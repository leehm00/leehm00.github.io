<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis事件 | homie's Home</title><meta name="author" content="homie"><meta name="copyright" content="homie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="redis事件数据结构&#x2F;&#x2F;事件处理器状态(同时是时间处理器和文件处理器) typedef struct aeEventLoop {     &#x2F;&#x2F;当前注册的最大描述符     int maxfd;   &#x2F;* highest file descriptor currently registered *&#x2F;     &#x2F;&#x2F;当前追踪的最大描述符     int setsize; &#x2F;* max number o">
<meta property="og:type" content="article">
<meta property="og:title" content="redis事件">
<meta property="og:url" content="https://leehm00.github.io/2022/01/27/redis-shi-jian/index.html">
<meta property="og:site_name" content="homie&#39;s Home">
<meta property="og:description" content="redis事件数据结构&#x2F;&#x2F;事件处理器状态(同时是时间处理器和文件处理器) typedef struct aeEventLoop {     &#x2F;&#x2F;当前注册的最大描述符     int maxfd;   &#x2F;* highest file descriptor currently registered *&#x2F;     &#x2F;&#x2F;当前追踪的最大描述符     int setsize; &#x2F;* max number o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leehm00.github.io/img/ibuki.png">
<meta property="article:published_time" content="2022-01-27T09:13:18.000Z">
<meta property="article:modified_time" content="2025-11-13T16:17:19.658Z">
<meta property="article:author" content="homie">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leehm00.github.io/img/ibuki.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "redis事件",
  "url": "https://leehm00.github.io/2022/01/27/redis-shi-jian/",
  "image": "https://leehm00.github.io/img/ibuki.png",
  "datePublished": "2022-01-27T09:13:18.000Z",
  "dateModified": "2025-11-13T16:17:19.658Z",
  "author": [
    {
      "@type": "Person",
      "name": "homie",
      "url": "https://leehm00.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leehm00.github.io/2022/01/27/redis-shi-jian/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: homie","link":"链接: ","source":"来源: homie's Home","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis事件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="homie's Home" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ibuki.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">homie's Home</span></a><a class="nav-page-title" href="/"><span class="site-name">redis事件</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">redis事件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-01-27T09:13:18.000Z" title="发表于 2022-01-27 09:13:18">2022-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kv/">kv</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="redis事件"><a href="#redis事件" class="headerlink" title="redis事件"></a>redis事件</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//事件处理器状态(同时是时间处理器和文件处理器)</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>
    <span class="token comment">//当前注册的最大描述符</span>
    <span class="token keyword">int</span> maxfd<span class="token punctuation">;</span>   <span class="token comment">/* highest file descriptor currently registered */</span>
    <span class="token comment">//当前追踪的最大描述符</span>
    <span class="token keyword">int</span> setsize<span class="token punctuation">;</span> <span class="token comment">/* max number of file descriptors tracked */</span>
    <span class="token comment">//时间事件的id,时间事件链表中记录了最大的id</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> timeEventNextId<span class="token punctuation">;</span>
    <span class="token comment">//已注册的文件事件</span>
    aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">/* Registered events */</span>
    <span class="token comment">//已经就绪,执行过处理器的文件事件</span>
    aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">/* Fired events */</span>
    <span class="token comment">//时间事件</span>
    aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span>
    <span class="token comment">//事件处理器开关</span>
    <span class="token keyword">int</span> stop<span class="token punctuation">;</span>
    <span class="token comment">//多路复用库的私有数据</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>apidata<span class="token punctuation">;</span> <span class="token comment">/* This is used for polling API specific data */</span>
    <span class="token comment">//处理事件之前要执行的函数</span>
    aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span>
    <span class="token comment">//处理事件之后要执行的函数</span>
    aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span></code></pre>



<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>服务器通过套接字和客户端连接,文件事件是对于套接字操作的抽象,通信过程会产生相应文件事件,服务器监听处理这些事件</p>
<ul>
<li><strong>本身单线程运行,但是I/O多路复用监听多个套接字</strong></li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* File event structure
 *
 * 文件事件结构
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>

    <span class="token comment">// 监听事件类型掩码，</span>
    <span class="token comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span>
    <span class="token comment">// 或者 AE_READABLE | AE_WRITABLE</span>
    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">/* one of AE_(READABLE|WRITABLE) */</span>

    <span class="token comment">// 读事件处理器</span>
    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>

    <span class="token comment">// 写事件处理器</span>
    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>

    <span class="token comment">// 多路复用库的私有数据</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>

<span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span></code></pre>



<h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul>
<li><p>套接字</p>
<ul>
<li>每当一个套接字准备好执行某项操作时,产生一个文件事件,一个服务器连接了多个套接字,可以产生多个文件事件</li>
<li>当套接字可读(客户端执行write或者close之后)或者有新的可应答套接字出现(新的connect建立)时,产生AE_READABLE事件;套接字变得可写(客户端执行read操作之后)时,产生AE_WRITABLE事件</li>
</ul>
</li>
<li><p>I/O多路复用程序</p>
<ul>
<li>负责监听多个套接字的上述两种事件,向文件事件分派器传送产生了事件的套接字</li>
<li>多个事件时先处理AE_READABLE事件,先读后写,多个套接字都有事件时按照一个队列传送,当上一个套接字的事件处理完毕之后再处理下一个套接字</li>
</ul>
</li>
<li><p>文件事件分派器</p>
<ul>
<li>根据传来的套接字调用相应的事件处理器</li>
</ul>
</li>
<li><p>事件处理器</p>
<ul>
<li>执行相关操作的函数</li>
</ul>
</li>
</ul>
<h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><ul>
<li><p>函数aeCreateFileEvent</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 根据 mask 参数的值，监听 fd 文件的状态，
 * 当 fd 可用时，执行 proc 函数
 * 将给定套接字的给定事件加入到I/O多路复用程序的监听范围
 * 将事件和事件处理器关联
 */</span>
<span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>
        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        errno <span class="token operator">=</span> ERANGE<span class="token punctuation">;</span>
        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 取出文件事件结构</span>
    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
    <span class="token comment">// 设置文件事件类型，以及事件的处理器</span>
    fe<span class="token operator">-&gt;</span>mask <span class="token operator">|=</span> mask<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>
    <span class="token comment">// 私有数据</span>
    fe<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>
    <span class="token comment">// 如果有需要，更新事件处理器的最大 fd</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">)</span>
        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeDeleteFileEvent</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 将 fd 从 mask 指定的监听队列中删除
 * i/o多路复用程序取消对给定套接字的给定事件的监听
 * 取消事件和事件处理器之间的关联
 */</span>
<span class="token keyword">void</span> <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 取出文件事件结构</span>
    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 未设置监听的事件类型，直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token comment">/* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> mask <span class="token operator">|=</span> AE_BARRIER<span class="token punctuation">;</span>
    <span class="token comment">// 取消对给定 fd 的给定事件的监视</span>
    <span class="token function">aeApiDelEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算新掩码</span>
    fe<span class="token operator">-&gt;</span>mask <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Update the max fd */</span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">!=</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeGetFileEvents</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 获取给定 fd 正在监听的事件类型
 * 返回正在监视的事件类型
 */</span>
<span class="token keyword">int</span> <span class="token function">aeGetFileEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> fe<span class="token operator">-&gt;</span>mask<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeWait</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* Wait for milliseconds until the given file descriptor becomes
 * writable/readable/exception
 * 在给定毫秒内等待，直到 fd 变成可写、可读或异常
 * 事件成功产生或者超时就返回 */</span>
<span class="token keyword">int</span> <span class="token function">aeWait</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> pfd<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retmask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pfd<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLIN<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLOUT<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> milliseconds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLOUT<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLERR<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLHUP<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
        <span class="token keyword">return</span> retmask<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeApiPoll</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*在指定时间内阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件
当有至少一个事件产生或者超时返回*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tvp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>apidata<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">,</span> j<span class="token punctuation">,</span> numevents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>rfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>wfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//根据select的retval决定之后的操作</span>
    retval <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">//监听得到的事件类型</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_READABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">)</span><span class="token punctuation">)</span>
                mask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_WRITABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">)</span><span class="token punctuation">)</span>
                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> j<span class="token punctuation">;</span>
            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> mask<span class="token punctuation">;</span>
            numevents<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"aeApiPoll: select, %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> numevents<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeProcessEvents</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 调用aeApiPoll等待事件产生,之后遍历所有产生的事件,处理所有已到达的时间事件，以及所有已就绪的文件事件
 * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪，
 * 或者下个时间事件到达（如果有的话）
 * 根据flag值确定相应的处理步骤
 * 函数的返回值为已处理事件的数量*/</span>
<span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> numevents<span class="token punctuation">;</span>

    <span class="token comment">/* Nothing to do? return ASAP */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_FILE_EVENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">/* Note that we want to call select() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">,</span> <span class="token operator">*</span>tvp<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> usUntilTimer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 距今最近的时间事件还要多久才能达到,使用usUntilTimer保存</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span>
            usUntilTimer <span class="token operator">=</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//还没有到达</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>usUntilTimer <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> usUntilTimer <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
            tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> usUntilTimer <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果时间事件已经到达(到达间隔时间为负数),将已到达时间事件的到达时间间隔设置为0</span>
            <span class="token comment">/* If we have to check for events but need to return
             * ASAP because of AE_DONT_WAIT we need to set the timeout
             * to zero */</span>
            <span class="token comment">// 执行到这一步，说明没有时间事件即将到达</span>
            <span class="token comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 设置文件事件不阻塞,将已到达时间事件的到达时间间隔设置为0</span>
                tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">/* Otherwise we can block */</span>
                <span class="token comment">// 文件事件可以阻塞直到有事件到达为止,wait时间设置为无穷</span>
                tvp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* wait forever */</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Call the multiplexing API, will return only on timeout or when
         * some event fires. */</span>
        <span class="token comment">// 处理文件事件，阻塞时间由 tvp 决定</span>
        numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* After sleep callback. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>aftersleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">aftersleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//从已就绪数组中获取事件</span>
            <span class="token keyword">int</span> fd <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> mask <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>
            <span class="token keyword">int</span> fired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Number of events fired for current fd. */</span>
            <span class="token keyword">int</span> invert <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_BARRIER<span class="token punctuation">;</span>
            <span class="token comment">//读取事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//确保读/写事件只能执行其中一个</span>
                fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                fired<span class="token operator">++</span><span class="token punctuation">;</span>
                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>
            <span class="token punctuation">}</span>

            <span class="token comment">/* Fire the writable event. */</span>
            <span class="token comment">//写事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">/* If we have to invert the call, fire the readable event now
             * after the writable one. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>invert<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            processed<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* Check time events */</span>
    <span class="token comment">//执行时间事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>
        processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> processed<span class="token punctuation">;</span> <span class="token comment">/* return the number of processed file/time events */</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ul>
<h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>实现不同的网络通信需求,主要是连接应答处理器,命令请求处理器,命令回复处理器</p>
<ul>
<li><p>连接应答处理器</p>
<ul>
<li><p>函数acceptTcpHandler对连接服务器监听套接字的客户端进行应答</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建一个TCP连接</span>
<span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> cport<span class="token punctuation">,</span> cfd<span class="token punctuation">,</span> max <span class="token operator">=</span> MAX_ACCEPTS_PER_CALL<span class="token punctuation">;</span>
    <span class="token keyword">char</span> cip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//accept客户端连接</span>
        cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cport<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//TCP连接函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cfd <span class="token operator">==</span> ANET_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span>
                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>
                    <span class="token string">"Accepting client connection: %s"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>neterr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Accepted %s:%d"</span><span class="token punctuation">,</span> cip<span class="token punctuation">,</span> cport<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 为客户端创建客户端状态（redisClient）</span>
        <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span><span class="token function">connCreateAcceptedSocket</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>cip<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<p>redis进行初始化时,将处理器与套接字的AE_READABLE事件连接起来,当由客户端使用sys/socket.h/connect函数连接服务器监听套接字时,套接字产生AE_READABLE事件,引发连接应答处理器执行,并执行相应的套接字应答操作</p>
<pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR

  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">连接监听套接字</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:服务器监听套接字产生的AE_READABLE事件,执行连接应答处理器]</span></code></pre></li>
</ul>
</li>
<li><p>命令请求处理器</p>
<ul>
<li><p>函数readQueryFromClient从套接字中读入客户端发送的命令请求内容</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 读取客户端的查询缓冲区内容
 */</span>
<span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nread<span class="token punctuation">,</span> big_arg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we want to read from the client later when exiting from
     * the event loop. This is the case if threaded I/O is enabled. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token comment">/* Update total number of reads on server */</span>
    <span class="token comment">//更新server的读入处理计数器</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_reads_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    readlen <span class="token operator">=</span> PROTO_IOBUF_LEN<span class="token punctuation">;</span>
    <span class="token comment">/* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_MULTIBULK <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>multibulklen <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">&gt;=</span> PROTO_MBULK_BIG_ARG<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ssize_t</span> remaining <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bulklen<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        big_arg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">/* Note that the 'remaining' variable may be zero in some edge case,
         * for example once we resume a blocked client after CLIENT PAUSE. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> readlen <span class="token operator">=</span> remaining<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 获取查询缓冲区当前内容的长度</span>
    <span class="token comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span>
    <span class="token comment">// 这些滞留内容也许不能完整构成一个符合协议的命令</span>
    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//为查询缓冲区分配空间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>big_arg <span class="token operator">||</span> <span class="token function">sdsalloc</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> PROTO_IOBUF_LEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* When reading a BIG_ARG we won't be reading more than that one arg
         * into the query buffer, so we don't need to pre-allocate more than we
         * need, so using the non-greedy growing. For an initial allocation of
         * the query buffer, we also don't wanna use the greedy growth, in order
         * to avoid collision with the RESIZE_THRESHOLD mechanism. */</span>
        <span class="token comment">//太长的指令参数只读入一个参数,查询缓冲区不需要多余分配空间,不使用贪心分配空间</span>
        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomForNonGreedy</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Read as much as possible from the socket to save read(2) system calls. */</span>
        readlen <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//读入内容到查询缓存</span>
    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//读入出错时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token operator">==</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Reading from client: %s"</span><span class="token punctuation">,</span><span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token comment">//遇到EOF</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>verbosity <span class="token operator">&lt;=</span> LL_VERBOSE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sds info <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Client closed connection %s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sdsfree</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Append the query buffer to the pending (not applied) buffer
         * of the master. We'll use this buffer later in order to have a
         * copy of the string applied by the last command executed. */</span>
        <span class="token comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span>
        <span class="token comment">// 并将 '\0' 正确地放到内容的最后</span>
        c<span class="token operator">-&gt;</span>pending_querybuf <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>pending_querybuf<span class="token punctuation">,</span>
                                        c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">sdsIncrLen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">&lt;</span> qblen<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">=</span> qblen<span class="token punctuation">;</span>
    <span class="token comment">// 记录服务器和客户端最后一次互动的时间</span>
    c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>
    <span class="token comment">// 如果客户端是 master 的话，更新它的复制偏移量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>read_reploff <span class="token operator">+=</span> nread<span class="token punctuation">;</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_input_bytes<span class="token punctuation">,</span> nread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span>
    <span class="token comment">// 清空缓冲区并释放客户端</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>client_max_querybuf_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sds ci <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        bytes <span class="token operator">=</span> <span class="token function">sdscatrepr</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span><span class="token punctuation">,</span> ci<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sdsfree</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sdsfree</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* There is more data in the client input buffer, continue parsing it
     * in case to check if there is a full command to execute. */</span>
    <span class="token comment">// 从查询缓存重读取内容，创建参数，并执行命令</span>
    <span class="token comment">// 函数会执行到缓存中的所有内容都被处理完为止</span>
     <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>当一个客户端通过连接应答处理器连接到服务器之后,客户端套接字的AE_READABLE事件和命令请求处理器相关联,当客户端向服务器发送命令请求时,产生AE_READABLE事件引发处理器执行,执行相关套接字读入工作</p>
<pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR

  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令请求</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:客户端套接字产生AE_READABLE事件,执行命令请求处理器]</span></code></pre></li>
</ul>
</li>
<li><p>命令回复处理器</p>
<ul>
<li><p>函数sendReplyToClient将服务器执行相关命令得到的命令回复通过套接字返回给客户端</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 负责传送命令回复的写处理器
 */</span>
 <span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//具体实现</span>
<span class="token punctuation">}</span></code></pre>

<p>具体实现的函数如下:</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Update total number of writes on server */</span>
    <span class="token comment">//更新写回复计数器</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_writes_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> objlen<span class="token punctuation">;</span>
    clientReplyBlock <span class="token operator">*</span>o<span class="token punctuation">;</span>
    <span class="token comment">//一直循环直到回复缓冲区为空</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bufpos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 写入内容到套接字</span>
            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>
            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时,</span>
            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上。</span>
            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>buf<span class="token operator">+</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>bufpos<span class="token operator">-</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//出错时跳出循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">//写入之后更新写入计数器变量</span>
            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>
            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>

            <span class="token comment">/* If the buffer was sent, set bufpos to zero to continue with
             * the remainder of the reply. */</span>
            <span class="token comment">// 如果缓冲区中的内容已经全部写入完毕</span>
            <span class="token comment">// 那么清空客户端的两个计数器变量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> c<span class="token operator">-&gt;</span>bufpos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                c<span class="token operator">-&gt;</span>bufpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//取出位于链表最前面的对象</span>
            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            objlen <span class="token operator">=</span> o<span class="token operator">-&gt;</span>used<span class="token punctuation">;</span>
            <span class="token comment">//空对象不做处理</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>objlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 写入内容到套接字</span>
            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>
            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时，</span>
            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上</span>
            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> o<span class="token operator">-&gt;</span>buf <span class="token operator">+</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//写入出错时跳出</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">//成功写入时更新计数器变量</span>
            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>
            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>

            <span class="token comment">/* If we fully sent the object on head go to the next one */</span>
            <span class="token comment">// 如果缓冲区内容全部写入完毕，那么删除已写入完毕的节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> objlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token comment">/* If there are no longer objects in the list, we expect
                 * the count of reply bytes to be exactly zero. */</span>
                <span class="token comment">//list之中没有对象,reply的字节数设置为0</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token function">serverAssert</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* 为了避免一个非常大的回复独占服务器，
         * 当写入的总数量大于 REDIS_MAX_WRITE_PER_EVENT ，
         * 临时中断写入，将处理时间让给其他客户端，
         * 剩余的内容等下次写入就绪再继续写入
         * 不过，如果服务器的内存占用已经超过了限制，
         * 那么为了将回复缓冲区中的内容尽快写入给客户端，
         * 然后释放回复缓冲区的空间来回收内存，
         * 这时即使写入量超过了 REDIS_MAX_WRITE_PER_EVENT ，
         * 程序也继续进行写入*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> NET_MAX_WRITES_PER_EVENT <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
             <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_output_bytes<span class="token punctuation">,</span> totwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写入出错检测</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span> <span class="token operator">!=</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span>
                <span class="token string">"Error writing to client: %s"</span><span class="token punctuation">,</span> <span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* For clients representing masters we don't count sending data
         * as an interaction, since we always send REPLCONF ACK commands
         * that take some time to just fill the socket output buffer.
         * We just rely on data / pings received for timeout detection. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span><span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">/* Note that writeToClient() is called in a threaded way, but
         * adDeleteFileEvent() is not thread safe: however writeToClient()
         * is always called with handler_installed set to 0 from threads
         * so we are fine. */</span><span class="token comment">//前面应该是aeDeleteFileEvent()</span>
        <span class="token comment">//不能直接删除write handler,因为本身调用就是在线程之中了,aeDeleteFileEvent()线程不安全</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>handler_installed<span class="token punctuation">)</span> <span class="token function">connSetWriteHandler</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Close connection after entire reply has been sent. */</span>
        <span class="token comment">// 如果指定了写入之后关闭客户端 FLAG ，那么关闭客户端</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>当访问有命令回复需要传送给客户端的时候将客户端套接字的AE_WRITABLE事件和命令回复处理器相关联,当客户端准备好接受服务器传回的命令回复时,产生AE_WRITABLE事件引发处理器执行,执行相关套接字写入工作</p>
<pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> RL

  a<span class="token text string">[服务器:客户端套接字产生AE_WRITABLE事件,执行命令回复处理器]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令回复</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">((客户端))</span></code></pre>

<p>回复发送之后就接触命令回复处理器和客户端套接字AE_WRITABLE事件之间的关联</p>
</li>
</ul>
</li>
<li><p>全过程:</p>
<pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR
a<span class="token text string">[客户端]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送连接请求,服务器执行连接应答处理器</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器]</span>
a<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送命令请求,服务器执行命令请求处理器</span><span class="token arrow operator">--&gt;</span></span>b
b<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">服务器向客户端发送命令回复,服务器执行命令回复处理器</span><span class="token arrow operator">--&gt;</span></span>a</code></pre></li>
</ul>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>(如serverCron函数)在给定时间点执行,时间事件就是对定时操作的抽象</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<h4 id="时间事件的结构"><a href="#时间事件的结构" class="headerlink" title="时间事件的结构"></a>时间事件的结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//时间事件的结构,种类包括定时事件和周期性事件</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>
    <span class="token comment">//事件的唯一标识符,从小到大表示从旧到新</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span>
    <span class="token comment">//事件的到达时间</span>
    monotime when<span class="token punctuation">;</span>
    <span class="token comment">//时间事件处理器,一个函数</span>
    <span class="token comment">//时间事件的种类决定于这个函数的返回值</span>
    <span class="token comment">//AE_NOMORE表示定时事件,到达一次之后被删除并且不会再次到达</span>
    <span class="token comment">//返回其他整数n表示周期性事件,服务器对事件的when属性进行更新,使之n毫秒之后再次到达</span>
    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>
    <span class="token comment">//事件释放函数</span>
    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>
    <span class="token comment">//多路复用库的私有数据</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
    <span class="token comment">//指向上一个和下一个时间事件结构,形成链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token comment">//防止在迭代过程中周期性事件被释放</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">/* refcount to prevent timer events from being
  		   * freed in recursive time event calls. */</span>
<span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span></code></pre>

<p>服务器将时间事件都放在一个链表中,每当时间事件处理器执行时遍历链表,对所有已到达的时间事件调用相应的事件处理器.</p>
<p>新事件放在链表头部,所以链表的头部事件id较大,无序是指when的无序</p>
<h4 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h4><ul>
<li><p>函数aeCreateTimeEvent将一个新的时间事件加入到服务器,在当前时间的milliseconds毫秒之后到达</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建事件计数器</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">,</span>
        aeTimeProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span>
        aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//更新时间计数器</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//创建时间事件结构</span>
    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>

    te <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
    <span class="token comment">//设置id</span>
    te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token comment">//设置事件</span>
    te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> milliseconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token comment">//设置事件处理器</span>
    te<span class="token operator">-&gt;</span>timeProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>
    te<span class="token operator">-&gt;</span>finalizerProc <span class="token operator">=</span> finalizerProc<span class="token punctuation">;</span>
    <span class="token comment">//私有数据</span>
    te<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>
    <span class="token comment">//将事件插入链表</span>
    te<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    te<span class="token operator">-&gt;</span>next <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>
    te<span class="token operator">-&gt;</span>refcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
        te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token punctuation">;</span>
    eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token punctuation">;</span>
    <span class="token keyword">return</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数aeDeleteTimeEvent删除给定id的时间事件</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//删除给定的时间事件</span>
<span class="token keyword">int</span> <span class="token function">aeDeleteTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>
    <span class="token comment">//遍历链表</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//发现目标事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//修改id之后,在processTimeEvents的时候删除</span>
            te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>
            <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span> <span class="token comment">/* NO event with the specified ID found  */</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数usUntilEarliestTimer返回到达时间距离当前时间最近的时间事件到达耗时</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//返回距离第一个时间事件触发的毫秒数</span>
<span class="token comment">//需要遍历链表,定时一般来说时间事件不多,遍历时间很短</span>
<span class="token keyword">static</span> <span class="token class-name">int64_t</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    aeTimeEvent <span class="token operator">*</span>earliest <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>earliest <span class="token operator">||</span> te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span>
            earliest <span class="token operator">=</span> te<span class="token punctuation">;</span>
        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>now <span class="token operator">&gt;=</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> earliest<span class="token operator">-&gt;</span>when <span class="token operator">-</span> now<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>函数processTimeEvents</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//处理到达的时间事件</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> maxId<span class="token punctuation">;</span>
    <span class="token comment">//遍历链表执行已到达的事件</span>
    te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span><span class="token comment">//指向链表头部</span>
    maxId <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>

        <span class="token comment">/* Remove events scheduled for deletion. */</span>
        <span class="token comment">//之前id已经设置为AE_DELETED_EVENT_ID的事件需要删除掉</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> AE_DELETED_EVENT_ID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            aeTimeEvent <span class="token operator">*</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token comment">/* If a reference exists for this timer event,
             * don't free it. This is currently incremented
             * for recursive timerProc calls */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>refcount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//有迭代子程序调用的事件不删除</span>
                te <span class="token operator">=</span> next<span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//修改相关的指针</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>prev<span class="token punctuation">)</span>
                te<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
                te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
            <span class="token comment">//执行清理处理器</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>finalizerProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                te<span class="token operator">-&gt;</span><span class="token function">finalizerProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>
                now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//释放要删除的时间事件</span>
            <span class="token function">zfree</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">;</span>
            te <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* Make sure we don't process time events created by time events in
         * this iteration. Note that this check is currently useless: we always
         * add new timers on the head, however if we change the implementation
         * detail, this check may be useful again: we keep it here for future
         * defense. */</span>
        <span class="token comment">//无效事件跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">&gt;</span> maxId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//当前时间大于等于时间事件的when,事件已到达,执行这个事件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;=</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> retval<span class="token punctuation">;</span>

            id <span class="token operator">=</span> te<span class="token operator">-&gt;</span>id<span class="token punctuation">;</span>
            te<span class="token operator">-&gt;</span>refcount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">//执行对应的文件处理器,记录返回值</span>
            retval <span class="token operator">=</span> te<span class="token operator">-&gt;</span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>
            te<span class="token operator">-&gt;</span>refcount<span class="token operator">--</span><span class="token punctuation">;</span>
            processed<span class="token operator">++</span><span class="token punctuation">;</span>
            now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//区分是否是定时事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> AE_NOMORE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//retval毫秒之后再次执行</span>
                te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> now <span class="token operator">+</span> retval <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">//直接删除</span>
                te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> processed<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>serverCron就是非常典型的周期性时间事件,服务器只要在运行就要周期性运行这个函数</p>
</li>
</ul>
<h2 id="redis运行流程"><a href="#redis运行流程" class="headerlink" title="redis运行流程"></a>redis运行流程</h2><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR

id1<span class="token text string">[启动服务器]</span><span class="token arrow operator">--&gt;</span>id7<span class="token text string">[配置和加载初始化]</span><span class="token arrow operator">--&gt;</span>id8<span class="token text string">[创建事件循环]</span><span class="token arrow operator">--&gt;</span>id10<span class="token text string">[开始socket监听]</span>
<span class="token arrow operator">--&gt;</span>id9<span class="token text string">[向循环事件中注册serverCron]</span>
<span class="token keyword">subgraph</span> 循环
id9<span class="token arrow operator">--&gt;</span>
id2<span class="token text string">{是否关闭服务器}</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">否</span><span class="token arrow operator">--&gt;</span></span>id4<span class="token text string">[等待文件事件产生]</span>
id4<span class="token arrow operator">--&gt;</span>id5<span class="token text string">[处理产生的文件事件]</span><span class="token arrow operator">--&gt;</span>id6<span class="token text string">[处理已到达的时间事件]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">开始新的事件循环</span><span class="token arrow operator">--&gt;</span></span>id2
<span class="token keyword">end</span>
id2<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">是</span><span class="token arrow operator">--&gt;</span></span>id3<span class="token text string">[关闭服务器]</span></code></pre>

<p><img src="/2022/01/27/redis-shi-jian/main_start_event_loop-3251881.png" alt="main_start_event_loop"></p>
<p>两张图的方式都差不多,展示了整个redis的过程</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://leehm00.github.io">homie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leehm00.github.io/2022/01/27/redis-shi-jian/">https://leehm00.github.io/2022/01/27/redis-shi-jian/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://leehm00.github.io" target="_blank">homie's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post-share"><div class="social-share" data-image="/img/ibuki.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/01/27/redis-ke-hu-duan/" title="redis客户端与服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">redis客户端与服务器</div></div><div class="info-2"><div class="info-item-1">redis客户端与服务器客户端 cli命令行 typedef struct multiCmd {     //参数     robj **argv;     //参数数量     int argc;     //命令指针     struct redisCommand *cmd; } multiCmd;  client结构(直接对于所有的数据结构进行了解释) //I/O复用,所以需要为每个客户端维持一个状态,多个客户端在服务器用链表链接 typedef struct client {     //client的id     uint64_t id;            /* Client incremental unique ID. */     connection *conn;     //协议版本     int resp;               /* RESP protocol version. Can be 2 or 3. */     //当前正在使用的数据库     redisDb *db;            /* Pointer to currentl...</div></div></div></a><a class="pagination-related" href="/2022/01/27/redis-dan-ji-shu-ju-ku/" title="redis单机数据库以及持久化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">redis单机数据库以及持久化</div></div><div class="info-2"><div class="info-item-1">单机数据库实现和持久化数据库细节实现 数据库的数据结构  源代码： typedef struct redisDb {     // 数据库键空间，保存着数据库中的所有键值对     dict *dict;                 /* The keyspace for this DB */     // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳     dict *expires;              /* Timeout of keys with a timeout set */     // 正处于阻塞状态的键     dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/     // 可以解除阻塞的键     dict *ready_keys;           /* Blocked keys that received a PUSH */     // 正在被 WATCH 命令监视的键     dict *watched_keys;  ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/03/04/redis-hotkey-solutions/" title="Redis hotkey solutions"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-04</div><div class="info-item-2">Redis hotkey solutions</div></div><div class="info-2"><div class="info-item-1">一、热点数据的存放场景：数据库中有2000w数据，而redis中只有100w数据，如何保证redis中存放的都是热点数据？ 方案：限定redis占用的内存，redis会根据自身数据淘汰策略，留下热数据到内存。所以可以计算100w数据大约占用的内存， 然后设置一下redis内存限制即可，并将淘汰策略设置为allkeys-lru或者volatile-lru.  设置redis最大占用内存：  　　　　打开redis配置文件，设置maxmemory参数，maxmemory是bytes字节类型哦！ 　　　　maxmemory 268435456  设置过期策略：  　　　　maxmemory-policy volatile-lru  当redis使用的内存超过设置的最大内存时，会触发redis的key淘汰机制，在redis3.0中的6中淘汰策略如下： noeviction :不删除策略。当达到最大内存限制时，如果需要使用更多内存，则直接返回错误信息（redis默认淘汰策略） allkeys-lru:在所有key中优先删除最近最少使用（less recently used，LRU）的key...</div></div></div></a><a class="pagination-related" href="/2022/03/16/build-cluster-with-bash-on-one-node/" title="build cluster with bash on one node"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-16</div><div class="info-item-2">build cluster with bash on one node</div></div><div class="info-2"><div class="info-item-1">在我自己的机器上进行实验，sh文件实现一条命令部署单个节点集群 下面是解析步骤 常量定义定义在另一个文件中 #!/bin/bash  # Redis_Cluster  # REDIS_SERVER_BIN="/home/k8s/homie/redis/src/redis-server" BASE_DIR=/home/k8s/homie REDIS_SERVER_BIN=$BASE_DIR/redis/src/redis-server REDIS_CLI_BIN=$BASE_DIR/redis/src/redis-cli REDIS_CLUSTER_BASE=$BASE_DIR/redis_cluster NODELIST="node2 node3 node4 node5" PORTS=`seq 7000 7005` BASEPORT=${ENTRY_PORT} HG_BASEPORT=${HG_PORT}  根据自己需要进行修改 安装redis# Check redis command if [ ! -f $REDIS_SERVER_BIN ]; then   echo "Red...</div></div></div></a><a class="pagination-related" href="/2022/03/09/redis-cluster-build/" title="redis cluster build"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="info-item-2">redis cluster build</div></div><div class="info-2"><div class="info-item-1">下载redis6.2.2并安装wget http://download.redis.io/releases/redis-6.2.2.tar.gz tar -zxvf ./redis-6.2.2.tar.gz mv redis-6.2.2 redis cd redis make  准备配置文件1、新建目录，并拷贝出6个节点的配置文件cd  redis-6.2.2 mkdir -p config mkdir -p log mkdir -p data mkdir -p node cp redis.conf ./config/redis-7000.conf  2、修改每个节点的配置文件内容远程访问需要把bind注释掉         # bind 127.0.0.1 修改端口号         port 7000 默认启动时为后台启动，yes为后台启动         daemonize yes 指定进程信息存储文件         pidfile /var/run/redis_7000.pid 指定日志文件(改成自己的路径)         logfile "/home/k8s/hom...</div></div></div></a><a class="pagination-related" href="/2022/04/22/redis-cluster-ji-qun-chang-yong-zhi-ling/" title="redis cluster集群常用指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="info-item-2">redis cluster集群常用指令</div></div><div class="info-2"><div class="info-item-1">1.redis 常用管理命令  https://redis.io/topics/rediscli   1.1 读写操作#读写操作$redis-cli -c -h 192.124.64.212 -p 6301 -a pwd123 set foo bar$redis-cli -c -h 192.124.64.212 -p 6301 -a pwd123 get foo$redis-cli -c -h 192.124.64.212 -p 6301 -a pwd123 del foo  1.2 查看内存等信息#查看内存等信息$redis-cli -h 192.124.64.212 -p 6301 -a pwd123 info$redis-cli -h 192.124.64.212 -p 6301 -a pwd123 info memory |grep human -i$redis-cli -h 192.124.64.212 -p 6301 -a pwd123 dbsize  1.3 查看key及bigkey#key的情况$redis-cli -c -h 192.124.64.212 -p ...</div></div></div></a><a class="pagination-related" href="/2022/03/05/redis-cluster/" title="redis cluster"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-05</div><div class="info-item-2">redis cluster</div></div><div class="info-2"><div class="info-item-1">redis集群理论单机遇到内存、并发、流量等瓶颈时，可以采用Cluster架构方案来达到负载均衡 一 基础理论1.1分区规则数据集按照分区规则映射到各个节点  常见哈希分区：  节点取余分区 使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式： hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。 缺点：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。 优点：这种方式的突出优点是简单，易理解； 这种方式常用于数据库的分库分表规则，一般采 用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张 表，保证可支撑未来一段时间的数据量，再根据负载情况将表迁移到其他数 据库中。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移 的情况  一致性哈希分区 一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token（范围一般在0~2^32），这些token构成一个哈希环。 数据读写 执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一...</div></div></div></a><a class="pagination-related" href="/2022/01/27/redis-dan-ji-shu-ju-ku/" title="redis单机数据库以及持久化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-27</div><div class="info-item-2">redis单机数据库以及持久化</div></div><div class="info-2"><div class="info-item-1">单机数据库实现和持久化数据库细节实现 数据库的数据结构  源代码： typedef struct redisDb {     // 数据库键空间，保存着数据库中的所有键值对     dict *dict;                 /* The keyspace for this DB */     // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳     dict *expires;              /* Timeout of keys with a timeout set */     // 正处于阻塞状态的键     dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/     // 可以解除阻塞的键     dict *ready_keys;           /* Blocked keys that received a PUSH */     // 正在被 WATCH 命令监视的键     dict *watched_keys;  ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Utterances</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ibuki.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">homie</div><div class="author-info-description">USTC | CS | Distributed System | In-memory Key-Value Store</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leehm00"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/leehm00" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:leehm0073@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">redis事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">文件事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API"><span class="toc-number">1.2.3.</span> <span class="toc-text">相关API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">文件事件处理器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">时间事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">时间事件的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">相关API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">redis运行流程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/13/diary251113/" title="diary251113">diary251113</a><time datetime="2025-11-13T21:30:09.000Z" title="发表于 2025-11-13 21:30:09">2025-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/12/zhen-si-jia-shi-eva-de-yuan-yin/" title="真嗣驾驶eva的原因">真嗣驾驶eva的原因</a><time datetime="2025-11-12T23:04:43.000Z" title="发表于 2025-11-12 23:04:43">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/12/diary251112/" title="diary251112">diary251112</a><time datetime="2025-11-12T15:38:05.000Z" title="发表于 2025-11-12 15:38:05">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/11/diary251111/" title="diary251111">diary251111</a><time datetime="2025-11-11T10:59:07.000Z" title="发表于 2025-11-11 10:59:07">2025-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/10/jin-bi-ta-ren-ji-di-yu-huan-shi-zi-wo-jie-zhi-guan-de-jian-li/" title="禁闭——他人即地狱还是自我价值观的建立">禁闭——他人即地狱还是自我价值观的建立</a><time datetime="2025-11-10T23:25:35.000Z" title="发表于 2025-11-10 23:25:35">2025-11-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By homie</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div><div class="footer_custom_text">Hi, welcome to my <a href="https://leehm00.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'leehm00/homepage_comment',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname/url/title/og:title'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://homepage-comment-kfulzg3zk-leehm00s-projects.vercel.app/',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.7.1/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.7.1/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Utterances' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Utterances' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>