<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式学习资料</title>
      <link href="/2022/02/14/fen-bu-shi-xue-xi-zi-liao/"/>
      <url>/2022/02/14/fen-bu-shi-xue-xi-zi-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>时下，随着通信技术的发展、移动互联网的普及、物联网车联网人工智能的兴起，每天所产生的数据呈爆炸性的增长。这种尺度的数据不是传统单机系统可以独立处理的，而只能借助于大规模的分布式系统，因而分布式系统渐渐的变成一门 “显学”。而作为一个分布式系统初学者，面对网上未加归类、浩如烟海的学习资料，很容易两眼抓瞎。</p><p>但分布式系统有其基本研究内容和独特发展脉络，比如：</p><ol><li>一些基本研究问题：时序问题、一致性问题、容错技术、共识算法、并发控制等等。</li><li>一些基本定理：CAP、PACELC、FLP</li><li>渐次发展的工业系统：MapReduce、Spark、GFS、Dynamo、Cosmos</li></ol><p>因此只需要在 “时空” 两个维度对分布式系统进行把握，就能提纲挈领，愈学愈明。“<strong>时</strong>” 表示分布式系统的演进脉络，可以通过阅读不同时期、学术界工业界的一些论文来把握。“<strong>空</strong>” 表示分布式系统中所研究的基本问题的拆解，可以通过阅读一些书籍建立分布式系统的知识体系。本文将我在学习分布式系统知识过程搜集到的一些资料，按类别简单汇总，以飨诸君。资料排名没有先后，请按需采用。</p><p><strong>注：</strong>文中推荐的资料大多为英文，如果阅读有困难，推荐使用 Chrome 浏览器，并且给 Chrome 装一个 “<a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb">google 翻译</a>” 的插件，可以点击一键 “翻译此页面”。</p><p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/2021/05/16/distributed-system-material/">https://www.qtmuniao.com/2021/05/16/distributed-system-material/</a>, 转载请注明出处</em></p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Dr-Martin-Kleppmann-Designing-Data-Intensive-Applications"><a href="#Dr-Martin-Kleppmann-Designing-Data-Intensive-Applications" class="headerlink" title="Dr. Martin Kleppmann. Designing Data-Intensive Applications"></a>Dr. Martin Kleppmann. Designing Data-Intensive Applications</h3><p>《构建数据密集型应用》，<a href="https://dataintensive.net/buy.html%EF%BC%8C%E4%BD%9C%E8%80%85%E6%8F%90%E4%BE%9B%E5%85%8D%E8%B4%B9%E8%8B%B1%E6%96%87%E7%89%88%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%BD%91%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E5%88%B0%E3%80%82">https://dataintensive.net/buy.html，作者提供免费英文版下载，网上也可以搜到。</a></p><p>全书分为三大部分：</p><ol><li>系统基石（Foundations of Data System）</li><li>分散数据（Distributed Data）</li><li>衍生数据（Derived Data）</li></ol><p><strong>系统基石</strong>部分探讨了数据系统的一些通用侧面：</p><ol><li>可靠性、可扩展性、可维护性（Reliable, Scalable, and Maintainable Applications）</li><li>数据模型和查询语言（Data Models and Query Languages）</li><li>数据存储和检索（Storage and Retrieval）</li><li>数据编码和演进（Encoding and Evolution）</li></ol><p><strong>分散数据</strong>部分讨论了构建分散在多机上的数据系统和一些原则和面临的问题：</p><ol><li>冗余（replication）</li><li>分片（Partition）</li><li>事务（Transactions）</li><li>分布式系统存在的问题（The Trouble With Distributed Systems）</li><li>一致性和共识（Consistency and Consensus）</li></ol><p><strong>衍生数据</strong>部分其实是在探讨分散在多机上的系统的处理问题。包括：</p><ol><li>批处理（Batch Processing）</li><li>流式处理（Stream Processing）</li><li>数据系统的未来（The Future of Data Systems）</li></ol><p>近年来流批系统趋于融合，从而让用户能够更加灵活、高效的对原始数据进行处理和变换。</p><p>这些章节拆分的都非常棒。熟读本书，让你在遇到一个新系统时，可以如庖丁解牛一般熟练拆解成为多个构件，并了每个构件背后的权衡取舍（trade off）。</p><h3 id="M-van-Steen-and-A-S-Tanenbaum-Distributed-Systems-3rd-ed-distributed-systems-net-2017"><a href="#M-van-Steen-and-A-S-Tanenbaum-Distributed-Systems-3rd-ed-distributed-systems-net-2017" class="headerlink" title="M. van Steen and A.S. Tanenbaum, Distributed Systems, 3rd ed., distributed-systems.net, 2017."></a>M. van Steen and A.S. Tanenbaum, Distributed Systems, 3rd ed., <a href="http://distributed-systems.net/">distributed-systems.net</a>, 2017.</h3><p>《分布式系统》第三版，<a href="https://www.distributed-systems.net/index.php/books/ds3/%E3%80%82%E4%BD%9C%E8%80%85%E6%8F%90%E4%BE%9B%E8%8B%B1%E6%96%87%E7%89%88">https://www.distributed-systems.net/index.php/books/ds3/。作者提供英文版</a> PDF 免费下载链接，简介：</p><p>本书分为九个小结：</p><ul><li>简介（Introduction）</li><li>架构（Architecture）</li><li>进程（Processes）</li><li>通信（Communication）</li><li>命名系统（Naming）</li><li>协同（Coordination）</li><li>一致性和多副本（Consistency and replication）</li><li>容错（Fault Tolerance）</li><li>安全（Security）</li></ul><p>作者还提供了 Python 示例代码和图表下载。</p><h3 id="Mikito-Takada-Distributed-System-for-fun-and-profit"><a href="#Mikito-Takada-Distributed-System-for-fun-and-profit" class="headerlink" title="Mikito Takada. Distributed System for fun and profit"></a>Mikito Takada. Distributed System for fun and profit</h3><p>一本免费的分布式系统小书：<a href="http://book.mixu.net/distsys/%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%BE%E8%AE%A1%E8%80%83%E9%87%8F%EF%BC%8C%E5%8A%A9%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9F%A5%E5%90%8D%E7%9A%84%E5%95%86%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%A6%82">http://book.mixu.net/distsys/，介绍了分布式系统中的一些关键概念和设计考量，助你了解知名的商用系统如</a> Dynamo、BigTable、MapReduce、Hadoop 背后的设计原理。作者将分布式编程的考量归结为两个方面：</p><ol><li>信息以光速传递</li><li>分离组件会独立出错</li></ol><p>然后将全书分为五个小结：</p><ol><li><strong>分布式系统基础（Basics）</strong>：粗粒度的介绍了一些名词和概念，探讨了系统的目标以及实现的难度</li><li><strong>自上而下的层层抽象（Up and down the level of abstraction）</strong>：介绍了 CAP 定理和 FLP impossibility ，然后探讨了多种一致性模型。</li><li><strong>时与序（time and order</strong>）。理解分布系统的关键之一，便是要理解分散的组件如何确定时间的先后顺序。</li><li><strong>多副本：避免分裂（Replication: preventing divergence）</strong>：多副本间如何保持一致</li><li><strong>多副本：接受分歧（Replication: accepting divergence）</strong>：多副本间如何处理冲突</li></ol><h2 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h2><h3 id="MIT-6-824-Distributed-Systems"><a href="#MIT-6-824-Distributed-Systems" class="headerlink" title="MIT 6.824: Distributed Systems"></a>MIT 6.824: Distributed Systems</h3><p>最经典的分布式系统课程之一：<a href="https://pdos.csail.mit.edu/6.824/schedule.html%E3%80%82">https://pdos.csail.mit.edu/6.824/schedule.html。</a></p><p>课程亮点在于：</p><ol><li>精选的论文列表</li><li>精巧的实验设计</li></ol><p>非常适合自学。</p><h3 id="Cambridge-Concurrent-and-Distributed-Systems"><a href="#Cambridge-Concurrent-and-Distributed-Systems" class="headerlink" title="Cambridge Concurrent and Distributed Systems"></a>Cambridge Concurrent and Distributed Systems</h3><p>剑桥大学的并发和分布式课程， <a href="https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/materials.html">https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/materials.html</a></p><p>DDIA 作者 Martin Kleppmann 主讲。</p><h3 id="CMU-15-440-Distributed-Systems"><a href="#CMU-15-440-Distributed-Systems" class="headerlink" title="CMU 15-440: Distributed Systems"></a>CMU 15-440: Distributed Systems</h3><p>cmu 的分布式系统：<a href="https://www.cs.cmu.edu/~dga/15-440/S14/syllabus.html%E3%80%82">https://www.cs.cmu.edu/~dga/15-440/S14/syllabus.html。</a></p><h3 id="standford-cs244b-Distributed-System"><a href="#standford-cs244b-Distributed-System" class="headerlink" title="standford cs244b Distributed System"></a>standford cs244b Distributed System</h3><p>斯坦福的分布式系统课程：<a href="http://www.scs.stanford.edu/20sp-cs244b/">http://www.scs.stanford.edu/20sp-cs244b/</a></p><p>CS244b 是一个讨论课，也给了一些经典的论文列表。</p><h3 id="UW-CSE490H-Distributed-Systems"><a href="#UW-CSE490H-Distributed-Systems" class="headerlink" title="UW CSE490H: Distributed Systems"></a>UW CSE490H: Distributed Systems</h3><p>华盛顿大学的分布式系统课程：<a href="https://courses.cs.washington.edu/courses/cse490h/11wi/%E3%80%82%E6%9C%80%E8%BF%91%E5%87%A0%E5%B9%B4%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%B2%A1%E6%9C%89%E5%BC%80%E8%BF%98%E6%98%AF%E6%B2%A1%E6%9C%89%E5%85%AC%E5%BC%80%EF%BC%8C%E6%9C%80%E8%BF%91%E7%9A%84%E6%98%AF">https://courses.cs.washington.edu/courses/cse490h/11wi/。最近几年的课程没有开还是没有公开，最近的是</a> 2011 年的。也提供了一个不错的论文阅读列表。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol><li>Hadoop， <a href="https://github.com/apache/hadoop">https://github.com/apache/hadoop</a> ，Java：可以通过 tag 看早期代码，包含 MapReduce 和 GFS 的开源实现</li><li>seaweedfs ，<a href="https://github.com/chrislusf/seaweedfs%EF%BC%8C">https://github.com/chrislusf/seaweedfs，</a> Golang：参考了 Facebook Haystack 和 F4</li><li>Minio，<a href="https://github.com/minio/minio%EF%BC%8C">https://github.com/minio/minio，</a> Golang：一个经典的开源实现的对象存储</li><li>TiDB，<a href="https://github.com/pingcap/tidb%EF%BC%8CGolang%EF%BC%8C%E6%8F%90%E4%BE%9B">https://github.com/pingcap/tidb，Golang，提供</a> MySql 访问接口的分布式数据库</li></ol><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><ol><li>Etcd，<a href="https://github.com/etcd-io/etcd%EF%BC%8CGolang%EF%BC%9ARaft">https://github.com/etcd-io/etcd，Golang：Raft</a> 的一个实现，用于 k8s 中。也可以用于任何分布式系统的控制面的数据存储。</li><li>Zookeeper，<a href="https://github.com/apache/zookeeper%EF%BC%8CJava%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BA%86">https://github.com/apache/zookeeper，Java：实现了</a> Zab 共识协议，最初用于 Hadoop 中存储元信息，地位和 Etcd 类似。</li></ol><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ol><li>Spark，<a href="https://github.com/apache/spark%EF%BC%8CScala%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E3%80%81%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E">https://github.com/apache/spark，Scala：一个大数据处理、分析引擎</a></li><li>Flink，<a href="https://github.com/apache/flink%EF%BC%8CJava%EF%BC%9A%E6%B5%81%E6%89%B9%E4%B8%80%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E">https://github.com/apache/flink，Java：流批一体的数据处理引擎</a></li><li>Ray，<a href="https://github.com/ray-project/ray%EF%BC%8CPython/C++%EF%BC%9A%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B%E5%BC%BA%E5%A4%A7%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E">https://github.com/ray-project/ray，Python/C++：表达能力强大的通用计算引擎</a></li></ol><h2 id="系列博客"><a href="#系列博客" class="headerlink" title="系列博客"></a>系列博客</h2><h3 id="写给分布式系统初学者的一些笔记"><a href="#写给分布式系统初学者的一些笔记" class="headerlink" title="写给分布式系统初学者的一些笔记"></a>写给分布式系统初学者的一些笔记</h3><p>Jeff Hodges <a href="https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/</a></p><p>博主将从事分布式系统工作所得到的经验教训做了一个概要性的总结，对新人进入分布式领域转换思想很有启发性作用。包括：</p><ol><li>故障频发是分布式系统区别于其他系统的显著特点</li><li>构建健壮的分布式系统要远难于单机系统</li><li>分布式系统的开源协作不同于单机系统</li><li>多机协同很难</li><li>很慢这个事情在分布式系统中很难定位</li><li>寻找使服务部分可用的手段</li><li>充分利用局部性原理</li><li>使用 CAP 原理来审视你的分布式系统</li><li>…</li></ol><h3 id="给分布式系统工程师的一些分布式理论"><a href="#给分布式系统工程师的一些分布式理论" class="headerlink" title="给分布式系统工程师的一些分布式理论"></a>给分布式系统工程师的一些分布式理论</h3><p><a href="https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/">https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/</a></p><p>博主给出了分布式系统的一个入门路径和参考资料：</p><ol><li><strong>第一步（First steps）：</strong>推荐了一些书</li><li><strong>故障和时序（Failure and Time）</strong>：分布系统中最重要的两个基石，给出了一些经典论文引用</li><li><strong>容错的基本考量（The basic tension of fault tolerance）</strong>：要做冗余以容错，但过分冗余又会浪费性能</li><li><strong>基本源语（Basic primitives）</strong>：分布系统中的一些基本概念论文链接，包括选举算法、一致性快照、共识协议、分布式状态机、广播、链式冗余。</li><li><strong>一些工业系统论文列表</strong>：谷歌的居多，非谷歌的也有一些</li></ol><h2 id="Meetup"><a href="#Meetup" class="headerlink" title="Meetup"></a>Meetup</h2><h3 id="Papers-we-love"><a href="#Papers-we-love" class="headerlink" title="Papers we love"></a>Papers we love</h3><p>PapersWeLove 计算机论文分享： <a href="https://www.zhihu.com/column/c_1353678180390162432">https://www.zhihu.com/column/c_1353678180390162432</a></p><h3 id="Microsoft-Distributed-System-Meetup"><a href="#Microsoft-Distributed-System-Meetup" class="headerlink" title="Microsoft-Distributed-System-Meetup"></a>Microsoft-Distributed-System-Meetup</h3><p>微软同学搞的一个分布式系统 meetup，包括 一块学 6.824、一块读 DDIA、有意思的主题演讲等等：<a href="https://microsoft-distributed-system-meetup.github.io/home/">https://microsoft-distributed-system-meetup.github.io/home/</a></p><h3 id="Distributed-Systems-Reading-Group"><a href="#Distributed-Systems-Reading-Group" class="headerlink" title="Distributed Systems Reading Group"></a>Distributed Systems Reading Group</h3><p>MIT 同学在 2013 年搞的一个论文阅读小组：<a href="http://dsrg.pdos.csail.mit.edu/papers/">http://dsrg.pdos.csail.mit.edu/papers/</a></p><p>包括共识协议、数据冗余、事务相关、并发问题等等。</p><h3 id="计算机系统学习小组"><a href="#计算机系统学习小组" class="headerlink" title="计算机系统学习小组"></a><strong>计算机系统学习小组</strong></h3><p>@<a href="https://www.zhihu.com/people/hu-jin-ming-31">胡津铭</a> 组织的系统学习小组：<a href="https://learn-sys.github.io/cn/">https://learn-sys.github.io/cn/</a></p><h3 id="The-Last-Thing"><a href="#The-Last-Thing" class="headerlink" title="The Last Thing"></a>The Last Thing</h3><p>最后，附赠一个 github 上经典的 awesome 系列中，分布式系统的 repo：<a href="https://github.com/theanalyst/awesome-distributed-systems">https://github.com/theanalyst/awesome-distributed-systems</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anna论文笔记</title>
      <link href="/2022/02/10/anna-lun-wen-bi-ji/"/>
      <url>/2022/02/10/anna-lun-wen-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记"><a href="#Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记" class="headerlink" title="Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记"></a>Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年前被学长安利了分布式最终一致性的存储系统 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 。初略看了一眼Paper，似乎很是牛X。说是支持任意规模的扩展，并且性能不低于 <a href="https://github.com/fastio/pedis">pedis</a>。于是抽空来看看并了解下这套系统的设计特点和这种夸张的单机性能和扩展性的来源。</p><h1 id="主流分布式KVS的比较"><a href="#主流分布式KVS的比较" class="headerlink" title="主流分布式KVS的比较"></a>主流分布式KVS的比较</h1><table><thead><tr><th>系统名词</th><th>扩容设计</th><th>内存模型</th><th>针对单个Key的一致性策略</th><th>针对多个Key一致性策略</th></tr></thead><tbody><tr><td>Masstree</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Bw-tree</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>PALM</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>MICA</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Redis</td><td>单核</td><td>N/A</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a></td></tr><tr><td>COPS, Bolt-on</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a></td></tr><tr><td>Bayou</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, 单调读/写, <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td></tr><tr><td>Dynamo</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Cassandra</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>PNUTS</td><td>分布式</td><td>消息队列</td><td>线性写, 单调读</td><td>无</td></tr><tr><td>CouchDB</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Voldemort</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>HBase</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Riak</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>DocumentDB</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, <a href="https://www.allthingsdistributed.com/2007/12/eventually_consistent.html"><strong>Session</strong></a>, <a href="http://pbs.cs.berkeley.edu/"><strong>Bounded Staleness</strong></a>, <a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Memcached</td><td>多核&amp;分布式</td><td>共享内存&amp;消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>MongoDB</td><td>多核&amp;分布式</td><td>共享内存&amp;消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>H-Store</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a></td></tr><tr><td>ScyllaDB</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Anna</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, Item Cut, Writes Follow Reads, 单调读/写, <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a>, <a href="https://en.wikipedia.org/wiki/PRAM_consistency"><strong>PRAM</strong></a></td><td><a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a>, <a href="https://jepsen.io/consistency/models/read-uncommitted"><strong>Read Uncommitted</strong></a></td></tr></tbody></table><blockquote><p>一致性说明:</p><ul><li><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a> 是指在更新了某行之后，后续的客户端不会读到老数据，通常用在单行一致性上，最强的一致性模型；</li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a> 是指在更新了某行之后，后续的客户端可能在某些（缓存）结点上会读到老数据（特别是并发执行的事务），但是最后（一段时间后）一定会读到一致的最新数据；</li><li><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a> 是指对多个读写同一行数据的事务，采用排序和排队执行的机制，这样也能保证数据的严格一致性，但是通常这涉及加锁（<a href="https://ai.google/research/pubs/pub39966">spanner</a>/<a href="https://ai.google/research/pubs/pub41344">f1</a>）或单点原子化操作（<a href="https://redis.io/">redis</a>）；</li><li><strong>单调读(Monotonic Reads)</strong> 是指在某一个客户端读取到新数据后，不会再读到老数据，但是有可能在更新一行后短期内客户端仍然读到老数据，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><strong>单调写(Monotonic Writes)</strong> 是指对单个客户端的写入操作一定是有序的，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a> 是指在某个客户端上对一组Key的读写操作会被认为有因果关系，那么在进程上也都保持一样的可见性顺序，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种。通常通过 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 实现；</li><li><a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 是指当一个数据行被更新后，这个进程后面的读操作一定会读到这个新值。通常如果数据库系统有 <strong>N个副本节点</strong> ， <strong>W个节点感知到写入</strong> ， <strong>R个节点对读操作返回的数据一致</strong> ， 且如果 <strong>W + R &gt; N</strong> ， 那么我们认为当前系统符合 <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 一致性，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="https://www.allthingsdistributed.com/2007/12/eventually_consistent.html"><strong>Session</strong></a> 是<a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a>的一种更具体的行为，即每一次客户端连接到服务器的Session中保证 <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 一致性，如果重新建立Session则不保证，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="http://pbs.cs.berkeley.edu/"><strong>Bounded Staleness</strong></a> 是指读取操作最多滞后于写入操作最多k个版本或t个周期之后，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><strong>Writes follows reads</strong> 是指对一个Key的读操作后一定跟着这个Key的写操作；</li><li><a href="https://en.wikipedia.org/wiki/PRAM_consistency"><strong>PRAM</strong></a> 是指对于某个进程对多个Key的写入，其他进程看到的写入顺序和这个写入进程的写入顺序一致。因为这些Key在这个写入进程上是同一个pipeline；</li><li><a href="https://jepsen.io/consistency/models/read-uncommitted"><strong>Read Uncommitted</strong></a> 是指对同一组事务禁止 <em><strong>脏写</strong></em> ，即多个未提交事务同时修改一组数据；</li><li><a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a> 是指事务读取数据时，不允许看到其他未提交事务所写入的数据，通常涉及多个事务并发执行且需要访问同一组数据；</li></ul><p>See <a href="https://en.wikipedia.org/wiki/Consistency_model">https://en.wikipedia.org/wiki/Consistency_model</a> for more details</p></blockquote><h1 id="Anna-架构设计"><a href="#Anna-架构设计" class="headerlink" title="Anna 架构设计"></a><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 架构设计</h1><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 整体上依赖 <a href="https://en.wikipedia.org/wiki/Semilattice"><strong>bounded join semilattice</strong></a> (文中简称 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> ) 的核心设计，也就是代数结构中讲的格。</p><p>数学上 <a href="https://en.wikipedia.org/wiki/Semilattice">Semilattice</a> 符合 <strong>ACI</strong> 特性：</p><ul><li><p>交换律（Commutativity）: $\sqcup (a, b) = \sqcup (b, a), \forall_{a,b} \in S⊔(a,b)=⊔(b,a),∀a,b∈S $，即操作和顺序无关</p></li><li><p>结合律（Associativity）:$$ \sqcup (\sqcup (a, b), c) = \sqcup (a, \sqcup (b, c)), \forall_{a,b,c} \in S⊔(⊔(a,b),c)=⊔(a,⊔(b,c)),∀a,b,c∈S$$ ，即操作和先后次序无关</p></li><li><p>幂等性（Idempotence）: $\sqcup (a, a) = a, \forall_{a} \in S⊔(a,a)=a,∀a∈S$ ，即操作多次不影响结果</p></li><li><p><strong>join-semilattice</strong> : join操作 $\sqcup (a, b)⊔(a,b) $指a,b的最小上界。</p><blockquote><p>这里是数学定义，我的理解在 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 中指数据合并操作。</p></blockquote></li><li><p><strong>bounded</strong> : 指存在特定元素 <strong>1</strong>，使得 $\sqcup (a, 1) = a , \forall_{a,1} \in S⊔(a,1)=a,∀a,1∈S$</p></li></ul><p>详见维基百科: <a href="https://en.wikipedia.org/wiki/Semilattice">https://en.wikipedia.org/wiki/Semilattice</a></p><p>我的理解就是一个比较细粒度的模块化数据块，互相之间没有强交互和关联，大多数情况下仅处理自己的数据集。然后对于数据合并的操作，要设计成符合上面的 <strong>ACI</strong> 特性。</p><p>在 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的基础上，很容易就可以设计出适合这种场景的分布式状态模型和通信模型。</p><p>整个架构使用了actor模型。和 <a href="https://github.com/scylladb/seastar">seastar</a> 框架相似，系统采用多线程结构，并且按CPU核心数分配线程。并且和 golang 的核心思想一样，用 <strong>Message-passing</strong> 来 <strong>shared-memory</strong> 。 这样虽然是多线程，但是每个线程跑自己的 <strong>Actor Core</strong> ，在业务处理的时候互相之间几乎不需要互相通信。每个actor线程由自己的数据变更集(<strong>changeset</strong>)，然后定期访问广播通道执行集群管理或者是合并操作。</p><p><img src="/2022/02/10/anna-lun-wen-bi-ji/1905-01.png" alt="1905-01.png"></p><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的key和节点的分布也是一致性哈希。采用 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 算法来处理actor的容灾和扩缩容。按文中的意思似乎数据分片的同步也采用的是 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 。不过在这一点上 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 对分布式系统的局部分片扩容天生是比 <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a> 和 <a href="https://raft.github.io/">Raft</a> 要好很多。</p><p>另外在 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的actor中，记录了所有其他actor最后感知到这个actor事件的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> ，这样在多副本时，比如出现任意副本对某个Key的删除操作，就可以用因果关系感知到其他副本的actor都同步了这个事件之后再执行真正的垃圾回收操作。这就避免了不一致的时候再被同步回来的问题。这个事件最差情况也会由广播机制定期同步。</p><blockquote><p>其实有点怀疑这种方案在大规模集群上的延迟，这样意味着每个actor两两之间都需要比较高密度的数据同步。后面给出的各项测试模式里也没有涉及大量节点和大规模跨机器的测试结果。大多数给的都是少数机器几十个节点的性能报告。</p></blockquote><h1 id="弹性可扩展的一致性策略"><a href="#弹性可扩展的一致性策略" class="headerlink" title="弹性可扩展的一致性策略"></a>弹性可扩展的一致性策略</h1><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是通过设计成一个无需交互，并且让内部符合ACI特性来实现这个高性能高并发的KVS的。<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 通过一种自底向上的方法，通过把复杂数据结构切割成一个一个的 <a href="https://en.wikipedia.org/wiki/Semilattice"><strong>ACI Building Blocks（Lattice）</strong></a> 来保证整体的保持ACI特性。系统内置了一些一致性模型的设计，然后用户也可以自定义Merge函数。 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的设计重点之一就是方便用户可以用 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 已有提供好的符合 <strong>ACI</strong> 的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 来组合成自己需要的也符合 <strong>ACI</strong> 的新形态。然后以此来很方便地实现上面提到的那么多种一致性策略。</p><blockquote><p>文中说是以C++模板来实现易扩展的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的。感觉和STL的思路比较像。</p></blockquote><p>比如说实现了 <strong>MapLattice</strong> （KV结构） 、 <strong>PairLattice</strong> （带版本号的数据对） 、 <strong>MaxIntLattice</strong> （递增整数） 、 <strong>ValueLattice</strong> （用户自定义数据）。可以按下面的结构实现 <a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a>。</p><p><img src="/2022/02/10/anna-lun-wen-bi-ji/1905-02.png" alt="1905-02.png"></p><p>如图，使用Key为 ClientID， Value为 <strong>MaxIntLattice</strong> 的 <strong>MapLattice</strong> 来实现因果一致性所需的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 。 大部分情况下，分片稳定并且系统运行良好的情况下，数据的因果关系可以通过 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 判定出来。少数情况下，如果发生了冲突，就要走冲突合并流程了。只要合并操作符合上面的 <strong>ACI</strong> 特性，等到一定时间窗以后，无论哪个节点先执行合并、数据合并的顺序是怎样，一定会有一个统一的最终结果。</p><blockquote><p>比如合并数据的时候采用按时间+节点ID排序，然后舍弃老数据。就是无论怎么合并。最终的结果一定是一致的。</p></blockquote><p>再比如 <a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a> 的一致性策略。 其他的部分和 <a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a> 一样，只要把维护Key的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 改成用 <strong>MaxIntLattice</strong> 表示的最大时间戳，然后合并策略改成按最新时间戳就行了。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>看 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 对比其他的 KVS 都是碾压的，但是我个人对其他 KVS的设计不熟，对 <a href="https://redis.io/">redis</a> 倒是比较熟悉。所以这里贴出来它和 <a href="https://redis.io/">redis</a> (主要是 redis-cluster) 的对比。</p><p><img src="//anna%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/1905-03.png" alt="1905-03.png"></p><p>如图，在低争用的情况下，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的表现和 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 相近。在高争用的时候，这里说是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的优势比较明显。但是我个人的理解， <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的这部分性能完全来自于对一致性的舍弃上。 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 是很容易配置成强一致，但是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是采用了多个 <strong>Actor Core</strong> 独立运行，然后最终进行Merge的形式。那么在高争用的时候， <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 相当于收敛到了少数节点上运行，但是仍然是可以实现保证一致性的；而 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是先跑完再Merge，这种的话一致性就比较差，也很难实现CAS类的操作（否则也会fallback到少数节点执行，那么和 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的设计模式就相背离了）。</p><p>它在性能消耗分析的部分也说明了，如果一致性策略选的比较弱的话，多副本高争用的情况下还会有Merge开销激增的情况。这个Merge因为是跨节点通信的操作，在Paper提供的3副本的部署结构下大约69%的CPU消耗在这上面。所以影响还是蛮大的，相当于单点性能退化了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终一致性和强一致性的数据库系统还是有很大区别，最终一致性不能保证大家看到的中间状态是一致的，并且可能需要自己去选择或者提供冲突时的处理方法。感觉上可能比较适合非关键性数据的分发和存储。至少在游戏项目中，感觉更实用的还是能保证强一致性的系统，即便是NoSQL系统。因为很多东西有比较复杂的逻辑关系，不太能接受多个节点结果不一致的状态。</p><p>上面 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 和其他系统的比较里也有列出一些强一致性的系统，我觉得和这些强一致的系统比性能其实不太公平。但是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的一些设计层面的东西还是值得参考的，比如它对worker的设计和考量。这方面它和 <a href="https://github.com/fastio/pedis">pedis</a> 也很像，而且 <a href="https://github.com/fastio/pedis">pedis</a> 性能比它没差太多，但是我的理解没错的话它可以保持强一致，感觉更胜一筹。当然 <a href="https://github.com/fastio/pedis">pedis</a> 功能上目前实现也还是弱了一些，事务的支持和CAS的支持都没有。也就是说乐观锁和悲观锁都还不支持，目前还是没法用于要求强一致的业务里，也就和 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 没太大区别了。</p><p>从分布式设计来看，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 和 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 的大体结构是一样的。节点间通信都是消息传递，节点维护都是 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> ，节点收到其他节点的请求都是redirect过去。区别是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 使用的多线程设计， 而 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 是多进程模型；<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 提供了更完备的proxy层，而redis-cluster目前这方面还得靠客户端支持；然后 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 对于resharding的自动化更好一些，并且还实现了热Key的动态副本。如果单单从单点性能的话，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是和redis差不多的。</p><p>个人感觉 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 最大的优势还是在于它的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的设计。这极大地方便了对多种一致性策略的扩展。以后如果有什么新的技术方案出来也能够比较容易在这上面实现和测试。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anna </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体制内还是体制外工作</title>
      <link href="/2022/01/31/ti-zhi-nei-huan-shi-ti-zhi-wai-gong-zuo/"/>
      <url>/2022/01/31/ti-zhi-nei-huan-shi-ti-zhi-wai-gong-zuo/</url>
      
        <content type="html"><![CDATA[<p>看到这个我觉得就是经济学家纯纯傻逼，</p><blockquote><p>经济学家向松祚表示：</p><blockquote><p>我看到这些优秀的清北毕业生，都去考公，我觉得很遗憾。我觉得这是不应该的，就说中国这些顶级大学的学生出来，应该主要是去做科学家，企业家，思想家和艺术家。学生可以做这些，不能去当官，如果一窝蜂都去当官了，就是没有希望了。</p></blockquote></blockquote><p>要不是这些尸位素餐只会说大话的在占着位置，谁愿意内卷，不内卷为什么又去卷体制内，而且什么鬼依靠读的大学来决定，解决温饱才有可能做科学家企业家思想家艺术家，得有相应的生活保证才有心思去创造好不好。</p><p>民营企业的工作强度太大，那么去体制内工作未尝不是一个理性的选择。这种情况大概回到了8、90年代时候大学毕业生的情况，那时候的大学毕业生都喜欢去国有单位和事业单位，拿铁饭碗。</p><p>王朔在1984年就在小说里提到了多数人最喜欢的工作：“少干活，多拿钱；不干活，也拿钱。”</p><p>体制内的工作，实际上就是王朔所说的这种工作。</p><p>只能说是其他的工作压力导致大家的选择偏向了公职，</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>译Dynamo Amazon&#39;s Highly Available Key-value Store</title>
      <link href="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/"/>
      <url>/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://arthurchiao.art/blog/amazon-dynamo-zh/">arthurchiao.art /blog/amazon-dynamo-zh/</a></p><h1 id="译-论文-Dynamo-Amazon’s-Highly-Available-Key-value-Store（SOSP-2007）"><a href="#译-论文-Dynamo-Amazon’s-Highly-Available-Key-value-Store（SOSP-2007）" class="headerlink" title="[译] [论文] Dynamo: Amazon’s Highly Available Key-value Store（SOSP 2007）"></a>[译] [论文] Dynamo: Amazon’s Highly Available Key-value Store（SOSP 2007）</h1><p>39-49 minutes</p><hr><p>Published at 2019-07-06 | Last Update 2019-07-06</p><h3 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h3><p>本文翻译自 2007 年 Amazon 的分布式存储经典论文：<strong>Dynamo: Amazon’s Highly Available Key-value Store</strong> (<a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">PDF</a>)。</p><p>标题直译为：<strong>《Dynamo：Amazon 的高可用键值仓库（存储）》</strong>。</p><p>对排版做了一些调整，以更适合 web 阅读。</p><p>Dynamo 是 Amazon 的高可用分布式键值存储（key/value storage）系统。这篇论文发表 的时候（2007）它还只是一个内部服务，现在（改名为 DynamoDB）已经发展成 AWS 最核心 的存储产品（服务）之一，与 S3 等并列。据了解，国内某一线大厂的公有云键值 存储服务，也是参考这篇文章设计和实现的。</p><p>现在提到键值存储，大家首先想到的可能是 Redis，那么 Dynamo 和 Redis 是不是竞品， 只是一个开源一个是商业的？不是的，二者针对的场景不同，这里非常粗地列举几方面：</p><ol><li>使用场景：Dynamo 定位是永远可写（always writable）的持久文件系统，Redis 主要用作（易失）缓存或内存数据库</li><li>存储方式：Dynamo 是磁盘，Redis 是内存</li><li>系统规模：Dynamo 是<strong>分布式</strong>（distributed）存储系统，设计之初（2006）就能支 撑几百台 node；Redis 是<strong>单机或集群（主从复制</strong>），规模不同</li><li>性能指标：以上差异必然导致各自设计时的性能考虑（例如延迟、吞吐、容错等）和实 际的性能量级不同</li></ol><p>精读一篇经典比泛读几十篇水文收获要大的多，尤其是那些领域开山之作。这篇论文适合精读。</p><p><strong>翻译仅供个人学习交流。由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问， 请查阅原文。</strong></p><p>以下是译文。</p><hr><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Amazon 是世界上最大的电商之一。</p><p>在这里我们所遇到的最大挑战之一就是<strong>超大规模下的稳定性问题</strong>（reliability at massive scale）。即使是最微小的故障（the slightest outage），也会造成巨大的经济 损失，而且会降低客户对我们的信任。Amazon.com 作为一个为全球提供 web 服务的平台， 其底层的基础设施是由分布在全球的数据中心中成千上万的服务器和网络设备组成的。在如 此庞大的规模下，大大小小的组件故障是不断在发生的，而我们应对这些故障时所采取 的<strong>管理持久状态的方式</strong>（the way persistent state is managed），<strong>驱动着软件系 统的可靠性（reliability）和可扩展性（scalability）的发展</strong>。</p><p>本文介绍 Dynamo —— 一个<strong>高可用键值存储系统</strong> —— 的设计和实现。Amazon 的一些核心 服务就是基于 Dynamo 提供不间断服务的（always-on experience）。为了达到这种等级的 可用性（level of availability），Dynamo <strong>牺牲了几种特定故障场景下的一致性</strong>。另 外，Dynamo 大量使用了<strong>对象版本化</strong>（object versioning）和<strong>应用协助的冲突解决</strong> （application-assisted conflict resolution）机制，给开发者提供了一种新颖的接口。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>Amazon 是一个全球电商平台，峰值用户达到几千万。支撑 Amazon 的是分布在全球的数据 中心中成千上万的服务器。Amazon 平台对<strong>性能、可靠性和效率</strong>等指标有着很高的要求 。而且，为了支撑持续增长（continous growth），平台需要有<strong>高度的可扩展性</strong>。<strong>可 靠性是我们最重要的需求之一</strong>，因为即使是最微小的故障也会造成巨大的经济损失，而且 会降低客户对我们的信任。</p><p>我们从打造 Amazon 平台的切身实践中总结出的一条经验是：<strong>一个系统的可靠性和可扩展 性取决于如何管理它的应用状态</strong>。</p><blockquote><p>The reliability and scalability of a system is dependent on how its application state is managed.</p></blockquote><p>Amazon 使用的是高度去中心化的、松耦合的、面向服务的架构，由几百个服务组成。这样 的环境对<strong>永远可用</strong>（always available）的存储技术有着强烈的需求。例如，<strong>即使磁 盘挂掉、路由抖动、甚至数据中心被飓风摧毁，用户应该仍然能向他们的购物车添加和查看 商品</strong>。要实现这样的目标，管理购物车的系统就必须永远能读写它的 数据仓库，而且 数据仓库还要跨多个数据中心可用。</p><p>对于我们这种由几百万台设备组成的基础设施，故障是家常便饭；在任何时刻都会有<strong>比例小 但数量不少</strong>（small but significant number）的服务器和网络设备发生故障。因此， Amazon 的软件系统要<strong>将故障视为正常的、可预期的行为（treat failure handling as the normal case），不应因设备故障而影响可用性和性能</strong>。</p><p>为了满足可靠性和可扩展性的需求，Amazon 开发了一些存储技术，S3 （Simple Storage Service）可能是最广为人知的一种。本文介绍 Amazon 的另一个存储产品 Dynamo —— 一个 高可用键值存储数据仓库（data store）—— 的设计和实现。</p><p>Dynamo 用于管理<strong>对可靠性要求非常高的服务</strong>的状态，这些服务还要求对可靠性、一致 性、成本-效率（cost-effectiveness）和性能有很强的控制能力。</p><blockquote><p>Dynamo is used to manage the state of services that have very high reliability requirements and need tight control over the tradeoffs between availability, consistency, cost-effectiveness and performance.</p></blockquote><p>Amazon 平台有很多类型的应用，不同的类型对存储的需求差异很大。例如，其中一类应用 希望能 <strong>数据仓库的配置足够灵活，以便在成本最经济的方式下，由开发者来决定如何 在可用性和性能之间取得折中</strong>。</p><p>Amazon 的一些服务<strong>只需以主键（primary key）的方式访问数据仓库</strong>。对于很多服 务，例如畅销排行榜、购物车、客户喜好偏向、session 管理、销售排名、商品目录等等， 常见的关系型数据库会非常低效，而且限制了规模的扩展性和可用性。Dynamo 提供了只使 用主键（primary key only）的访问接口来满足这类应用的需求。</p><p><strong>Dynamo 基于一些众所周知的（well known）技术实现了可扩展性和高可用性</strong>：</p><ul><li>数据通过<strong>一致性哈希</strong>分散和复制（partitioned and replicated）[10]</li><li>通过<strong>对象版本化</strong>（object versioning）实现一致性 [12]</li><li>副本之间的一致性由一种<strong>类似仲裁的技术</strong>（quorum-like technique）和一个去中 心化的<strong>副本同步协议</strong>（replica synchroni protocol）保证</li><li>gossip-based 分布式故障检测和成员检测（membership）协议</li></ul><p>Dynamo 是一个只需最少人工管理的、完全去中心化的系统。</p><blockquote><p>Dynamo is a completely decentralized system with minimal need for manual administration.</p></blockquote><p>向 Dynamo 添加或移除存储节点不需要人工 partition（调整哈希节点）或 redistribution（在节点之间重新平衡数据分布）。</p><p>Dynamo 在过去的几年已经成为 Amazon 很多核心服务的底层存储技术。在节假日购物高峰 ，它能实现不停服（平滑）扩容以支持极高的峰值负载。例如购物车服务的几千万请求会 产生单日 300 万次的付款动作，管理 session 状态的服务能处理几千万的并发活跃用户等 等。</p><p><strong>本文对该领域的主要贡献</strong>：</p><ul><li>评估了如何通过组合不同技术实现一个高度可用的（highly-available）系统</li><li>证明了最终一致性存储系统可以用于生产环境，满足应用的高要求</li><li>展示了若干优化技术，以满足生产环境的非常严格的性能要求</li></ul><p>本文章节结构介绍（略，见下面全文）。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p>Amazon 的电商平台由几百个服务组成，它们协同工作，提供的服务包罗万象，从推荐系统 到订单处理到欺诈检测等等。每个服务对外提供定义良好的 API，被其他服务通过网络的方 式访问。这些服务运行在分布在全球的数据中心中，成千上万的服务器组成的基础设施之上 。有些服务是无状态的（例如，聚合其他服务的响应的服务），有些是有状态的（例如，基 于存储在数据仓库里的状态，执行业务逻辑并产生响应的服务）。</p><p>传统上，生产系统使用关系型数据库来存储状态。但对很多<strong>持久状态的存储</strong>需求来说， 关系型数据库并不是一种理想的方式。这一类型中的大多数服务只用主键去检索，并不需要 RDBMS 提供的复杂查询和管理功能。这些额外的功能需要昂贵的硬件和专门的技能，而实际 上服务根本用不到，最终的结果就是使用关系型数据库非常不经济。另外，这类数据库的复 制功能很受限，而且通常是靠<strong>牺牲可用性来换一致性</strong>。虽然近些年有了一些改进，但总 体来说水平扩展（scale-out）以及使用智能（smart）partitioning 来做负载均衡还是很不 方便。</p><p>本文介绍 Dynamo 是如何解决以上需求的。Dynamo 有易用的 key/value 接口，高度可用 ，有定义清晰的一致性窗口（clearly defined consistency window），资源使用效率很高 ，并且有易用的水平扩展方案以解决请求量或数据增长带来的挑战。<strong>每个使用 Dynamo 的 服务，使用的都是它们独立的一套 Dynamo 系统</strong>。</p><blockquote><p>Each service that uses Dynamo runs its own Dynamo instances.</p></blockquote><h3 id="2-1-系统假设与需求"><a href="#2-1-系统假设与需求" class="headerlink" title="2.1 系统假设与需求"></a>2.1 系统假设与需求</h3><p>Dynamo 对使用它的服务有如下几点假设。</p><h4 id="查询模型（Query-Model）"><a href="#查询模型（Query-Model）" class="headerlink" title="查询模型（Query Model）"></a>查询模型（Query Model）</h4><p><strong>通过唯一的 key 对数据进行读写</strong>。状态以<strong>二进制对象</strong>（binary objects，e.g. blobs）形式存储，以唯一的 key 索引。</p><p><strong>任何操作都不会跨多个 data items</strong>（数据单元），没有关系型 schema 需求。</p><p>Dynamo 面向的应用<strong>存储的都是相对较小的文件（一般小于 1 MB）</strong>。</p><h4 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h4><p>ACID（Atomicity, Consistency, Isolation, Durability）是一组保证数据库事务可 靠执行的特性。在数据库领域，对数据的单次逻辑操作（single logical operation） 称为一次事务（transaction）。 我们在 Amazon 的实践表明，让数据仓库支持 ACID 会使得它的可用性（availability） 非常差，工业界和学术界也已经就这一点达成了广泛共识 [5]。</p><p><strong>Dynamo 的目标应用具有这样的特点：如果能给可用性（CAP 里面的 A）带来很大提升 ，那牺牲一些一致性（C）也是允许的</strong>。</p><p>Dynamo 不提供任何隔离保证，并且只允许带单个 key 的更新操作（permit only single key updates）。</p><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><p>系统需要运行在通用硬件（commodity hardware）之上。Amazon 的服务对延迟有着严格的 要求，通常用百分位值（percentile）<code>P99.9</code> 衡量。</p><p>考虑到对状态数据的访问是服务的核心操作之一，我们的存储系统必须满足那些严格的 SLA （见 Section 2.2）。另外，服务要有配置 Dynamo 的能力，以便能满足服务的延迟和吞吐 需求。最终，就是在性能、成本效率、可用性和持久性之间取得折中。</p><h4 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h4><p>Dynamo 定位是 Amazon 内部使用，因此我们假设环境是安全的，不需要考虑认证和鉴权 等安全方面的问题。</p><p>另外，<strong>由于设计中每个服务都使用各自的一套 Dynamo，因此 Dynamo 的初始设计规模是 几百个存储节点</strong>。后面会讨论可扩展性限制的问题，以及可能的解决方式。</p><h3 id="2-2-SLA-Service-Level-Agreements"><a href="#2-2-SLA-Service-Level-Agreements" class="headerlink" title="2.2 SLA (Service Level Agreements)"></a>2.2 SLA (Service Level Agreements)</h3><p>要<strong>保证一个应用完成请求所花的时间有一个上限</strong>（bounded time），它所依赖的那些服 务就要有一个更低的上限。<strong>对于给定的系统特性</strong>，其中最主要的是客户端期望的<strong>请求 率分布</strong>（request rate distribution），<strong>客户端和服务端会定义一个 SLA（服务级别 协议）</strong>来作为契约。</p><p>举个简单例子：某个服务向客户端保证，在 500 QPS 的负载下，它处理 <code>99.9%</code> 的请求 所花的时间都在能 <code>300ms</code> 以内。</p><p>在 Amazon 的去中心化的、面向服务的基础设施中，SLA 扮演着重要角色。例如，对购物 页面的一次请求，在典型情况下会使渲染引擎向多达 150 个服务发送子请求，而这些子服 务又都有自己的依赖，最终形成一张多层的（more than one level）调用图（call graph ）。为了保证渲染引擎能在一个上限时间内返回一个页面，调用链中的所有服务就都必须遵 循各自的性能契约（contract）。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/1.png" alt="img"></p><p>图 1 Amazon 平台的面向服务架构</p><p>图 1 是一张简化之后的 Amazon 平台架构图。可以看到，动态 web 内容由页面渲染组件 提供，而它是通过调用其他的一些服务来完成这项工作的。</p><p><strong>每个服务可以选择不同类型的数据仓库（data store）来管理（存储）它们的状态数据， 这些数据仓库只能在各自的服务边界（service boundaries）内访问</strong>。一些服务会通过聚 合其他服务的数据来组合产生一个响应（composite response）。典型情况下，聚合服务（ aggregator service）是无状态的，虽然它们大量使用缓存技术。</p><p>对于面向性能的 SLA（performance oriented SLA），业内一般习惯使用<strong>平均值、中位数 和方差</strong>来描述。但在 Amazon 我们发现，要打造一个让所有用户——而不是大部分用户——都 有良好体验的系统，以上 SLA 并不合适。例如，<strong>如果使用了个性化推荐技术，那用户的 访问历史越多，他的请求被处理的时间就越长，最终落到了性能分布的长尾区</strong>。基于平均 值或中位数的 SLA 并不能反映这种情况。为了解决这个问题，<strong>我们使用了 <code>P99.9</code> 分布。<code>99.9%</code> 这个精度是经过大量实验分析，权衡了成本和性能之后得到的</strong>。 我们在生产环境的实验显示，这比基于均值或中位数的 SLA 有更好的用户体验。</p><p>本文多处都将引用 P99.9 分布，这也显示了 Amazon 的工程师对提高用户体验所做的持续 不断的努力。一些基于均值的论文，我们会在它真正有意义的场景才拿出来作为比较，但我 们自己的工程和优化都不是以<strong>均值 SLA</strong> 为核心的。某些技术，例如 write coordinator（写操作协调者），是完全面向 P99.9 来控制性能的。</p><p><strong>存储系统在构建一个服务的 SLA 中经常扮演着重要角色，尤其是业务逻辑相对轻量的 场景</strong>，Amazon 的服务即属于这一类。因此，<strong>状态管理</strong> 就成了服务的 <strong>SLA 的主要 部分</strong>。</p><p><strong>Dynamo 的设计目标之一就是：允许服务自己控制自己的系统特性</strong>——例如持久性和一 致性——<strong>让服务自己决定如何在功能、性能和成本效率之间取得折中</strong>。</p><blockquote><p>One of the main design considerations for Dynamo is to give services control over their system properties, such as durability and consistency, and to let services make their own tradeoffs between functionality, performance and cost-effectiveness.</p></blockquote><h3 id="2-3-设计考虑"><a href="#2-3-设计考虑" class="headerlink" title="2.3 设计考虑"></a>2.3 设计考虑</h3><p><strong>商业系统中数据复制算法一般都是同步的，以提供一个强一致性的数据访问接口。 为了达到这种级别的一致性，这些算法被迫牺牲了某些故障场景下的数据可用性</strong>。例如， 如果数据有冲突，它们会禁止访问这个数据，直到数据的不一致完全得到了解决。在早期，这 种<strong>复制式数据库</strong>（replicated database）是可以工作的。</p><p>但众所周知，分布式系统是无法同时满足<strong>强一致性、高可用性和正确处理网络故障（CAP ）</strong>这几个条件的 [2, 11]。<strong>因此，系统和应用都需要知道，在什么场景下选择满足什么 特性</strong>。</p><p>对于<strong>服务器和网络故障较高的场景</strong>，可以通过<strong>乐观复制</strong>（optimistic replication ）技术增强<strong>可用性</strong>，在后台将数据变动同步到其他节点，并发更新和失联也是可以容忍 的。这种方式的问题是会<strong>导致数据冲突，需要检测并解决冲突</strong>。而解决数据冲突又会带 来两个额外问题：</p><ul><li>何时解决？</li><li>谁来解决？</li></ul><p><strong>Dynamo 设计为最终一致数据仓库</strong>（eventually consistent data store），即，最终 所有的更新会应用到所有的副本。</p><h4 id="何时解决冲突？"><a href="#何时解决冲突？" class="headerlink" title="何时解决冲突？"></a>何时解决冲突？</h4><p>设计时的一个重要考虑是：<strong>何时解决更新冲突</strong>，例如，是读的时候还是写的时候。</p><blockquote><p>An important design consideration is to decide when to perform the process of resolving update conflicts, i.e., whether conflicts should be resolved during reads or writes.</p></blockquote><p>一些传统的数据仓库是在<strong>写的时候解决冲突</strong>，这样可以<strong>保证读的复杂度很低</strong> [7]。 在这种系统中，任何时候<strong>如果数据仓库不能访问所有（或者大多数）副本，写就会被拒绝</strong>。</p><p>Dynamo 的设计与此相反，它的目标是提供一个<strong>“永远可写”（always writable）</strong>的数据 仓库（例如，一个对写操作高度可用的数据仓库）。对很多 Amazon 服务来说，拒绝写 入会造成很差的用户体验。比如即使发生服务器或网络故障，也应该允许用户往购物车添 加或删除商品。<strong>这个需求使我们将解决冲突的复杂度放到了读操作，以保证写永远不会 被拒绝</strong>。</p><h4 id="谁来解决冲突？"><a href="#谁来解决冲突？" class="headerlink" title="谁来解决冲突？"></a>谁来解决冲突？</h4><p>下一个需要考虑的问题是：<strong>谁来解决冲突</strong>。<strong>数据仓库</strong>和<strong>应用</strong>都可以做这件事情。</p><p><strong>如果由数据仓库来做，那选择会相当受限</strong>。在这种情况下，数据仓库只能使用一些 非常简单的策略，例如<strong>“最后一次写有效”</strong>（last write wins） [22]，来解决更新冲突。</p><p>另一方面，由于<strong>应用理解数据描述的是什么</strong>（application is aware of the data schema），<strong>它可以自主选择对用户体验最好的冲突解决算法</strong>。例如，购物车应用可以选择“ 合并”冲突的版本，返回一个合并后的（unified）购物车。尽管这样可以带来很大的灵活性 ，但一些应用开发者并不想自己实现一套冲突解决机制，因此在这种情况下，解决冲突的问 题就下放给了数据仓库，由后者来选择一些简单的策略，例如 “last write wins”。</p><h4 id="其他设计原则"><a href="#其他设计原则" class="headerlink" title="其他设计原则"></a>其他设计原则</h4><ul><li><strong>增量扩展性</strong>（Incremental scalability）：应当支持<strong>逐机器（节点）扩容</strong>，而 且对系统及运维人员带来的影响尽量小</li><li><strong>对称性</strong>（Symmetry）：<strong>每个节点的职责应该是相同的</strong>，不应当出现某些节点承担 特殊职责或特殊角色的情况。以我们的实践经验，<strong>对称性简化了系统的交付和运维</strong></li><li><strong>去中心化</strong>（Decentralization）：<strong>“去中心化”是“对称性”的进一步扩展</strong>，系统应 该是去中心化的、点对点的，而不应该是集中式控制的。在过去，集中式控制导致了很多 服务故障（outage），我们应当极力避免它。去中心化会使得系统更简单、更具扩展性和 可用性</li><li><strong>异构性</strong>（Heterogeneity）：系统要能够利用到基础设施的异构性。例如，<strong>负载的 分布要和存储节点的能力成比例</strong>。对于逐步加入能力更强的新节点，而不是一次升级所 有节点来说，这种异构支持能力是不可或缺的</li></ul><h2 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h2><h3 id="3-1-点对点系统（Peer-to-Peer-Systems）"><a href="#3-1-点对点系统（Peer-to-Peer-Systems）" class="headerlink" title="3.1 点对点系统（Peer to Peer Systems）"></a>3.1 点对点系统（Peer to Peer Systems）</h3><p>一些点对点（peer-to-peer, P2P）系统关注了<strong>数据存储和分散</strong>（data storage and distribution）的问题。</p><h4 id="P2P-系统"><a href="#P2P-系统" class="headerlink" title="P2P 系统"></a>P2P 系统</h4><p>第一代 P2P 系统，例如 Freenet 和 Gnutella，在文件共享系统（file sharing system） 领域使用广泛。它们都是<strong>非受信（untrusted）P2P 网络</strong>的代表，节点之间的 overlay （网络术语，和 underlay 对应，请参考 Wikipedia 或其他资料，译者注）链路都是随机 （随意）建立的（established arbitrarily）。在这种网络中，一次查询请求通常是<strong>泛 洪（flood）到整张网络，找到尽量多的共享这个数据的节点</strong>。</p><h4 id="结构化-P2P-系统"><a href="#结构化-P2P-系统" class="headerlink" title="结构化 P2P 系统"></a>结构化 P2P 系统</h4><p>P2P 网络到下一代，就是有名的<strong>结构化 P2P 网络</strong>（structured P2P network）。这种 网络使用了全局一致性协议（globally consistent protocol），保证<strong>任何一个节点可以 高效地将查询请求路由到存储这个数据的节点</strong>。</p><p>Pastry [16] 和 Chord [20] 这样的系统<strong>利用路由机制可以保证查询在若干（有上限） 跳</strong>（a bounded number of hops）之内收到应答。</p><p>为了减少多跳（multi-hop）路由带来的额外延迟，一些 P2P 系统（例如 [14]）使用了 <strong><code>O(1)</code>路由机制</strong>，在这种机制中，<strong>每个节点维护了足够多的路由信息</strong>，因此它可以 将（访问数据的）请求在常量跳数（constant number of hops）内路由到合适的对端节点 。</p><p>包括 Oceanstore [9] 和 PAST [17] 在内的很多存储系统都是构建在这种路由（routing） overlay 之上的。Oceanstore 提供全球分布的、事务型的、持久的存储服务，支持分布在 很大地理范围内的副本的串行化更新（serialized updates on widely replicated data） 。<strong>为了支持并发更新，同时避免广域锁</strong>（wide-are locking）内在的一些问题，它使用了一 种基于冲突解决（conflict resolution）的更新模型。conflict resolution 在 [21] 中 提出，用于减少事务异常中止（transaction abort）的数量。<strong>Oceanstore 处理冲突的方式是 ：对并发更新进行排序（order），将排好序的若干个更新作为原子操作应用到所有副本</strong>。 Oceanstore 是为在<strong>不受信的基础设施上做数据复制的场景</strong>设计的。</p><p>作为对比，PAST 是在 Pastry 之上提供了一个简单的抽象层，以此来提供持久和<strong>不可变对 象</strong>（persistent and immutable objects）。它假设<strong>应用可以在它之上构建自己需要的 存储语义</strong>（storage semantics）（例如可变文件）。</p><h3 id="3-2-分布式文件系统与数据库"><a href="#3-2-分布式文件系统与数据库" class="headerlink" title="3.2 分布式文件系统与数据库"></a>3.2 分布式文件系统与数据库</h3><p>文件系统和数据库系统领域已经对<strong>通过分散数据（distributing data）来提高性能、可 用性和持久性</strong>进行了广泛研究。和 <strong>P2P 存储系统只支持扁平命名空间</strong>（flat namespace）相比，<strong>典型的分布式文件系统都支持层级化的命名空间</strong>（hierarchical namespace）。</p><ul><li>Ficus [5] 和 Coda [19] 这样的系统通过文件复制来提高可用性，代价是牺牲一致性。 解决更新冲突一般都有各自特殊的解决方式</li><li>Farsite [1] 是一不使用中心式服务器（例如 NFS）的分布式文件系统，它通过复制实现 高可用和高扩展</li><li><strong>Google File System</strong> [6] 是另一个分布式文件系统，用于存储 Google 内部应用的 状态数据。GFS 的设计很简单，一个主节点（master）管理所有元数据，数据进行分片（ chunk），存储到不同数据节点（chunkservers）。</li><li>Bayou 是一个分布式关系型数据库系统，允许在失联情况下进行操作（disconnected operation），提供最终一致性</li></ul><p>在这些系统中，Bayou、Coda 和 Ficus 都支持失联情况下进行操作，因此对网络分裂和宕 机都有很强的弹性，它们的不同之处在于如何解决冲突。例如，Coda 和 Ficus 在系统层面 解决（system level conflict resolution），而 Bayou 是在应用层面（application level）。相同的是，它们都提供最终一致性。与这些系统类似，<strong>Dynamo 允许在网络发生 分裂的情况下继续执行读写操作，然后通过不同的冲突解决机制来处理更新冲突</strong>。</p><p>分布式块存储系统（distributed block storage system），例如 FAB [18]，将一个大块 分割成很多小块并以很高的可用性的方式存储。和这类系统相比，<strong>我们的场景更适合使用键 值存储</strong>，原因包括：</p><ul><li>系统定位是<strong>存储相对较小的文件</strong>（ <code>size &lt; 1 MB</code>）</li><li><strong>键值存储</strong>（key-value store）更容易在应用级别<strong>针对单个应用</strong>（per-application）进行配置</li></ul><p>Antiquity 是一个广域分布式文件系统，设计用于处理多个服务器挂掉的情况 [23]。它使 用<strong>安全日志</strong>（secure log）保证数据完整性，在不同服务器之间复制 secure log 来保 证持久性（durability），使用<strong>拜占庭容错协议</strong>（Byzantine fault tolerance protocols）保证数据一致性。与此不同，<strong>Dynamo 并不将数据完整性和安全性作为主要关 注点，因为我们面向的是受信环境</strong>。</p><p><strong>Bigtable 是一个管理结构化数据</strong>（structured data）的分布式文件系统，它维护了一 张稀疏的多维有序映射表（sparse, multi-dimensional sorted map），允许应用通过多重 属性访问它们的数据（access their data using multiple attributes） [2]。与此不同 ，<strong>Dynamo 面向的应用都是以 key/value 方式访问数据的，我们的主要关注点是高可用</strong> ，即使在发生网络分裂或服务器宕机的情况下，写请求也是不会被拒绝的。</p><p>传统的复制型关系数据库系统（replicated relational database systems）都将关注点放 在<strong>保证副本的强一致性</strong>。虽然强一致性可以<strong>给应用的写操作提供方便的编程模型</strong>， 但导致系统的扩展性和可用性非常受限 [7]，无法处理网络分裂的情况。</p><h3 id="3-3-讨论"><a href="#3-3-讨论" class="headerlink" title="3.3 讨论"></a>3.3 讨论</h3><p>Dynamo 面临的需求使得它与前面提到的集中式存储系统都不相同。</p><p>首先，Dynamo 针对的主要是<strong>需要“永远可写的”（always writable）数据仓库的应用</strong>， 即使发生故障或并发更新，写也不应该被拒绝。对于 Amazon 的很多应用来说，这一点是非 常关键的。</p><p>第二，Dynamo 构建在<strong>受信的、单一管理域的基础设施</strong>之上。</p><p>第三，使用 Dynamo 的应用<strong>没有层级命名空间（hierarchical namespace）的需求</strong>（这是很 多文件系统的标配），也没有复杂的关系型 schema 的需求（很多传统数据库都支持）。</p><p>第四，Dynamo 是为<strong>延迟敏感型应用</strong>（latency sensitive application）设计的，至少 <code>99.9%</code> 的读写操作都要在几百毫秒内完成。为了到达如此严格的响应要求，在多节点 之间对请求进行路由的方式（被很多分布式哈希表系统使用，例如 Chord 和 Pastry ）就无法使用了。因为多跳路由会增加响应时间的抖动性，因此会增加长尾部分的延迟。 Dynamo 可以被描述为：一个<strong>零跳（zero hop）分布式哈希表（DHT）</strong>，每个节点在本地 维护了足够多的路由信息，能够将请求直接路由到合适节点。</p><h2 id="4-系统架构"><a href="#4-系统架构" class="headerlink" title="4. 系统架构"></a>4. 系统架构</h2><p>生产级别的存储系统的架构是很复杂的。除了最终存储数据的组件之外，系统还要针对下列 方面制定可扩展和健壮的解决方案：负载均衡、成员管理（membership）、故障检测、故障 恢复、副本同步、过载处理（overload handling）、状态转移、并发和任务调度、请求 marshalling、请求路由（routing）、系统监控和告警，以及配置管理。</p><p>详细描述以上提到的每一方面显然是不可能的，因此本文将关注下面几项 Dynamo 用到的分 布式系统核心技术：</p><ul><li>partitioning（分区，经哈希决定将数据存储到哪个/些节点）</li><li>复制（replication）</li><li>版本化（versioning）</li><li>成员管理（membership）</li><li>故障处理（failure handling）</li><li>规模扩展（scaling）</li></ul><p>表 1 总结了 Dynamo 使用的这些技术及每项技术的好处。</p><p>表 1 Dynamo 用到的技术及其好处</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/table-1.png" alt="img"></p><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><ul><li>技术：<strong>一致性哈希</strong></li><li>好处：增量可扩展性</li></ul><h4 id="写高可用"><a href="#写高可用" class="headerlink" title="写高可用"></a>写高可用</h4><ul><li>技术：读时协调（解决冲突）的<strong>向量时钟</strong>（vector clocks with reconciliation during reads）</li><li>好处：version size（？）和更新频率（update rates）解耦</li></ul><h4 id="短时故障处理"><a href="#短时故障处理" class="headerlink" title="短时故障处理"></a>短时故障处理</h4><ul><li>技术：<strong>宽松的选举和 hinted handoff</strong>（移交给其他节点处理，附带提示信息）</li><li>好处：部分副本不可用时，仍然可以提供高可用性和持久性</li></ul><h4 id="持久（permanent）故障恢复"><a href="#持久（permanent）故障恢复" class="headerlink" title="持久（permanent）故障恢复"></a>持久（permanent）故障恢复</h4><ul><li>技术：<strong>基于 Merkle tree 的逆熵</strong>（anti-entropy）</li><li>好处：后台同步版本不一致的副本</li></ul><h4 id="成员管理和故障检测"><a href="#成员管理和故障检测" class="headerlink" title="成员管理和故障检测"></a>成员管理和故障检测</h4><ul><li>技术：<strong>基于 Gossip 的成员管理协议和故障检测</strong></li><li>好处：保持了<strong>架构的对称性</strong>，无需一个中心组件（centralized registry）来存储成员和节点状态等信息</li></ul><h3 id="4-1-系统接口"><a href="#4-1-系统接口" class="headerlink" title="4.1 系统接口"></a>4.1 系统接口</h3><p>Dynamo 存储键值对象的接口非常简单，它提供两个操作：</p><ul><li><code>get()</code></li><li><code>put()</code></li></ul><p><code>get(key)</code> 会定位到存储系统中 <code>key</code> 对应的所有对象副本，<strong>返回对象</strong> ——可能是单个对 象，也可能是一个对象列表（有冲突情况下，包括了所有版本）—— <strong>以及一个 <code>context</code>（ 上下文）</strong>。</p><p><code>put(key)</code> 确定对象应该存放的位置，然后写到相应的磁盘。</p><p><code>context</code> 包含了系统中对象的元数据，例如对象的版本，<strong>对调用方是不透明的</strong>（ opaque）。<strong>上下文信息是和对象存储在一起的</strong>，这样系统很<strong>容易验证 <code>put</code> 请求的 <code>context</code> 是否合法</strong>。</p><p>Dynamo <strong>将调用方提供的 key 和对象都视为不透明的字节序列</strong>（opaque array of bytes） 。它<strong>对 key 应用 MD5 哈希得到一个 128bit 的 ID，并根据这个 ID 计算应该存储 到哪些节点</strong>。</p><blockquote><p>Dynamo treats both the key and the object supplied by the caller as an opaque array of bytes. It applies a MD5 hash on the key to generate a 128-bit identifier, which is used to determine the storage nodes that are responsible for serving the key.</p></blockquote><h3 id="4-2-数据分散（Partitioning）算法"><a href="#4-2-数据分散（Partitioning）算法" class="headerlink" title="4.2 数据分散（Partitioning）算法"></a>4.2 数据分散（Partitioning）算法</h3><p>Dynamo 的核心需求之一是：系统必须支持<strong>增量扩展</strong>（scale incrementally）。 这就要求有一种机制能够将数据分散到系统中的不同的节点（例如，以一台机器作为一个 节点的维度）上。</p><p>Dynamo 的<strong>分散方案基于一致性哈希</strong> [10]。在一致性哈希中，哈希函数的<strong>输出是一个 固定的范围，通常作为一个循环空间，或称环（ring）</strong>。<strong>每个节点都会随 机分配一个在这个循环空间内的值</strong>，这个值代表了节点在这个环上的位置。</p><p>用如下方式找到一个数据项（data item）对应的存储节点：</p><ol><li>首先对它的 key 做哈希得到一个哈希值</li><li>然后，在环上沿着顺时针方向找到第一个<strong>所带的值比这个哈希值更大的节点</strong>（前面 提到每个节点都会被分配一个值）</li></ol><p>即，每个节点要负责环上从它自己到它的下一个节点之间的区域。<strong>一致性哈希的主要好处是 ：添加或删除节点只会影响相邻的节点，其他节点不受影响。</strong></p><blockquote><p>The principle advantage of consistent hashing is that departure or arrival of a node only affects its immediate neighbors and other nodes remain unaffected.</p></blockquote><p>但是，<strong>初级的一致性哈希算法在这里是有一些问题的</strong>。 首先，给每个节点随机分配一个位置会导致数据和负载的非均匀分布。 其次，初级的一致性哈希算法没有考虑到节点的异构因素，导致性能不理想。</p><p>为了解决这些问题，Dynamo 使用了一致性哈希的一个变种（和 [10, 20] 的类似）：<strong>每个 节点并不是映射到环上的一个点，而是多个点</strong>。</p><blockquote><p>Intead of mapping a node to a single point in the circle, each node gets assigned to multiple points in the ring.</p></blockquote><p>为了实现这种设计，Dynamo 使用了<strong>虚拟节点</strong>（virtual node）的概念。一个虚拟节点 看上去和一个普通节点一样，但<strong>实际上可能管理不止一台虚拟节点</strong>。具体来说， <strong>当一个新节点添加到系统后，它会在环上被分配多个位置（对应多个 token）</strong>。 我们会在 Section 6 介绍 Dynamo 分散策略（算法）的深入调优 。</p><p><strong>虚拟节点可以代来如下好处</strong>：</p><ol><li>当一个节点不可用时（故障或例行维护），这个节点的负载会均匀分散到其他可用节点上</li><li>当一个节点重新可用时，或新加入一个节点时，这个节点会获得与其他节点大致相同的 负载</li><li>一个节点负责的虚拟节点的数量可用根据节点容量来决定，这样可用充分利用物理基础 设施中的异构性信息</li></ol><h3 id="4-3-数据复制（Replication）"><a href="#4-3-数据复制（Replication）" class="headerlink" title="4.3 数据复制（Replication）"></a>4.3 数据复制（Replication）</h3><p>为了实现高可用性和持久性，Dynamo 将数据复制到多台机器上。每个数据会被复制到 N 台 机器，这里的 N 是每套 Dynamo 可以自己配置的。</p><p>上节介绍到，<strong>每个 key <code>k</code>，会被分配一个 coordinator（协调者）</strong>节点。 coordinator <strong>负责落到它管理的范围内的数据的复制</strong>。它除了自己存储一份之外，还会 在环上顺时针方向的其他 <code>N-1</code> 个节点存储一份副本。因此在系统中，每个节点要负责从 它自己往后的一共 N 个节点。</p><p>例如，图 2 中，B 除了自己存储一份之外，还会将其复制到 C 和 D 节点。因此，D 实际 存储的数据，其 key 的范围包括 <code>(A, B]</code>、<code>(B, C]</code> 和 <code>(C, D]</code>（例如，落在 <code>(A, B]</code> 范围内的 key 会沿顺时针方向找到第一个值比它大的节点，因此找到的是 B，而 B 会 将自己存储的数据复制到 C 和 D，因此 D 会包含 key 在 <code>(A, B]</code> 范围内的对象。其他 几个范围也是类似的。译者注）。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2.png" alt="img"></p><p>图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）</p><p>存储某个特定 key 的所有节点组成一个列表，称为 <strong>preference list</strong>（优先列表）。 我们在 4.8 节会看到，Dynamo 的设计是，<strong>对于给定的 key，每个节点都能决定哪些 节点可以进入这个列表</strong>。<strong>为了应对节点失败的情况，preference list 会包含多余 N 个节 点</strong>。</p><blockquote><p>todo：这里的优先列表会不会非常非常大？占用资源太多？</p></blockquote><p>另外注意，由于我们引入了虚拟节点，存储一个 key 的 N 个节点，实际上对应的物理节 点可能少于 N 个（例如，一个节点可能会占用环上的不止一个节点）。为了避免这个问题 ，<strong>preference list 在选择节点的时候会跳过一些位置，以保证 list 里面的节点都在不 同的物理节点上</strong>。</p><h3 id="4-4-数据版本化（Data-Versioning）"><a href="#4-4-数据版本化（Data-Versioning）" class="headerlink" title="4.4 数据版本化（Data Versioning）"></a>4.4 数据版本化（Data Versioning）</h3><p>Dynamo 提供最终一致性，所有更新操作会异步地传递给所有的副本。</p><p><code>put()</code> 操作返回时，数据（更新）可能还没有应用到所有副本，因此紧接着的 <code>get()</code> 操作可能获取不到最新数据。在没有故障的情况下，传递更新的耗时有一个上限；但在特定 故障场景下（例如服务器宕机或网络分裂），更新可能会在限定的时间内无法传递到所有副 本。</p><p>Amazon 有些应用是可以容忍这种不一致性的，应用在这种情况下能继续运行。例如，购物 车应用要求“添加到购物车”的请求永远不能被丢失或拒绝。如果购物车的最新状态不可用， 而用户对一个稍老版本的购物车状态做了修改，那这种修改也是有意义的，需要保留；但它 不能直接覆盖最新的状态，因为最新的状态中可能也有一些修改需要保留。这里要注意，不 管是“添加到购物车”还是“从购物车删除”，在系统中转换成的都是 Dynamo 的 <code>put()</code> 操作 。如果最新的状态不可用，而用户又基于稍的大版本做了修改，那这两个版本都需要保留， 由随后的步骤来处理更新冲突。</p><h4 id="如何解决更新冲突"><a href="#如何解决更新冲突" class="headerlink" title="如何解决更新冲突"></a>如何解决更新冲突</h4><p>为了满足以上需求，Dynamo <strong>将每次修改结果都作为一个新的、不可变的版本</strong>。</p><blockquote><p>Dynamo treats the result of each modification as a new and immutable version of the data.</p></blockquote><p>即，允许系统中同时存在多个不同版本。</p><h5 id="冲突调和（使一致化）方式"><a href="#冲突调和（使一致化）方式" class="headerlink" title="冲突调和（使一致化）方式"></a>冲突调和（使一致化）方式</h5><ul><li>syntactic reconciliation（<strong>基于句法的调和</strong>）</li><li>semantic reconciliation（<strong>基于语义的调和</strong>）</li></ul><p>在<strong>大部分情况下，新版本都包含老版本的数据，而且系统自己可以判断哪个是权威版本</strong> （syntactic reconciliation）。</p><p>但是，在发生故障并且存在并发更新的场景下，版本会发生分叉（version branching）， 导致冲突的对象版本。<strong>系统本身无法处理这种情况，需要客户端介入，将多个分支合并成 一个</strong>（semantic reconciliation）。一个典型的例子是：合并多个不同版本的购物车。 有了这种调和机制（reconciliation mechanism），“添加到购物车”操作就永远不会失败 ；但是，这种情况会导致<strong>已经删除的商品偶尔又在购物车中冒出来</strong>（resurface）。</p><p>有很重要的一点需要注意：某些故障模式（failure mode）会导致存在多个冲突的版本，而 不仅仅是两个。服务器故障或网络分裂会导致一个对象有多个版本，每个版本有各自的子历 史（version sub-histories），随后要由系统来将它们一致化。这需要<strong>将应用 设计为：显式承认多版本存在的可能性（以避免丢失任何更新）</strong></p><h5 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h5><p><strong>Dynamo 使用向量时钟（vector clock）[12] 来跟踪同一对象不同版本之间的因果性</strong>。 一个向量时钟就是一个 <code>(node, counter)</code> 列表。一个向量时钟关联了一个对象的所有版 本，可以通过它来判断对象的两个版本是否在并行的分支上，或者它们是否有因果关系。 <strong>如果对象的第一个时钟上的所有 counter 都小于它的第二个时钟上的 counter，那第一个 时钟就是第二的祖先，可以安全的删除；否则，这两个修改就是有冲突的，需要 reconciliation</strong>。</p><p>在 Dynamo 中，<strong>客户端更新一个对象时，必须指明基于哪个版本进行更新</strong>。流程是先执 行读操作，拿到 context，其中包含了 vector clock 信息，然后写的时候带上这个 context。</p><p>在处理读请求的时候，如果 Dynamo 能够访问到多个版本，并且无法 reconcile 这些版本 ，那它就会返回所有版本，并在 context 中附带各自的 vector clock 信息。 <strong>基于 context 指定版本更新的方式解决了冲突</strong>，将多个分支重新合并为一个唯 一的新分支。</p><blockquote><p>An update using this context is considered to have reconciled the divergent versions and the branches are collapsed into a single new version.</p></blockquote><h4 id="一个具体例子"><a href="#一个具体例子" class="headerlink" title="一个具体例子"></a>一个具体例子</h4><p>我们通过 图 3 来展示 vector clock 是如何工作的。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/3.png" alt="img"></p><p>图 3 一个对象在一段时间内的版本演进</p><p>首先，客户端写入一个对象。处理这个 key 的写请求的节点 <code>Sx</code> 增加 key 的序列号（计 数），并用这个序列号创建对象的 vector clock。至此，系统有了一个对象 <code>D1</code> 和它的 时钟 <code>[(Sx, 1)]</code>。</p><p>第二步，客户端更新这个对象。假设还是 <code>Sx</code> 处理这个请求。此时，系统有了对象 <code>D2</code> 和它的时钟 <code>[(Sx, 2)]</code>。<code>D2</code> 是 <code>D1</code> 的后代，因此可以覆盖 <code>D1</code>；<strong>但是，<code>D1</code> 在 其他节点上的副本可能还没有看到 <code>D2</code> 这次更新</strong>。</p><p>第三步，假设还是这个客户端，再次更新了对象，并且这次是由另外的一个节点 <code>Sy</code> 处理 请求。此时，系统有了 <code>D3</code> 和它的时钟 <code>[(Sx, 2), (Sy, 1)]</code>.</p><p>接下来，假设另一个客户端读取 <code>D2</code>，并尝试更新它，写请求由另一个节点 <code>Sz</code> 处理。 现在，系统有 <code>D4</code>（<code>D2</code> 的后代），版本 clock 是 <code>[(Sx, 2), (Sz, 1)]</code>。如果一个节 点知道 <code>D1</code> 和 <code>D2</code>，那它收到 <code>D4</code> 和它的 clock 后，就可以断定 <code>D1</code> 和 <code>D2</code> 被同 一个新数据覆盖了，因此可以安全地删除 D1 和 D2。但如果一个节点只知道 <code>D3</code>，那它受 到 <code>D4</code> 后就看不出这两个版本有何因果关系。<strong>换言之，<code>D3</code> 和 <code>D4</code> 各自的改动并没 有反映在对方之中。因此这两个版本都应当被保留，然后交给客户端，由客户端（在下一次 读到时候）执行 semantic reconciliation</strong>。</p><p>现在，假设一些客户端把 <code>D3</code> 和 <code>D4</code> 都读到了（<code>context</code> 会同时显示 <code>D3</code> 和 <code>D4</code> ）。读操作返回的 <code>context</code> 综合了 <code>D3</code> 和 <code>D4</code> 的 clock，即 <code>[(Sx, 2), (Sy, 1), (Sz, 1)]</code>。如果客户端执行 reconciliation，并且节点 <code>Sx</code> 执行协调写（coordinates the write），<code>Sx</code> 会更新自己在 clock 中的序列号。最终新生成的数据 <code>D5</code> 的 clock 格式如下：<code>[(Sx, 3), (Sy, 1), (Sz, 1)]</code>。</p><h4 id="Vector-clock-的潜在问题"><a href="#Vector-clock-的潜在问题" class="headerlink" title="Vector clock 的潜在问题"></a>Vector clock 的潜在问题</h4><p>vector clock 的一个潜在问题是：<strong>如果有多个节点先后 coordinate 同一个对象 的写操作，那这个对象的 clock vector 会变得很长</strong>。但在实际中这不太可能发生，因为 写操作 coordination 只会由 preference list 中前 N 个 节点中的一个来执行。 只有在网络分裂或多台服务器挂掉的情况下，写操作才可能由非 preference list 前 N 个 节点来执行，导致 vector clock 变长。在这种情况下，应该要限制 vector clock 的长度 。</p><p>Dynamo 采用了一种 clock 截断方案（clock truncation scheme）： 另外保存一个和 <code>(node, counter)</code> 对应的时间戳，记录对应的节点最后一次更新该记录 的时间。当 vector clock 里的 <code>(node, counter)</code> 数量达到一个阈值（例如，10）时， 就删除最老的一项。</p><p>显然，这种截断方案会给 reconciliation 带来一定问题，因为截断后可能无法精确判断部 分后代的因果关系。但到目前为止，我们还没有在生产环境遇到这个问题，因此没有继续深 入研究下去。</p><h3 id="4-5-get-和-put-的执行过程"><a href="#4-5-get-和-put-的执行过程" class="headerlink" title="4.5 get() 和 put() 的执行过程"></a>4.5 <code>get()</code> 和 <code>put()</code> 的执行过程</h3><p><strong>在 Dynamo 中，任何存储节点都可以接受任何 key 的 <code>get</code> 和 <code>put</code> 操作请求</strong>。</p><blockquote><p>Any storage node in Dynamo is eligible to receive client get and put operations for any key.</p></blockquote><p>本节先介绍在无故障场景下这些操作是如何执行的，下一节介绍有故障的场景。</p><p><code>get</code> 和 <code>put</code> 操作由 Amazon 基础设施相关的请求处理框架发起，使用 HTTP。 客户端有两种选择：</p><ol><li>将请求路由到负载均衡器，由后者根据负载信息选择一个后端节点</li><li>使用能感知 partition 的客户端，直接将请求路由到某 coordinator 节点</li></ol><p>第一种方式的好处是使用客户端的应用不需要了解任何 Dynamo 相关的代码，第二种的好处 是延迟更低，因为跳过了一次潜在的转发步骤。</p><p><strong>负责处理读或写请求的节点称为 coordinator</strong>。<strong>通常情况下</strong>，这是 preference list 内前 N 个节点中的<strong>第一个节点</strong>。如果请求是经过负载均衡器转发的，那这个请求 可能会被转发到环上的任意一个节点。在这种情况下，如果收到请求的节点不是 preference list 的 前 N 个节点中的一个，那它就不会处理这个请求，而是将其转发到 preference list 前 N 个节点中的第一个节点。</p><p><strong>读或写操作需要 preference list 中前 N 个节点处于健康状态</strong>，如果有 down 或不可 访问状态的节点，要跳过。如果所有节点都是健康的，那就取 preference list 的前 N 个 节点。如果发生节点故障或网络分裂，优先访问 preference list 中编号较小的节点。</p><h4 id="读写操作仲裁算法"><a href="#读写操作仲裁算法" class="headerlink" title="读写操作仲裁算法"></a>读写操作仲裁算法</h4><p>为了保证副本的一致性，Dynamo 使用了一种类似仲裁系统（quorum systems）的一致性协议。 这个协议有两个配置参数：<code>R</code> 和 <code>W</code>：</p><ul><li><code>R</code>：允许执行一次读操作所需的最少投票者</li><li><code>W</code>：允许执行一次写操作所需的最少投票者</li></ul><p><strong>设置 <code>R + W &gt; N</code><strong>（<code>R</code> 或 <code>W</code> 至少有一个超过半数 N/2，译者注），</strong>就得到了一 个类似仲裁的系统</strong>。</p><p>在这种模型下，一次 <code>get</code> （或 <code>put</code>）的延迟由 <code>R</code>（或 <code>W</code>）个<strong>副本中最慢的一个决 定</strong>。因此，为了降低延迟，<code>R</code> 和 <code>W</code> 通常设置的比 <code>N</code> 小。</p><h4 id="写和读过程"><a href="#写和读过程" class="headerlink" title="写和读过程"></a>写和读过程</h4><p>当收到一个 <code>put()</code> 请求后，coordinator 会为新版本生成 vector clock，并将其保存到 节点本地；然后，将新版本（及对应的新 vector clock）发送给 N 个排在最前面的、可到 达的节点。只要有至少 <code>W-1</code> 个节点返回成功，这次写操作就认为是成功了。</p><p>类似地，对于一次 <code>get()</code> 请求，coordinator 会向排在最前面的 N 个（highest-ranked ）可访问的节点请求这个 key 对应的数据的版本，等到 R 个响应之后，就将结果返回给客 户端。如果 coordinator 收集到了多个版本，它会<strong>将所有它认为没有因果关系的版本返 回给客户端</strong>。客户端需要对版本进行 reconcile，合并成一个最新版本，然后将结果写回 Dynamo。</p><h3 id="4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）"><a href="#4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）" class="headerlink" title="4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）"></a>4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）</h3><p>如果使用传统仲裁算法，Dynamo 无法在服务器宕机或网络分裂的时候仍然保持可用，而且 在遇到最简单故障情况下，持久性（durability）也会降低。</p><p>因此，Dynamo 采用了一种<strong>宽松的仲裁机制</strong>（sloppy quorum）：<strong>所有读和写操作在 preference list 的前 N 个健康节点上执行</strong>；注意这 N 个节点不一定就是前 N 个节点， 因为遇到不健康的节点，会沿着一致性哈希环的顺时针方向顺延。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2-20220130214812411.png" alt="img"></p><p>图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）</p><p>以图 2 的配置为例，其中 N=3。<strong>如果 A 临时不可用，正常情况下应该到达 A 的写请求就 会发送到 D</strong>。这样设计是为了保证期望达到的可用性和持久性。<strong>发送到 D 的副本的元 数据中会提示（hint）这个副本本来应该发送给谁</strong>（这里是 A），然后这个数据会被 D 保存到本地的一个独立数据库中，并且有一个<strong>定期任务不断扫描，一旦 A 可用了，就将 这个数据发送回 A</strong>，然后 D 就可以从本地数据库中将其删除了，这样系统内的副本数还 是保持不变。</p><p>使用这种 hinted handoff 的方式，Dynamo <strong>保证了在节点或网络发生短时故障时读和写 操作不会失败</strong>。希望可用性最高的应用可以将 <code>W</code> 设为 1，这样可以保证只要一个节点 完成写，这次写操作就被系统接受了。在这种情况下，除非全部节点都不可用，否则写操作 就不会被拒绝。但实际上，大部分 Amazon 的应用都是设置一个比 1 大的值，以达到期望 的持久性（durability）等级。我们会在第 6 节更深入地讨论 <code>N</code>、<code>R</code> 和 <code>W</code> 的配置。</p><p><strong>高度可用的存储系统必须能够处理整个数据中心挂掉的情况。</strong>掉电、制冷失效、网络故 障以及自然灾难都会导致整个数据中心发生故障。Dynamo 可以配置<strong>向多个数据中心同步 副本</strong>，只要<strong>将 preference list 里的节点分散到不同数据中心</strong>。这些数据中心之间 通过高速网络互连。这使得我们可以在整个数据中心挂掉的情况下仍然可以提供服务。</p><h3 id="4-7-持久（permanent）故障处理-副本跨数据中心同步"><a href="#4-7-持久（permanent）故障处理-副本跨数据中心同步" class="headerlink" title="4.7 持久（permanent）故障处理: 副本跨数据中心同步"></a>4.7 持久（permanent）故障处理: 副本跨数据中心同步</h3><p>在节点成员变动较小、节点故障只是短时的情况下，hinted handoff 方式工作良好。但也 有一些场景，在 hinted 副本移交给原本应该存储这个副本的节点之前，该副本就不可用了 。为了解决这个问题，以及其他威胁到持久性（durability）的场景，Dynamo 实现了一种 <strong>逆熵（副本同步）协议</strong>来<strong>保证副本是同步的</strong>。</p><blockquote><p>To handle this and other threats to durability, Dynamo implements an anti-entropy (replica synchronization) protocol to keep the replicas synchronized.</p></blockquote><h4 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h4><p>为了实现<strong>快速检测副本之间的不一致性，以及最小化转移的数据量</strong>，Dynamo 使用了 Merkle trees [13].</p><p>一个 Merkle tree 就是一个<strong>哈希树</strong>，其叶子节点是 <strong>key 对应的 value 的哈希值</strong>。 <strong>父节点是其子节点的哈希</strong>。</p><p>Merkle tree 的主要优点是：</p><ul><li>每个分支都可以独立查看（check），节点无需下载整棵树或者整个数据集</li><li>减少检查副本一致性时所需传输的数据量</li></ul><p><strong>例如，如果两棵树的根节点的哈希值相同，那这两棵树的叶子节点必然相同，这两台 node 之间就无需任何同步</strong>；否则，就说明两台 node 之间的某些副本是不同的，这种情 况下两台 node 就需要交换树的子节点哈希值，直到到达叶子节点，就找到了未同步（out of sync）的 key。Merkle tree 最小化了同步时需要转移的数据量，<strong>减少了逆熵过程中 读取磁盘的次数</strong>。</p><p>Dynamo 使用 Merkle tree 实现<strong>逆熵的过程</strong>如下：<strong>每个节点为每段 key range（一台 虚拟节点所覆盖的 key 的范围）维护了一棵单独的 Merkle tree</strong>。</p><p>这使得节点之间可以比较 key range，确定其维护的 range 内的 key 是否是最新的（up to date）。在这种方案中，两个节点会交换他们都有的 key range 所对应的 Merkle tree 的 根节点。然后，基于前面提到的树遍历方式， node 可以判断是是否有不一致，如果有，就 执行同步。</p><p>这种方案的缺点是：<strong>每当有节点加入或离开系统时，一些 key range 会变，因此对应的 tree 需要重新计算</strong>。我们会在 6.2 节介绍如何通过改进的 partitioning scheme 解决 这个问题。</p><h3 id="4-8-节点成员（Membership）管理和故障检测"><a href="#4-8-节点成员（Membership）管理和故障检测" class="headerlink" title="4.8 节点成员（Membership）管理和故障检测"></a>4.8 节点成员（Membership）管理和故障检测</h3><h4 id="4-8-1-哈希环（ring）成员"><a href="#4-8-1-哈希环（ring）成员" class="headerlink" title="4.8.1 哈希环（ring）成员"></a>4.8.1 哈希环（ring）成员</h4><p>在 Amazon 的环境中，节点服务不可用（故障或维护导致的）通常情况下持续时间都很短， 但也存在中断比较长的情况。一个节点服务中断并不能说明这个节点永久性的离开了系统， 因此不应该导致系统对 partition 进行再平衡（rebalance），或者修复无法访问的副本。 与此类似，无意的手动操作可能导致新的节点加入到 Dynamo。</p><p>因此，为了避免以上这些问题，我们决定<strong>使用显式机制（explicit mechanism）来向 Dynamo Ring 增删节点</strong>。管理员通过命令行或 web 方式连接到 Dynamo node，然后下发 一个成员变更命令，来将这个 node 添加到 ring 或从 ring 删除。负责处理这个请求的 node 将成员变动信息和对应的时间写入持久存储。成员变动会形成历史记录，因为一个节 点可能会多次从系统中添加和删除。Dynamo <strong>使用一个 gossip-based 的算法通告（ propagete）成员变动信息</strong>，维护成员的一份最终一致视图。</p><p>每个节点每秒会随机选择另一个节点作为对端，这两个节点会高效地 reconcile 它们的成 员变动历史。</p><p><strong>一个节点第一次起来时，首先会选择它的 token 集合</strong>（一致性哈希空间内的虚拟节点 ），然后<strong>将节点映射到各自的 token 集合</strong>。</p><blockquote><p>When a node starts for the first time, it chooses its set of tokens (virtual nodes in the consistent hash space) and maps nodes to their respective token sets.</p></blockquote><p><strong>映射关系会持久存储到磁盘上</strong>，初始时只包含本节点（local node）和 token set。存 储在不同 Dynamo 节点上的<strong>映射关系，会在节点交换成员变动历史时被 reconcile</strong>。因 此，partitioning 和 placement（数据的放置信息）也会通过 gossip 协议进行扩散，<strong>最 终每个节点都能知道其他节点负责的 token 范围</strong>。</p><blockquote><p>The mappings stored at different Dynamo nodes are reconciled during the same communication exchange that reconciles the membership change histories.</p><p>Therefore, partitioning and placement information also propagates via the gossip-based protocol and each storage node is aware of the token ranges handled by its peers.</p></blockquote><p>这<strong>使得每个节点可以将一个 key 的读/写操作直接发送给正确的节点</strong>进行处理。</p><h4 id="4-8-2-系统外部发现（External-Discovery）和种子节点"><a href="#4-8-2-系统外部发现（External-Discovery）和种子节点" class="headerlink" title="4.8.2 系统外部发现（External Discovery）和种子节点"></a>4.8.2 系统外部发现（External Discovery）和种子节点</h4><p>以上机制<strong>可能导致 Dynamo ring 在逻辑上临时分裂</strong>。</p><p>例如，管理员先联系 node A，将 A 将入 ring，然后又联系 node B 加入 ring。在这种情 况下，A 和 B 都会认为它们自己是 ring 的成员，但不会立即感知到对方。</p><p><strong>为了避免逻辑分裂，我们会将一些 Dynamo 节点作为种子节点</strong>。种子节点是通过外部机 制（external mechanism）发现的，所有节点都知道种子节点的存在。因为所有节点最终都 会和种子节点 reconcile 成员信息，所以逻辑分裂就几乎不可能发生了。</p><p>种子或者从静态配置文件中获取，或者从一个配置中心获取。通常情况下，种子节点具有普 通节点的全部功能。</p><h4 id="4-8-3-故障检测"><a href="#4-8-3-故障检测" class="headerlink" title="4.8.3 故障检测"></a>4.8.3 故障检测</h4><p>故障检测在 Dynamo 中用于如下场景下跳过不可达的节点：</p><ul><li><code>get()</code> 和 <code>put()</code> 操作时</li><li>转移 partition 和 hinted replica 时</li></ul><p>要避免尝试与不可达节点通信，一个<strong>纯本地概念（pure local notion）的故障检测</strong>就 足够了：节点 B 只要没有应答节点 A 的消息，A 就可以认为 B 不可达（即使 B 可以应答 C 的消息）。</p><p>在客户端有持续频率的请求的情况下，Dynamo ring 的节点之间就会有持续的交互；因此只 要 B 无法应答消息，A 可以很快就可以发现；在这种情况下，A 可以选择和与 B 同属一个 partition 的其他节点来处理请求，并定期地检查 B 是否活过来了。</p><p><strong>在没有持续的客户端请求的情况下，两个节点都不需要知道另一方是否可达。</strong></p><blockquote><p>In the absence of client requests to drive traffic between two nodes, neither node really needs to know whether the other is reachable and responsive.</p></blockquote><p><strong>去中心化故障检测协议使用简单的 gossip 风格协议，使得系统内的每个节点都可以感知 到其他节点的加入或离开</strong>。想详细了解去中心化故障检测机制及其配置，可以参考 [8]。</p><p>Dynamo 的早期设计中使用了一个去中心化的故障检测器来维护故障状态的全局一致视图 （globally consistent view of failure state）。</p><p>后来我们发现，我们<strong>显式的节点加入和离开机制</strong>使得这种全局一致视图变得多余了。因 为节点的真正（permanent）加入和离开消息，依靠的是我们的显式添加和删除节点机制， 而临时的加入和离开，由于节点之间的互相通信（转发请求时），它们自己就会发现。</p><h3 id="4-9-添加-移除存储节点"><a href="#4-9-添加-移除存储节点" class="headerlink" title="4.9 添加/移除存储节点"></a>4.9 添加/移除存储节点</h3><p>当一个新节点 <code>X</code> 加入到系统后，它会<strong>获得一些随机分散在 ring 上的 token</strong>。对每 个分配给 <code>X</code> 的 key range，当前可能已经有一些（小于等于 <code>N</code> 个）节点在负责处理了 。因此,将 key range 分配给 <code>X</code> 后，这些节点就不需要处理这些 key 对应的请求了，而 要将 keys 转给 <code>X</code>。</p><p>考虑一个简单的情况：<code>X</code> 加入 图 2 中 <code>A</code> 和 <code>B</code> 之间。这样，<code>X</code> 就负责处理落到 <code>(F, G], (G, A] and (A, X]</code> 之间的 key。结果，<code>B</code>、<code>C</code> 和 <code>D</code> 节点就不需负责相应 range 了。因此，在收到 <code>X</code> 的转移 key 请求之后，**<code>B</code>、<code>C</code> 和 <code>D</code> 会向 X 转移相 应的 key**。当移除一个节点时，key 重新分配的顺序和刚才相反。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2-20220130214820871.png" alt="img"></p><p>图 2</p><p>我们的实际运行经验显示，这种方式<strong>可以在存储节点之间保持 key 的均匀分布</strong>，这对 于保证延迟需求和快速 bootstrapping 是非常重要的。另外，在源和目的节点之间加了确 认（转移），可以保证不会转移重复的 key range。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>Dynamo 中的<strong>每个存储节点上主要有三个组件</strong>，都是用 Java 实现的：</p><ul><li>request coordination（请求协调）组件</li><li>成员验证和故障检测组件</li><li>本地持久存储引擎</li></ul><h3 id="本地存储引擎"><a href="#本地存储引擎" class="headerlink" title="本地存储引擎"></a>本地存储引擎</h3><p>Dynamo 的本地持久存储组件支持以插件的方式使用不同的存储引擎。在使用的引擎包括：</p><ul><li>Berkeley Database (BDB) Transactional Data Store2</li><li>BDB Java Edition</li><li>MySQL</li><li>an in-memory buffer with persistent backing store</li></ul><p>将其设计为可插拔的原因是：<strong>为不同应用访问类型选择最合适的存储引擎</strong>。例如，BDB 通常用于处理几十 KB 大小的对象，而 MySQL 可以处理更大的对象。应用可以根据它们的 对象大小分布选择合适的持久化引擎。</p><p>我们生产环境的 Dynamo 大部分使用的都是 BDB Transactional Data Store。</p><h3 id="请求协调"><a href="#请求协调" class="headerlink" title="请求协调"></a>请求协调</h3><p>request coordination 组件构建在一个事件驱动的消息系统之上，其中的消息处理 pipeline 分为多个阶段，和 SEDA 架构类似 [24]。所有通信都基于 Java NIO channel 实现。</p><p><strong>coordinator 代替客户端执行读和写请求</strong>：读操作时会从一个或多个节点收集数据，写操作 时会向一个或多个节点存储数据。每个客户端请求都会<strong>在收到这个请求的节点上创建一个状 态机</strong>。这个状态机包含了识别 key 对应的节点、发送请求、等待响应、重试、处理响应和 组合响应返回给客户端等所有逻辑。</p><h4 id="read-coordination"><a href="#read-coordination" class="headerlink" title="read coordination"></a>read coordination</h4><p>每个状态机处理且只处理一个客户端请求。例如，一个读操作实现了包含如下步骤的状态机：</p><ol><li>发送读请求给节点</li><li>等待所需的最少数量响应</li><li>如果在规定的上限时间内收到的响应数量太少，认定请求失败</li><li>否则，收集对象的所有版本，确定应该返回哪些</li><li>如果打开了版本化（versioning）配置，执行 syntactic reconciliation，生成一个不 透明的写上下文（context），其中包含了合并之后的版本对应的的 vector clock</li></ol><p>为了描述的简单，以上没有提及故障处理和重试的步骤。</p><p><strong>读操作的响应发送给调用方之后，状态机会继续等待一小段时间，接收可能的有效响应</strong>（ outstanding responses，例如最小数量响应之外的其他节点的响应，译者注）。</p><p>如果返回中有过期版本（stale version），coordinator 就需要合并版本，并将最新版本 更新回这些节点。这个过程称为<strong>“读时修复”（read repair）</strong>，因为它<strong>在一个乐观的 时间点</strong>（at an opportunistic time）<strong>修复了那些错过了最新更新的副本</strong>（replicas that have missed a recent update），<strong>减少了逆熵协议的工作</strong>（本来应该是稍后由逆 熵协议做的）。</p><h4 id="write-coordination"><a href="#write-coordination" class="headerlink" title="write coordination"></a>write coordination</h4><p>前面提到过，写请求是由 preference list 内的前 N 个节点中的任意一个 coordinate 的 。总是让 N 个节点中的第一个来 coordinate 有一些好处，例如可以使得在同一个地方完 成写操作的顺序化（serializing all writes），但是，这种方式也有缺点：它会导致不均 匀的负载分布，损害 SLA。这是因为对象请求并不是均匀分布的（request load is not uniformly distributed across objects）。</p><p>为了解决这个问题，<strong>preference list 内的所有 N 个节点都可以 coordinate 写操作</strong>。 而且，因为一个写操作之前通常有一个读操作，因此写操作的 coordinator 都选择为：<strong>前 一次读操作返回最快的那个节点</strong>，这个信息存储在读操作返回的上下文中。</p><p>这项优化还使在下一次读取时，前一次读操作选中的存储这个数据的节点更容易被选中，提 高了“读取刚写入的数据”（“read-your-writes”）的概率。</p><blockquote><p>This optimization enables us to pick the node that has the data that was read by the preceding read operation thereby increasing the chances of getting “read-your-writes” consistency.</p></blockquote><p>同时，还降低了请求处理性能的抖动性，提高了 <code>P99.9</code> 性能。</p><h2 id="6-测试结果及学到的经验"><a href="#6-测试结果及学到的经验" class="headerlink" title="6. 测试结果及学到的经验"></a>6. 测试结果及学到的经验</h2><p>Dynamo 被几种不同类型的服务使用，每种场景下的配置不同。这些不同体现在 vesion reconciliation 逻辑和读/写仲裁特点上。几种主要的场景：</p><ul><li><strong>业务逻辑相关的 reconciliation</strong>：这种场景使用很广。每个数据对象都会复制到不同节 点上，发生<strong>版本冲突时由应用执行自己的 reconciliation 逻辑</strong>。前文提到的购物 车服务就是一个典型的例子，应用自己来合并冲突的购物车版本</li><li><strong>基于时间戳的 reconciliation</strong>：和第一种的不同仅仅是 reconciliation 机制。当 发生版本冲突时，Dynamo 根据<strong>“最后一次写胜出”</strong>（last write wins）机制，例如， 选择时间戳最近的一个版本作为最终版本。一个例子是维护客户 session 信息的服务</li><li><strong>高性能读引擎</strong>：虽然 Dynamo 设计为永远可写（always writeable） 数据仓库, 但 一些服务通过<strong>对 Dynamo 的仲裁特性进行调优（tuning），而将其作为一个高性能读引 擎使用</strong>。典型情况下，这类服务有很高的读频率和很小的写频率。<strong>在这种配置中， <code>R</code> 一般设为 1，<code>W</code> 设为 <code>N</code><strong>。对于这些服务，Dynamo 提供了 partition 和数据跨 多节点复制的能力，因而提供了增量可扩展性。</strong>数据的权威持久缓存</strong>（the authoritative persistence cache for data）存储在更重量级的后端存储中（more heavy weight backing stores）。<strong>维护产品目录和促销商品的服务</strong>会用到这种类型 的 Dynamo 配置</li></ul><p>Dynamo 的最大优势是：<strong>客户端应用可以通过对 N、R 和 W 三个参数进行调优来达到期 望的性能、可用性和持久性等级</strong>。</p><blockquote><p>The main advantage of Dynamo is that its client applications can tune the values of N, R and W to achieve their desired levels of performance, availability and durability.</p></blockquote><p>例如，N 的大小决定了每个对象的持久性。Dynamo 用户最常用的 N 配置是 3。</p><p>W 和 R 的值会影响对象的可用性、持久性和一致性。例如，如果 W 设为 1，那只要系统还 有一台正常的 node，写操作就不会被拒绝。但是，太小的 W 和 R 配置会增加不一致的风 险，因为一次写操作即使在没有大多数副本都写成功的情况下，还是会给客户端返回成功。 这也导致存在一个<strong>风险窗口</strong>（vulnerability window）：<strong>一次写操作即使只在少量节 点上完成了持久化，也会向客户端返回成功</strong>。</p><p>传统观点认为，持久性和可用性是相伴而生（go hand in hand）的，但在这里不一定成立。 例如，增加 W 就会减小持久性的风险窗口；但是，这可能会增加请求被拒绝的概率（因此 降低了可用性），因为这种情况下需要更多的健康存储节点来处理写请求。</p><p>我们**最常用的 Dynamo 集群 <code>(N,R,W)</code> 配置是 <code>(3,2,2)</code>**。这个配置符合我们所需的 性能、持久性、一致性和可用性（SLA）等级。</p><p>本节所有的数据都是从一套线上 Dynamo 环境获得的，配置是 <code>(3,2,2)</code>， 有几百台节点（a couple hundred nodes），配置利用到了异构硬件信息。</p><p>之前我们提到，每套 Dynamo 的节点都是跨数据中心部署的，这些数据中心之间通过高速网 络互联。执行一次成功的 <code>get</code> （或 <code>put</code>）需要 <code>R</code> （或 <code>W</code>）个节点向 coordinator 发送响应，因此很明显，数据中心之间的时延会影响到响应时间，因此在选择节点（以及它 所在的数据中心的位置）的时候要特别注意，以保证能满足应用期望的 SLA。</p><h3 id="6-1-性能和持久性的平衡"><a href="#6-1-性能和持久性的平衡" class="headerlink" title="6.1 性能和持久性的平衡"></a>6.1 性能和持久性的平衡</h3><p>虽然 Dynamo 的首要设计目标是一个高可用数据仓库，但性能指标在 Amazon 也同样重要。 前面提到过，为了提供一致的用户体验，Amazon 的服务会设置一个很高的用百分比衡量的 （例如 <code>P99.9</code> 或 <code>P99.99</code>）性能指标。典型的 SLA 指标是：读和写操作的 <code>P99.9</code> 要 在 <code>300ms</code> 以内成。</p><p>由于 Dynamo 是在<strong>通用硬件</strong>上运行的，和高端企业级服务器相比，<strong>I/O 吞吐性能要差 很多</strong>，因此提供一致的高性能读写并不是一项简单的工作。而且，每次读/写操作都要涉 及多台节点，给这项工作带来了更大的挑战性，因为<strong>最终的性能受限于最慢的那个副本所 在的节点</strong>。</p><h4 id="通用配置下的性能"><a href="#通用配置下的性能" class="headerlink" title="通用配置下的性能"></a>通用配置下的性能</h4><p>图 4 显示了 30 天内 Dynamo 的读和写操作延迟平均值和 <code>P99.9</code>：</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/4.png" alt="img"></p><p>图 4 2006 年 12 月峰值请求季的读写延迟平均值和 P99.9。 X 轴一个刻度 12 小时。延迟走势和每天的请求量走势一致，延迟的 P99.9 比平均值要大一个数量级。</p><p>从图上可以看出，延迟曲线每天的走势（diurnal pattern）都类似，这和平台每天的请求 量走势也是一致的（例如，白天和晚上的请求量明显不一样）。另外，写延迟明显高于读延 迟，因为<strong>写操作永远需要访问磁盘</strong>。另外，**<code>P99.9</code> 大约为 <code>200ms</code>，比平均值高一 个数量级**。这是因为 P99.9 有很多影响因素，例如请求负载变化、对象大小和 locality patterns。</p><h4 id="低延迟配置下的性能"><a href="#低延迟配置下的性能" class="headerlink" title="低延迟配置下的性能"></a>低延迟配置下的性能</h4><p>以上性能对很多服务来说都足够了，但有少数面向用户的服务，它们对性能有更高的要求。 对于这种情况，Dynamo 提供了<strong>牺牲持久性换性能</strong>的能力。具体来说，每个存储节点会 <strong>在主内存中维护一个对象缓存</strong>（object buffer），写操作将数据存储到缓存直接返回， 另有一个独立的写线程定期将数据写入磁盘。读操作会先检查缓存中是否有，如果有，就直 接从缓存读，从而避免了访问存储引擎。</p><p>这项优化可以**将峰值流量期间的 P99.9 降低到原来的 <code>1/5</code>**，即使只使用一个很小的 、只能存放 1000 个对象的缓存，见图 5。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/5.png" alt="img"></p><p>图 5 带缓存和不带缓存的 P99.9 性能对比，时间跨度 24 小时，X 轴一个刻度一个小时</p><p>另外，从图中可以看到，缓存写（write buffering）可以对百分比延迟进行平滑。显然， 这种方案中持久性和性能之间做了折中：一台<strong>节点挂掉会导致缓存里还未落盘的数据丢失</strong>。 为了减小这种风险，写操作进行了优化（refine），由 coordinator <strong>从 <code>N</code> 个副本中选择 一个进行持久化写入</strong>（durable write）。因为 coordinator 只等待 <code>W</code> 个写操作，因此整 体的写操作不受这次写盘操作的影响。</p><blockquote><p>以上优化的意思是，每次写操作到达 coordinator 时，它会将请求转发给相应个节点， 这些节点都是写完内存 buffer 就直接返回的；除此之外，coordinator 还会挑一个节点 进行持久写入，跟其他节点的写是并行进行的，这样可以降低其他节点挂掉时内存数据丢 失的风险。由于 coordinator 只等待 W 个结果就返回了，因此虽然这个执行持久写的节 点（相对）很慢，但 coordinator 并不会依赖它的结果才返回，因此文中说对写性能来 说是没有影响的，译者注。</p></blockquote><h3 id="6-2-均匀负载分布（Uniform-Load-distribution）"><a href="#6-2-均匀负载分布（Uniform-Load-distribution）" class="headerlink" title="6.2 均匀负载分布（Uniform Load distribution）"></a>6.2 均匀负载分布（Uniform Load distribution）</h3><p>Dynamo 通过一致性哈希将它的 key 空间进行 partition，保证负载分布的均匀性。 只要 key 的访问不是极度不均衡，均匀的 key 分布就可以帮助我们实现负载的均衡分布。 特别地，即使出现了明显的 key 访问不平衡的情况，只要这些 key 足够多，Dynamo 也能 保证这些 key 在后端节点之间是均衡分散的。 本节介绍 Dynamo 中的负载不平衡问题，几种解决策略及其对负载分布的影响。</p><p>为了研究负载不平衡（load imbalance）以及它和请求负载（request load）的相关性，我 们测量了 24 个小时内每台节点收到的请求量，以 30 分钟作为一个点。在规定的时间内， 只要节点收到的请求量偏离平均值的程度不超过一个阈值（例如，15%），这台节点就认为 是平衡的（inbalance）；否则，就是不平衡的（out of balance）。</p><p>图 6 展示了不平衡的节点所占的比例（imbalance ratio）：</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/6.png" alt="img"></p><p>图 6 不平衡节点比例，及其负载（请求数），X 轴一个刻度 30 分钟</p><p>作为参考，图中也画出了这段期间系统的总负载（请求量）。从图中可以看出，随着请求量 的上升，不平衡的比例在下降。例如，低负载期间的不平衡比例高达 20%，而高负载期间降 到了 10%。直观上可以解释：随着负载（请求量）的上升，大量的活跃 key 的访问会均匀 的分发到节点，导致负载平衡分布。而低峰期间（请求量只有峰值的 1/8），只有很少的 活跃 key 访问，导致负载非常不平衡。</p><p>本节接下来介绍 Dynamo 的 partition scheme 是如何随时间演进的，以及它对负载分布的 影响。</p><h4 id="策略-1：每个节点-T-个随机-token，按-token-值分散"><a href="#策略-1：每个节点-T-个随机-token，按-token-值分散" class="headerlink" title="策略 1：每个节点 T 个随机 token，按 token 值分散"></a>策略 1：每个节点 T 个随机 token，按 token 值分散</h4><p>这是生产环境最早部署的策略（在 4.2 节介绍过了）。</p><p>在这种策略中，会<strong>给每个节点（从哈希空间）随机分配 T 个 token</strong>。所有节点的 token 在哈希空间中是有序的（按 token 值）。<strong>两个相邻的 token 定义一个范围</strong>（ key range）。最后一个 token 和第一个 token 收尾相连。</p><p>因为 token 是随机选择的，因此范围有大有小。<strong>当有节点加入或离开系统的时，token 集合会变化，导致范围也会跟着变</strong>。注意，<strong>每个节点用来维护成员信息所需的空间随着 系统中的节点数线性增长</strong>。</p><p>这种策略在使用过程中发现如下几个问题。</p><p>首先，一个<strong>新节点加入到系统后，需要从其他节点“偷”出它要用的 key range</strong>。 这会导致那些需要将一部分 key range 移交给新节点的节点，<strong>扫描它们全部的本地持久存 储</strong>，以过滤出所需的数据。在生产环境环境执行这种扫描操作是很棘手的，因为它 会<strong>占用大量磁盘 IO</strong>；为了不影响正常的请求处理，需要把这个任务放到后台。 这要求我们只能将新节点加入集群的任务调到最低优先级。这带来的后果就是，<strong>节点上线的 速度非常慢</strong>，尤其是购物高峰季每天处理百万请求时，上线一台节点需要花费几乎一整天时 间。</p><p>第二，一个节点加入或离开系统时，很多节点负责的 key range 会发生变化，对应的 <strong>Merkle tree 需要重新计算</strong>。对于生产环境来说，这也是一项不小的工作。</p><p>最后，由于 key range 的随机性，<strong>无法快速地对整个 key 空间进行快照</strong>（snapshot）。 这使得存档（备份）工作变得复杂。在这种方案下，我们进行一次快照需要分别从所有节 点获取 key，非常低效。</p><p><strong>这种策略的根本问题出在：数据的 partition 和 placement 方案混在了一起</strong>（ intertwined）。例如，在某些场景下希望通过增加节点应对请求量的上涨，但是在这种方 案中，<strong>无法做到添加新节点不影响数据 partition</strong>。</p><p>理想情况下，应该使用独立的数据 partition 和 placement 方案。为此，我们考察了下面的几种方案。</p><h4 id="Strategy-2-每个节点-T-个随机-token，平均分散"><a href="#Strategy-2-每个节点-T-个随机-token，平均分散" class="headerlink" title="Strategy 2: 每个节点 T 个随机 token，平均分散"></a>Strategy 2: 每个节点 T 个随机 token，平均分散</h4><p>这种策略将哈希空间分为 <code>Q</code> 个相同大小的 partition/range，每个节点分配 <code>T</code> 个 随 机 token。<code>Q</code> 的选择通常要满足：<code>Q &gt;&gt; N</code> 和 <code>Q &gt;&gt; S*T</code>（<code>&gt;&gt;</code>：远大于，译者注）， 其中 <code>S</code> 是系统中节点的数量。</p><p>在这种策略中，token 仅用于<strong>哈希空间的值映射到有序节点列表</strong>的过程，并<strong>不影响数 据 partition</strong>。</p><p>一个 partition 会放在从该 partition 末尾开始<strong>沿顺时针方向得到的前 N 个独立节点</strong>。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/7.png" alt="img"></p><p>图 7 三种策略中 key 的 partition 和 placement。N=3，A、B、 C 是 key k1 的 preference list 中的三个独立节点。阴影区域表示 preference list 是 [A,B,C] 的 key range，箭头表示不同节点对应的 token 位置</p><p>图 7 展示了 <code>N=3</code> 时这种策略的示意图。</p><p>这种策略的主要优点：</p><ol><li>将数据的 partition 和 placement 解耦</li><li>提供了在运行时更改 placement 方案的能力</li></ol><h4 id="Strategy-3-每个节点-Q-S-个-token-平均分散"><a href="#Strategy-3-每个节点-Q-S-个-token-平均分散" class="headerlink" title="Strategy 3: 每个节点 Q/S 个 token, 平均分散"></a>Strategy 3: 每个节点 <code>Q/S</code> 个 token, 平均分散</h4><p>和策略 2 类似，策略 3 也将哈希空间等分为 <code>Q</code> 个 partition，而且 placement 从 partition 解耦。不同的是，每个节点会分配 <code>Q/S</code> 个 token，其中 <code>S</code> 是系统中的节点 数量。</p><p>当一个节点离开时，它的 token 会随机地分配给其他节点，因此 <code>Q/S</code> 个 token 的特性 还是能成立。类似地，当一个节点加入系统时，它会从其他节点“偷”一些 token 过来，同 时保证 <code>Q/S</code> 特性仍然成立。</p><h4 id="几种策略的性能对比"><a href="#几种策略的性能对比" class="headerlink" title="几种策略的性能对比"></a>几种策略的性能对比</h4><p>对一套 <code>S=30</code>，<code>N=3</code> 的 Dynamo 测试了以上三种策略。需要说明的是，公平地比较这三 种策略的性能是很难做到的，因为它们有各自特殊的配置可以调优。例如，策略 1 的负载 分布特性取决于 token 的数量（例如 <code>T</code>），而策略 3 取决于 partition 的数量（例如 <code>Q</code>）。</p><p>一种比较公平的方式是：<strong>所有的策略都使用相同大小的空间存储成员信息时，测量它们的 负载分布倾斜度</strong>（skew in load distribution）。例如，策略 1 中每个节点需要为环上 的全部节点维护各自的 token 位置，而策略 3 中每个节点需要维护系统分配给每个节点的 partition 信息。</p><p>实验中我们将通过改变相关的参数（<code>T</code> 和 <code>Q</code>）来评估这三种策略。测试每个节点需要维 护的成员信息的大小（size）不同时，几种策略的<strong>负载均衡效率</strong>。其中负载均衡效率（ load balancing efficiency）的定义是：每个节点平均处理的请求数 <code>/</code> 负载最高的节点处 理的请求数。</p><p>结果如图 8 所示。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/8.png" alt="img"></p><p>图 8 三种策略的负载均衡效率对比，30 个几点，N=3，每个节点维护相同大小的元数据</p><p>如图所示，<strong>策略 3 取得了最好的负载均衡性能，策略 2 最差</strong>。在某段较短的时期内， 策略 2 充当了将线上的一些 Dynamo 从策略 1 迁移到策略 3 的过渡策略。</p><p>和 策略 1 相比，策略 3 性能更好，而且减少了每个节点所需维护的成员信息的大小。</p><p><strong>虽然存储这些成员信息并不会占用太多存储，但是，节点通过 gossip 协议定期地将成员 信息发送给其他节点</strong>（gossip the membership information periodically），因此<strong>保 持这些信息越紧凑越好。</strong></p><p>此外，策略 3 部署更加方便，原因包括：</p><ol><li><strong>bootstrap 和恢复更快</strong>：因为 <strong>partition 范围是固定的</strong>，因此可以将其存放 到<strong>单独的文件</strong>，这样下次 relocation 的时候可以直接将<strong>整个文件</strong>发送给其他节点 （避免了为了定位特点的数据而进行的<strong>随机访问</strong>）。简化了 bootstrap 和恢复的过程</li><li><strong>易于存档</strong>：定期对数据集（dataset）进行存档是 Amazon 存储服务的硬性要求之一 。在策略 3 中，存档过程会变得更容易，因为 partition 文件可以单独存档。作为对 比，在策略 1 中，token 是随机选取的，存档的时候需要从所有节点分别获取它们存储 的 key 信息，通常非常低效，速度也很慢。</li></ol><p>策略 3 的不足：<strong>变更节点成员时，需要 coordination</strong>，以保持平均分配所需的前提特 性（preserve the properties required of the assignment）。</p><h3 id="6-3-版本分叉：什么时候？有多少？"><a href="#6-3-版本分叉：什么时候？有多少？" class="headerlink" title="6.3 版本分叉：什么时候？有多少？"></a>6.3 版本分叉：什么时候？有多少？</h3><p>我们已经提到过，Dynamo 是通过牺牲一些一致性（consistency）来换可用性（ availability）的。要准确地理解不同类型的一致性失败带来的影响需要考虑很多因素：故障时 常（outage length）、失败类型（type of failures）、组件可靠性、负载等等。 详细地展示这些数据超出了本文范围。但是，本节可以提供一个很好的总结指标：一份真实 的生产环境里<strong>应用看到的分叉版本数量</strong>（number of divergent versions seen by the application）。</p><p>有两种情况会出现数据版本的分叉：</p><ol><li>遇到节点失败、数据中心故障或网络分裂等故障场景</li><li>同一数据对象的大量并发写操作，不同节点都在 coordinating 写操作</li></ol><p>从使用性（usability）和效率的角度，最好在任何时间都保证分叉的版本数尽量小。</p><p>如果冲突的版本无法仅通过向量时钟做句法调和（syntactically reconcile），那就需要 将它们交给业务逻辑，执行语义调和（semantic reconciliation）。</p><blockquote><p>If the versions cannot be syntactically reconciled based on vector clocks alone, they have to be passed to the business logic for semantic reconciliation.</p></blockquote><p><strong>Semantic reconciliation 会给服务引入额外的负担</strong>，因此应当越少越好。</p><p>我们采集了 24 小时内返回到购物车应用的版本数量。结果显示在这段时间内，<code>99.94%</code> 的请求看到的都是一个版本（无冲突）；<code>0.00057%</code> 的请求看到能 2 个，<code>0.00047%</code> 能看 到 3 个，<code>0.00009%</code> 的能看到 4 个。这说明版本分叉的概率还是相当小的。</p><p>实验还显示，导致分叉版本数量增多的并不是故障，而是并发写数量的增加。并发写数据上 升通常都是 busy robots（自动化客户端程序）导致的，极少是人（的应用）导致的。由于 涉及商业机密，在此不再就这一问题进行更深入的讨论。</p><h3 id="6-4-客户端驱动或服务端驱动的-Coordination"><a href="#6-4-客户端驱动或服务端驱动的-Coordination" class="headerlink" title="6.4 客户端驱动或服务端驱动的 Coordination"></a>6.4 客户端驱动或服务端驱动的 Coordination</h3><p>第 5 节提到，Dynamo 有一个 request coordination 组件，利用状态机处理收到的请求。</p><h4 id="服务端驱动"><a href="#服务端驱动" class="headerlink" title="服务端驱动"></a>服务端驱动</h4><p>客户请求会通过负载均衡器均匀地分发给哈希环上的所有节点。每个节点都可以作为读请求 的 coordinator，而写操作的 coordinator 必须由 key 的 preference list 里面的节点 才能充当。有这种限制是因为，preference list 中的这些节点<strong>被赋予了额外的职责：创 建一个新的版本戳（version stamp），在因果关系上包含被它的写操作更新的版本</strong>。注 意，如果 Dynamo 的版本化方案使用的是物理时间戳（physical timestamps），那任何节 点都可以 coordinate 写操作。</p><h4 id="客户端驱动"><a href="#客户端驱动" class="headerlink" title="客户端驱动"></a>客户端驱动</h4><p>另一中 coordinate request 的方式是：<strong>将状态机前移到客户端</strong>（move the state machine to the client nodes）。在这种方式中，客户端应用使用库（library）在本地执 行请求 coordination。每个客户端定期地随机选择一个 Dynamo 节点，下载它的系统成员 状态（Dynamo membership state）的当前视图（current view）。有了这个信息，客户端 就可以知道任何 key 对应的 preference list 由哪些节点组成。</p><p>读请求可以在客户端节点（client node）coordinate，因此如果请求是被负载均衡器随机 分给一个 Dynamo 节点，那这种方式可以避免额外的网络转发跳数。写操作或者转发给 key 对应的 preference list 里面的一个节点，或者，如果使用的是基于时间戳的版本化方式 ，可以在本地 coordinate。</p><p>客户端驱动的一个重要<strong>优势</strong>是：不再需要一个负载均衡器才能均匀地分发客户负载。 在存储节点上近乎均匀分布的 key，暗含了（implicitly guaranteed）负载的均匀分布。</p><p>显然，这种方式的效率取决于客户端侧的成员信息的新鲜程度（how fresh the membership information）。当前，每个客户端会每隔 <code>10s</code> 随机地轮询（poll）一个 Dynamo 节点， 获取成员更新（membership updates）。这里选用 pull 而不是 push 模型是考虑前者在大 量客户端的情况下可扩展性更好，而且相比于客户端侧，只需在服务端侧维护很少的状态信 息。</p><p>然而，在最差的情况下，客户端的 membership 信息会有 <code>10s</code> 的脏数据。 因此，如果客户端检测到它的成员表（membership table）过期了（例如，当一些成员不可 达的时候），它会立即更新它的成员信息。</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>表 2 显示了客户端驱动比服务端驱动的 coordination 的性能提升，测量时间为 24 个小时。</p><p>表 2 客户端驱动和服务端驱动的 coordination 性能对比</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/table-2.png" alt="img"></p><p>从中可以看出，客户端驱动的方式比服务端方式 <code>P99.9</code> 减少了至少 <code>30ms</code>，平均值减少 了 <code>3ms~4ms</code>。</p><p>延迟降低是因为客户端驱动的方式没有了负载均衡器的开销，而且减少了可能的将请求转发 给一个随机节点的网络跳数。</p><p>另外从表中还可以看出，平均延迟远远小于 <code>P99.9</code>。这是因为 Dynamo 的存储引擎缓存（ storage engine caches）和写缓存（write buffer）命中率很高。</p><p>另外，由于负载均衡器和网络会给延迟引入额外的抖动性，因此 <code>P99.9</code> 的性能提升要比 均值更明显。</p><h3 id="6-5-平衡后台和前台任务"><a href="#6-5-平衡后台和前台任务" class="headerlink" title="6.5 平衡后台和前台任务"></a>6.5 平衡后台和前台任务</h3><p>每个节点除了执行正常的前台 <code>put</code>/<code>get</code> 操作之外，还需要为副本同步和数据移交（ handoff）（由于 hinting 或添加/删除节点）执行不同种类的后台任务。</p><p>在早期的生产系统中，这些后台任务触发了资源竞争问题，影响了常规的 <code>get</code>/<code>put</code> 操 作性能。</p><p>因此，必须在保证常规的关键操作不受明显影响的情况下，才允许执行后台任务。为此，我 们将后台任务关联了一种<strong>许可控制机制</strong>（admission control mechanism）。每个后台 任务通过这个控制器<strong>申请资源（例如数据库）的运行时时间片</strong>（runtime slice），这 些资源是在所有后台任务之间共享的。对前台任务性能的监控会通过<strong>反馈机制</strong>改变后台 任务可以使用的时间片数量。</p><p>许可控制器（admission controller）在执行一个前台 <code>put</code>/<code>get</code> 操作的时候，会持续 监控资源访问的状况。<strong>监控的指标</strong>包括磁盘操作延迟、锁竞争和事务超时导致的数据库 访问失败次数，以及请求队列的等待时间。这些信息用于判断在给定的时间窗口之内的延迟 （或失败）性能是否在可接受的范围内。例如，后台控制器检查数据库（过去 <code>60s</code>）的 <code>P99</code> 读延迟是否离预设的阈值（例如 <code>50ms</code>）足够近。控制器正是根据这些对比信息为 前台操作评估资源的可用性，然后决定给后台任务分配多少时间片，因此利用反馈回路限制 了后台任务的侵入性（intrusiveness ）。[4] 也研究了类似的后台任务管理问题。</p><h3 id="6-6-讨论"><a href="#6-6-讨论" class="headerlink" title="6.6 讨论"></a>6.6 讨论</h3><p>本节总结我们在开发和维护 Dynamo 的过程中获得的一些经验。</p><p>很多 Amazon 的内部服务在过去的两年都开始使用 Dynamo，它给应用提供了非常高等级（ significant levels）的可用性。具体来说，使用 Dynamo 的应用，响应成功率（不包括超 时？）达到了 <code>99.9995%</code>（<strong>applications have received successful responses (without timing out) for <code>99.9995%</code> of its requests</strong>），并且到目前位置还没有发 生过丢失数据的情况。</p><p>Dynamo 的主要优势是：给应用提供了配置能力，应用可以根据自己的需求对 <code>(N,R,W)</code> 进 行调优。</p><p>和流行的商业数据仓库不同，Dynamo 将数据一致性和 reconciliation 逻辑开放给了开发 者。刚开始时，有人可能会觉得这样会使应用逻辑变得更复杂。但从传统来看（ historically），Amazon 平台就是为高可用设计的，很多<strong>应用在设计的时候就考虑了如 何处理可能出现的各种故障模式（failure modes）和不一致问题</strong>。对于这类应用来说， 适配 Dynamo 相对还是比较简单的。对于想要使用 Dynamo 的新应用，就需要首先花一些时 间做一些分析，在开发初期，选择满足业务需求的合适的冲突解决机制（conflict resolution mechanisms）。</p><p>最后，Dynamo 采用了一种<strong>full membership model</strong>（完整成员模型），在这种模型中， 每个节点都知道它的对端（peer）节点存储哪些数据。在实现中，每个节点要主动将完整路 由表 gossip 给系统内的其他节点。这个模型<strong>对几百台、上千台节点的规模很适用</strong>。但 对于上万台节点的规模就不适应了，因为维护这么大一个系统的路由表开销会大大增加。 但是，可以通过向 Dynamo 引入<strong>hierarchical extensions</strong>（层级扩展）来解决这个限制。 <code>O(1)</code> 复杂度的的动态哈希树系统（DHS）（例如 [14]）解决的就是这种问题。</p><blockquote><p>this problem is actively addressed by O(1) DHT systems(e.g., [14]).</p></blockquote><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7. 结束语"></a>7. 结束语</h2><p>本文介绍了 Dynamo，一个高可用、高可扩展的数据仓库（data store），在 Amazon 电商 平台用于存储许多核心服务的状态数据。</p><p>Dynamo 提供了期望的可用性和性能等级，可以正确地处理服务器故障、数据中心故障和网 络分裂。</p><p>Dynamo 可以增量扩展，允许服务所有者根据负载高低动态的对 Dynamo 系统进行扩缩容； 允许服务所有者根据他们的性能、持久性和一致性 SLA 需求，通过调优 <code>N``R``W</code> 三个参 数来定制化它们的存储系统。</p><p>过去几年 Dynamo 在生产环境的实践表明：一些去中心化技术结合起来，可以提供一个高度 可用的系统。这种在极具挑战性的应用环境的成功也表明，<strong>最终一致性存储系统可以作为 高可用应用（highly available applications）的一块基石</strong>。</p><blockquote><p>The production use of Dynamo for the past year demonstrates that decentralized techniques can be combined to provide a single highly-available system. Its success in one of the most challenging application environments shows that an eventualconsistent storage system can be a building block for highlyavailable applications.</p></blockquote><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>The authors would like to thank Pat Helland for his contribution to the initial design of Dynamo. We would also like to thank Marvin Theimer and Robert van Renesse for their comments. Finally, we would like to thank our shepherd, Jeff Mogul, for his detailed comments and inputs while preparing the camera ready version that vastly improved the quality of the paper.</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>Adya, et al. Farsite: federated, available, and reliable storage for an incompletely trusted environment. SIGOPS 2002</li><li>Bernstein, P.A., et al. An algorithm for concurrency control and recovery in replicated distributed databases. ACM Trans. on Database Systems, 1984</li><li>Chang, et al. <strong>Bigtable: a distributed storage system for structured data</strong>. In Proceedings of the 7th Conference on USENIX Symposium on Operating Systems Design and Implementation, 2006</li><li>Douceur, et al. Process-based regulation of low-importance processes. SIGOPS 2000</li><li>Fox, et al. Cluster-based scalable network services. SOSP, 1997</li><li>Ghemawat, et al. <strong>The Google file system</strong>. SOSP, 2003</li><li>Gray, et al. The dangers of replication and a solution. SIGMOD 1996</li><li>Gupta, et al. On scalable and efficient distributed failure detectors. In Proceedings of the Twentieth Annual ACM Symposium on Principles of Distributed Computing. 2001</li><li>Kubiatowicz, et al. OceanStore: an architecture for global-scale persistent storage. SIGARCH Comput. Archit. News, 2000</li><li>Karger, et al. Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web. STOC 1997</li><li>Lindsay, et al. “Notes on Distributed Databases”, Research Report RJ2571(33471), IBM Research, 1979</li><li>Lamport, L. <strong>Time, clocks, and the ordering of events in a distributed system</strong>. ACM Communications, 1978</li><li>Merkle, R. A digital signature based on a conventional encryption function. Proceedings of CRYPTO, 1988</li><li>Ramasubramanian, et al. Beehive: O(1)lookup performance for power-law query distributions in peer-topeer overlays. In Proceedings of the 1st Conference on Symposium on Networked Systems Design and Implementation, , 2004</li><li>Reiher, et al. Resolving file conflicts in the Ficus file system. In Proceedings of the USENIX Summer 1994 Technical Conference, 1994</li><li>Rowstron, et al. Pastry: Scalable, decentralized object location and routing for large-scale peerto- peer systems. Proceedings of Middleware, 2001.</li><li>Rowstron, et al. Storage management and caching in PAST, a large-scale, persistent peer-to-peer storage utility. Proceedings of Symposium on Operating Systems Principles, 2001</li><li>Saito, et al. FAB: building distributed enterprise disk arrays from commodity components. SIGOPS 2004</li><li>Satyanarayanan, et al. Coda: A Resilient Distributed File System. IEEE Workshop on Workstation Operating Systems, 1987.</li><li>Stoica, et al. Chord: A scalable peer-to-peer lookup service for internet applications. SIGCOMM 2001</li><li>Terry, et al. Managing update conflicts in Bayou, a weakly connected replicated storage system. SOSP 1995</li><li>Thomas. A majority consensus approach to concurrency control for multiple copy databases. ACM Transactions on Database Systems, 1979.</li><li>Weatherspoon, et al. Antiquity: exploiting a secure log for wide-area distributed storage. SIGOPS 2007</li><li>Welsh, et al. SEDA: an architecture for well-conditioned, scalable internet services. SOSP 2001</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis哨兵sentinels</title>
      <link href="/2022/01/27/redis-shao-bing-sentinels/"/>
      <url>/2022/01/27/redis-shao-bing-sentinels/</url>
      
        <content type="html"><![CDATA[<h2 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h2><p>Sentinel节点本质上是一个特殊的Redis节点</p><p>它可以监视任意多个主服务器以及这些主服务器属下的所有从服务器，并在被监视的主服务器进人下线状态时(根据ping的时间间隔判断是否是下线了)， 自动将下线主服务器属下的某个从服务器升级为新的主服务器， 然后由新的主服务器代替已下线的主服务器继续处理命令请求  </p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211119220249825.png" alt="image-20211119220249825"></p><p>当 serverl 的下线时长超过用户设定的下线时长上限时， Sentinel 系统就会对server1 执行故障转移操作：</p><ul><li>首先， Sentinel 系统会挑选 server1属下的其中一个从服务器， 并将这个被选中的从服务器升级为新的主服务器。  </li><li>之后， Sentinel 系统会向 serverl 属下的所有从服务器发送新的复制指令， 让它们成为新的主服务器的从服务器， 当所有从服务器都开始复制新的主服务器时， 故障转移操作执行完毕。</li><li>另外， Sentinel 还会继续监视已下线的 serverl， 并在它重新上线时， 将它设置为新的主服务器的从服务器。  </li></ul><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211119220709722.png" alt="image-20211119220709722"></p><h3 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h3><p>每个Sentinel实例会维护与所监测的主从实例之间的两个连接，分别是命令连接（Command Connection）和发布/订阅连接（Pub/Sub Connection）。但是<strong>Sentinel和其他Sentinel之间只有一个命令连接</strong>。</p><h4 id="命令连接"><a href="#命令连接" class="headerlink" title="命令连接"></a>命令连接</h4><p>Sentinel维护命令连接是为了与其他主从实例以及Sentinel实例通过发送接收命令的方式进行通信</p><p>作用包括：</p><ol><li>Sentinel会默认以每1s间隔发送PING 命令给其他实例以主观判断其他实例是否下线。</li><li>Sentinel会通过Sentinel和主实例之间的命令连接每隔10s发送INFO命令给主从实例以得到主实例和从实例的最新信息。</li><li>在主实例下线的情况下，Sentinel会通过Sentinel和从实例的命令连接发送SLAVEOF NO ONE命令给选定的从实例从而使从实例提升为新的主节点。</li><li>Sentinel会默认每隔1s发送is-master-down-by-addr命令以询问其他Sentinel节点关于监控的主节点是否下线。</li></ol><p>实现函数sentinel.c/sentinelReconnectInstance</p><h4 id="发布-订阅连接"><a href="#发布-订阅连接" class="headerlink" title="发布/订阅连接"></a>发布/订阅连接</h4><p>Sentinel维护和其他主从节点的发布/订阅连接作用是为了获知其他监控相同主从实例的Sentinel实例的存在，并且从其他Sentinel实例中更新对所监控的主从实例以及发送的Sentinel实例的认知。例如在故障转移完成后，其他Sentinel通过读取领头Sentinel的频道消息来更新新的主节点的相关信息（地址，端口号等）。</p><p>Sentinel在默认每隔2秒钟会发送Hello消息包到其对应的主从实例的_<em>sentinel</em>_:hello频道中。Hello消息格式如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">__sentinel__:hello <span class="token operator">&lt;</span>sentinel地址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel端口号<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel运行id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel配置纪元<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点名字 <span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点地址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点端口号<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点配置纪元<span class="token operator">&gt;</span></code></pre><p>当Sentinel通过订阅连接收到其他Sentinel发送的的Hello包时，会更新对主从节点以及发送Sentinel的实例，如果收到自己发送的Hello包，则简单的丢弃不做任何处理。</p><p>处理hello信息实现函数sentinel.c/sentinelProcessHelloMessage</p><p>发布/订阅连接实现函数sentinel.c/sentinelReconnectInstance</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>sentinel本质是一个特殊模式的redis的服务器，代码的入口一样位于server.c/main函数</p><p>与普通的节点有不同:</p><p>**sertinet.c/initSentinelConfig()**函数将会覆盖普通redis服务器的一些默认配置</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 此函数用于设置Sentinel的默认值 * 覆盖普通redis config默认值。 */</span> <span class="token comment">/* This function overwrites a few normal Redis config default with Sentinel * specific defaults. */</span><span class="token keyword">void</span> <span class="token function">initSentinelConfig</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//使用26379作为sentinel的默认端口</span>    server<span class="token punctuation">.</span>port <span class="token operator">=</span> REDIS_SENTINEL_PORT<span class="token punctuation">;</span>     server<span class="token punctuation">.</span>protected_mode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Sentinel must be exposed. */</span><span class="token punctuation">}</span></code></pre><p>使用<strong>sentinel.c/sentinelcmds</strong>作为sentinel的命令表</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//sentinel 模块初始化</span><span class="token comment">/* Perform the Sentinel mode initialization. */</span><span class="token keyword">void</span> <span class="token function">initSentinel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>     <span class="token comment">// 清空常用命令；只添加sentinel 命令</span>    <span class="token comment">/* Remove usual Redis commands from the command table, then just add     * the SENTINEL command. */</span>    <span class="token function">dictEmpty</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>commands<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinelcmds<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinelcmds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> retval<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd <span class="token operator">=</span> sentinelcmds<span class="token operator">+</span>j<span class="token punctuation">;</span>         retval <span class="token operator">=</span> <span class="token function">dictAdd</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>commands<span class="token punctuation">,</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverAssert</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//......</span>    <span class="token comment">//初始化各种数据结构</span>    <span class="token comment">//......</span><span class="token punctuation">}</span>  <span class="token comment">//所有sentinel可以执行的命令</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> sentinelcmds<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token string">"ping"</span><span class="token punctuation">,</span>pingCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"sentinel"</span><span class="token punctuation">,</span>sentinelCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"subscribe"</span><span class="token punctuation">,</span>subscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"unsubscribe"</span><span class="token punctuation">,</span>unsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"psubscribe"</span><span class="token punctuation">,</span>psubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"punsubscribe"</span><span class="token punctuation">,</span>punsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"publish"</span><span class="token punctuation">,</span>sentinelPublishCommand<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"pub-sub fast"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"info"</span><span class="token punctuation">,</span>sentinelInfoCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"random @dangerous"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">,</span>sentinelRoleCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"fast read-only @dangerous"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"client"</span><span class="token punctuation">,</span>clientCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin random @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"shutdown"</span><span class="token punctuation">,</span>shutdownCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"auth"</span><span class="token punctuation">,</span>authCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"no-auth fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span>helloCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"no-auth fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"acl"</span><span class="token punctuation">,</span>aclCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"command"</span><span class="token punctuation">,</span>commandCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"random @connection"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>初始化sentinel状态</p><p>接下来服务器会初始化一个<strong>sentinel.c/sentinelState</strong>，用于保存所有与sentinel功能有关的状态(redisServer保存了一般的状态)</p><pre class="language-c" data-language="c"><code class="language-c"> <span class="token comment">/** * sentinel 状态 */</span><span class="token comment">/* Main state. */</span><span class="token keyword">struct</span> <span class="token class-name">sentinelState</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> myid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* This sentinel ID. */</span>    <span class="token class-name">uint64_t</span> current_epoch<span class="token punctuation">;</span>         <span class="token comment">/* Current epoch. */</span> <span class="token comment">//当前纪元用户实现故障转移</span>     <span class="token comment">/**     * 当前哨兵监听的所有master字典     * key是实例名，value是指向sentinelRedisInstance 结构的指针     */</span>     dict <span class="token operator">*</span>masters<span class="token punctuation">;</span>      <span class="token comment">/* Dictionary of master sentinelRedisInstances.                           Key is the instance name, value is the                           sentinelRedisInstance structure pointer. */</span>    <span class="token comment">//是否进入了TILT模式                                          </span>    <span class="token keyword">int</span> tilt<span class="token punctuation">;</span>           <span class="token comment">/* Are we in TILT mode? */</span>    <span class="token comment">//目前正在执行的脚本数量</span>    <span class="token keyword">int</span> running_scripts<span class="token punctuation">;</span>    <span class="token comment">/* Number of scripts in execution right now. */</span>    <span class="token comment">//进入tilt模式的时间</span>    <span class="token class-name">mstime_t</span> tilt_start_time<span class="token punctuation">;</span>       <span class="token comment">/* When TITL started. */</span>    <span class="token comment">//最后一次执行处理器的时间</span>    <span class="token class-name">mstime_t</span> previous_time<span class="token punctuation">;</span>         <span class="token comment">/* Last time we ran the time handler. */</span>    <span class="token comment">//FIFO队列，包含所有需要执行的用户脚本</span>    list <span class="token operator">*</span>scripts_queue<span class="token punctuation">;</span>            <span class="token comment">/* Queue of user scripts to execute. */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>announce_ip<span class="token punctuation">;</span>  <span class="token comment">/* IP addr that is gossiped to other sentinels if                           not NULL. */</span>    <span class="token keyword">int</span> announce_port<span class="token punctuation">;</span>  <span class="token comment">/* Port that is gossiped to other sentinels if                           non zero. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> simfailure_flags<span class="token punctuation">;</span> <span class="token comment">/* Failures simulation. */</span>    <span class="token keyword">int</span> deny_scripts_reconfig<span class="token punctuation">;</span> <span class="token comment">/* Allow SENTINEL SET ... to change script                                  paths at runtime? */</span><span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span>   <span class="token comment">//sentinel 模块初始化</span><span class="token comment">/* Perform the Sentinel mode initialization. */</span><span class="token keyword">void</span> <span class="token function">initSentinel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">//...............</span>    <span class="token comment">// 清空常用命令；只添加sentinel 命令</span>    <span class="token comment">//..............</span>     <span class="token comment">//初始化各种数据结构</span>    <span class="token comment">/* Initialize various data structures. */</span>    sentinel<span class="token punctuation">.</span>current_epoch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>masters <span class="token operator">=</span> <span class="token function">dictCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>instancesDictType<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>tilt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>tilt_start_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>previous_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>running_scripts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>scripts_queue <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>announce_ip <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>announce_port <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>simfailure_flags <span class="token operator">=</span> SENTINEL_SIMFAILURE_NONE<span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>deny_scripts_reconfig <span class="token operator">=</span> SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>初始化sentinel状态的master属性</p><p>sentinelState状态中的master属性记录所有被sentinel监视的所有相关信息；</p><ul><li>sentinelState.masters的结构是hash；</li><li>字典键的被监视主服务的名字；</li><li>字典值则是 sentinel.c/sentinelRedisInstance结构体；</li></ul><p>根据sentinel启动时的指定的配置项或者配置文件来初始化</p><p>如果按照下图指定:</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155233753.png" alt="image-20211121155233753"></p><p>则最后的字典值为:</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155311843.png" alt="image-20211121155311843"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155327607.png" alt="image-20211121155327607"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155342021.png" alt="image-20211121155342021"></p><p>创建与主服务器的网络连接</p><p>sentinel会与被监控的master建立连接，sentinel将会成为master的客户端</p><p>sentinel会创建两个连接向master的异步网络连接：</p><ul><li>一个是命令连接，用于向master发送命令并接受回复</li><li>一个是订阅连接，用于订阅master的<code>__sentinel__:hello</code>频道</li></ul><blockquote><p><strong>为什么要有两个连接</strong></p><p>目前发布和订阅的功能，被发送的信息都不会保存在服务器里面；</p><p>如果发送时接受信息的客户端不在线，那么客户端就会丢失这条数据；为了不丢失<code>__sentinel__:hello</code>频道的任何信息，所以sentinel必须创建一个订阅连接来接受消息</p><p>因为是多个连接,所以必须是异步的</p><p><strong>创建入口：</strong><br>server.c/main -&gt; server.c/serverCron() -&gt; sentinel.c/sentinelTimer -&gt; sentinel.c/sentinelHandleDictOfRedisInstances() -&gt; sentinel.c/sentinelHandleRedisInstance</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//对于特定的redis实例执行预操作</span><span class="token comment">/* Perform scheduled operations for the specified Redis instance. */</span><span class="token keyword">void</span> <span class="token function">sentinelHandleRedisInstance</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* ========== MONITORING HALF ============ */</span>    <span class="token comment">/* Every kind of instance */</span>    <span class="token comment">//监控所有类型的实例(master,slave,sentinel)</span>    <span class="token function">sentinelReconnectInstance</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sentinelSendPeriodicCommands</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* ============== ACTING HALF ============= */</span>    <span class="token comment">/* We don't proceed with the acting half if we are in TILT mode.     * TILT happens when we find something odd with the time, like a     * sudden change in the clock. */</span>    <span class="token comment">//对于tilt模式下哨兵已经不可信,这时候检测是否时钟恢复正常,如果正常就推出tilt模式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>tilt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>sentinel<span class="token punctuation">.</span>tilt_start_time <span class="token operator">&lt;</span> sentinel_tilt_period<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        sentinel<span class="token punctuation">.</span>tilt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"-tilt"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">"#tilt mode exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Every kind of instance */</span>    <span class="token function">sentinelCheckSubjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Masters and slaves */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_MASTER<span class="token operator">|</span>SRI_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Nothing so far. */</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Only masters */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelCheckObjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sentinelStartFailoverIfNeeded</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_ASK_FORCED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelFailoverStateMachine</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_NO_FLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121204051572.png" alt="image-20211121204051572"></p><h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p>sentinel默认每10s一次频率向 master &amp; slale发送info命令</p><p>实现的入口:(server.c/main -&gt; server.c/serverCron() -&gt; sentinel.c/sentinelTimer -&gt; sentinel.c/sentinelHandleDictOfRedisInstances() -&gt; sentinel.c/sentinelSendPeriodicCommands)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 定期向指定的slave或master发送PING、INFO, 发布到消息到 “订阅”的channel */</span><span class="token comment">//类似于心跳检测</span><span class="token comment">/* Send periodic PING, INFO, and PUBLISH to the Hello channel to * the specified master or slave instance. */</span><span class="token keyword">void</span> <span class="token function">sentinelSendPeriodicCommands</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">mstime_t</span> now <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> info_period<span class="token punctuation">,</span> ping_period<span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token comment">/* Return ASAP if we have already a PING or INFO already pending, or     * in the case the instance is not properly connected. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>disconnected<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* For INFO, PING, PUBLISH that are not critical commands to send we     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't     * want to use a lot of memory just because a link is not working     * properly (note that anyway there is a redundant protection about this,     * that is, the link will be disconnected and reconnected if a long     * timeout condition is detected. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands <span class="token operator">&gt;=</span>        SENTINEL_MAX_PENDING_COMMANDS <span class="token operator">*</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>refcount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* If this is a slave of a master in O_DOWN condition we start sending     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD     * period. In this state we want to closely monitor slaves in case they     * are turned into masters by another Sentinel, or by the sysadmin.     *     * Similarly we monitor the INFO output more often if the slave reports     * to be disconnected from the master, so that we can have a fresh     * disconnection time figure. */</span>    <span class="token comment">//对于一个处于客观判断下线的slave,每秒发送info,避免被转换成了master</span>    <span class="token comment">//同时也检测其真实下线时间</span>    <span class="token comment">//todo:这里其实消耗的资源会比较多,有没有更好的解决办法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_SLAVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>master<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_O_DOWN<span class="token operator">|</span>SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>         <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>master_link_down_time <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        info_period <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        info_period <span class="token operator">=</span> sentinel_info_period<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* We ping instances every time the last received pong is older than     * the configured 'down-after-milliseconds' time, but every second     * anyway if 'down-after-milliseconds' is greater than 1 second. */</span>    ping_period <span class="token operator">=</span> ri<span class="token operator">-&gt;</span>down_after_period<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ping_period <span class="token operator">&gt;</span> sentinel_ping_period<span class="token punctuation">)</span> ping_period <span class="token operator">=</span> sentinel_ping_period<span class="token punctuation">;</span>    <span class="token comment">/* Send INFO to masters and slaves, not sentinels. */</span>    <span class="token comment">//向master和slave发送info命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_SENTINEL<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>info_refresh <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>info_refresh<span class="token punctuation">)</span> <span class="token operator">&gt;</span> info_period<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        retval <span class="token operator">=</span> <span class="token function">redisAsyncCommand</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token punctuation">,</span>            sentinelInfoReplyCallback<span class="token punctuation">,</span> ri<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span>            <span class="token function">sentinelInstanceMapCommand</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span><span class="token string">"INFO"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Send PING to all the three kinds of instances. */</span>    <span class="token comment">//对所有的实例发送ping</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>last_pong_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> ping_period <span class="token operator">&amp;&amp;</span>               <span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>last_ping_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> ping_period<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelSendPing</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* PUBLISH hello messages to all the three kinds of instances. */</span>    <span class="token comment">//向订阅的频道发布信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>last_pub_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> sentinel_publish_period<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelSendHello</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121205944717.png" alt="image-20211121205944717"></p><p>通过解析maser返回Info命令信息，获取master的当前信息；</p><ul><li>一方面获取master的信息，包括run_id、角色、地址等；</li><li>另一方面获取master下所有slave服务器信息；</li></ul><p>根据这些返回信息，用户无需提供从服务器信息，就可以自动发现从服务器（便于与从服务器建立连接）</p><p>这些信息用来更新slaves字典,出现了新的就要加入到字典中,键是从服务器的ip:port，值是从服务器的对应实例结构</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223027407.png" alt="image-20211121223027407"></p><p><strong>解析info返回结果入口</strong><br><strong>sentinel.c/sentinelSendPeriodicCommands</strong> -&gt; <strong>sentinel.c/sentinelInfoReplyCallback</strong> &gt; <strong>sentinel.c/sentinelInfoReplyCallback</strong> &gt; <strong>sentinel.c/sentinelRefreshInstanceInfo</strong></p><h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>对于每个连接到主服务器的从服务器也要建立命令连接和订阅连接</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223238004.png" alt="image-20211121223238004"></p><p>通过解析slave返回的slave的信息，主要提取以下信息。然后根据这些信息，更新从服务的实例信息；</p><ul><li>从服务的run_id</li><li>主服务器的ip地址以及端口号</li><li>主从服务器的连接状态</li><li>从服务器优先级</li><li>从服务的偏移量</li></ul><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223623465.png" alt="image-20211121223623465"></p><h3 id="向被监视的主从服务器发送信息"><a href="#向被监视的主从服务器发送信息" class="headerlink" title="向被监视的主从服务器发送信息"></a>向被监视的主从服务器发送信息</h3><p>每两秒进行一次</p><p>发送的内容：</p><ul><li>sentinel_ip :sentinel的ip；</li><li>sentinel_port：sentinel的端口</li><li>sentinel_runid：：sentinel的runid</li><li>sentinel_current_epoch:sentinel当前配置的纪元</li><li>master_name: master的名称</li><li>·master_ip：master的ip</li><li>master_port：master的端口</li><li>master_config_epoch：master的当前配置的纪元</li></ul><p>函数实现：（sentinel.c/sentinelSendHello）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//通过Pub/Sub向指定的redis实例(即ri)发送hello消息,广播主机当前的配置,通知sentinel存活</span><span class="token comment">//如果发布成功排队,返回C_OK,否则是C_ERR</span><span class="token keyword">int</span> <span class="token function">sentinelSendHello</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token operator">+</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>announce_ip<span class="token punctuation">;</span>    <span class="token keyword">int</span> announce_port<span class="token punctuation">;</span>    sentinelRedisInstance <span class="token operator">*</span>master <span class="token operator">=</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token operator">?</span> ri <span class="token operator">:</span> ri<span class="token operator">-&gt;</span>master<span class="token punctuation">;</span>    sentinelAddr <span class="token operator">*</span>master_addr <span class="token operator">=</span> <span class="token function">sentinelGetCurrentMasterAddress</span><span class="token punctuation">(</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>disconnected<span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">/* Use the specified announce address if specified, otherwise try to     * obtain our own IP address. */</span>    <span class="token comment">//设置广播的ip和端口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>announce_ip<span class="token punctuation">)</span> <span class="token punctuation">{</span>        announce_ip <span class="token operator">=</span> sentinel<span class="token punctuation">.</span>announce_ip<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">anetFdToString</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token operator">-&gt;</span>c<span class="token punctuation">.</span>fd<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>FD_TO_SOCK_NAME<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        announce_ip <span class="token operator">=</span> ip<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>announce_port<span class="token punctuation">)</span> announce_port <span class="token operator">=</span> sentinel<span class="token punctuation">.</span>announce_port<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>tls_replication <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>tls_port<span class="token punctuation">)</span> announce_port <span class="token operator">=</span> server<span class="token punctuation">.</span>tls_port<span class="token punctuation">;</span>    <span class="token keyword">else</span> announce_port <span class="token operator">=</span> server<span class="token punctuation">.</span>port<span class="token punctuation">;</span>    <span class="token comment">/* Format and send the Hello message. */</span>    <span class="token comment">//格式化要发送的消息</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>payload<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"%s,%d,%s,%llu,"</span> <span class="token comment">/* Info about this sentinel. */</span>        <span class="token string">"%s,%s,%d,%llu"</span><span class="token punctuation">,</span> <span class="token comment">/* Info about current master. */</span>        announce_ip<span class="token punctuation">,</span> announce_port<span class="token punctuation">,</span> sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">,</span>        <span class="token comment">/* --- */</span>        master<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span><span class="token function">announceSentinelAddr</span><span class="token punctuation">(</span>master_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>master_addr<span class="token operator">-&gt;</span>port<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> master<span class="token operator">-&gt;</span>config_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    retval <span class="token operator">=</span> <span class="token function">redisAsyncCommand</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token punctuation">,</span>        sentinelPublishReplyCallback<span class="token punctuation">,</span> ri<span class="token punctuation">,</span> <span class="token string">"%s %s %s"</span><span class="token punctuation">,</span>        <span class="token function">sentinelInstanceMapCommand</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span><span class="token string">"PUBLISH"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        SENTINEL_HELLO_CHANNEL<span class="token punctuation">,</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="接受来自主从服务器的频道信息"><a href="#接受来自主从服务器的频道信息" class="headerlink" title="接受来自主从服务器的频道信息"></a>接受来自主从服务器的频道信息</h3><p>当sentinel与主服务或者从服务建立连接后，sentinel就订阅主服务或从服务器的<code>__sentinel__::hello</code>频道；</p><p>订阅频道会一直持续到连接断开；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122130447110.png" alt="image-20211122130447110"></p><p>这样对于监听同一个服务器的多个sentinel，一个sentinel发送的信息会被其他sentinel接受到，这些信息会被其他sentinel用于更新信息；</p><p><strong>举个例子：</strong><br>假设有三个sentinel ，s1、s2、s3监听同一个服务器，s1向服务器频道<code>__sentinel__:hello</code>发送了一条信息，s1、s2、s3都会受到这条消息 ；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122145234776.png" alt="image-20211122145234776"></p><p>sentinel接受到消息后，会对消息进行解析:</p><ul><li>如果是自己发送的信息，就会丢弃该信息</li><li>如不是自己发送的，则是监视同一服务器的其他sentinel发送的，则会更新sentinel实例中相关信息</li></ul><h3 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h3><p>每个sentinel节点对于其他也监视这个主服务器的其他sentinel节点保存了一个instance结构</p><ul><li>键是其中一个 Sentinel 的名字， 格式为 ip:port</li><li>值是对应的实例结构</li></ul><p>收到其他sentinel发送的消息时，对于信息中sentinel，主服务器相关的参数配置做相应的记录</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122151957038.png" alt="image-20211122151957038"></p><p>sentinel节点保存的master实例中的sentinels字典不需要包含自身</p><p>sentinels字典利于发现监视同一个主服务器的其他sentinel节点</p><h3 id="创建连向其他sentinel节点的命令连接"><a href="#创建连向其他sentinel节点的命令连接" class="headerlink" title="创建连向其他sentinel节点的命令连接"></a>创建连向其他sentinel节点的命令连接</h3><p>使用命令连接相连的各个 Sentinel 可以通过向其他 Sentinel 发送命令请求来进行信息交换，但是不会创建订阅链接</p><p>Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新 Sentinel, 所以需要建立订阅连接， 而相互已知的 Sentinel 只要使用命令连接来进行通信就足够了   </p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122153845487.png" alt="image-20211122153845487"></p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>默认情况下sentinel每秒发送ping，然后通过回复的pong确认监视的对象是否下线</p><p>对于ping命令的回复分两种情况：</p><ul><li>有效回复：返回 +PONG、-LOADING、-MASTERDOWN</li><li>无效回复：除了上述三种的回复外，都是无效回复</li></ul><p>如果down-after-millseconds毫秒内，连续返回无效回复，那么sentinel就会将master标记为主观下线，在实例结构的flag属性中标记主观下线</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211125223705911.png" alt="image-20211125223705911"></p><blockquote><p>down-after-millonseconds是sentinel配置文件指定的下线标准；<br>这个参数不仅会应用于master，还会应用到master下属的所有从服务器；</p><p>多个sentinel设置的down-after-millseconds时间可能是不同的，所以可能部分的sentinel认为主观下线，而其他的认为没有主观下线</p></blockquote><h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当sentinel将一个主服务器判断主观下线时，会向其他sentinel询问，看其他sentinel是否也人为他下线；</p><p>当有足够多的sentinel认为服务已经下线时，就判定服务器是客观下线，并进行故障转移</p><h4 id="发送SENTINEL-is-master-down-by-addr命令"><a href="#发送SENTINEL-is-master-down-by-addr命令" class="headerlink" title="发送SENTINEL is-master-down-by-addr命令"></a>发送SENTINEL is-master-down-by-addr命令</h4><p>询问其他sentinel的命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">SENTINEL is-master-down-by-addr <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>current_epoch<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>runid<span class="token operator">&gt;</span></code></pre><p>各参数意义如下</p><ul><li>ip：被sentinel判断为主观下线的服务ip</li><li>port：被sentinel判断为主观下线的服务端口</li><li>current_epoch：sentinel当前配置的纪元，用于选取领头sentinel</li><li>runid:可以是*符号或者sentinel的运行id，* 代表用于检测主服务器的客观下线状态；sentinel的运行id 则代表用于选举领头的sentinel；</li></ul><h4 id="接受SENTINEL-is-master-down-by-addr命令"><a href="#接受SENTINEL-is-master-down-by-addr命令" class="headerlink" title="接受SENTINEL is-master-down-by-addr命令"></a>接受SENTINEL is-master-down-by-addr命令</h4><p>返回的信息是包含三个参数的multi bulk：</p><ul><li><down_state>：表示自己对于目标服务器在线状态的检测结果</down_state></li><li><leader_runid>：可以是 * 符号或者目标 Sentinel 的局部领头 Sentinel 的运行 ID: * 符号代表命令用于检测主服务器的下线状态， 而局部领头 Sentinel 的运行 ID 则用于选举领头 Sentinel</leader_runid></li><li><leader_epoch>  ：局部领头 Sentinel的运行纪元</leader_epoch></li></ul><h4 id="接受SENTINEL-is-master-down-by-addr命令-的回复"><a href="#接受SENTINEL-is-master-down-by-addr命令-的回复" class="headerlink" title="接受SENTINEL is-master-down-by-addr命令 的回复"></a>接受SENTINEL is-master-down-by-addr命令 的回复</h4><p>sentienl根据SENTINEL is-master-down-by-addr命令的返回，统计其他sentinel返回下线的数量；<br>当这一数量达到配置指定的客观下线数量（之前由quorum参数指定）时，sentinel会将服务器实例结构的flags属性的SIR_O_DOWN标记位打开，标识主服务进入客观下线状态；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211125223723501.png" alt="image-20211125223723501"></p><blockquote><p>同样的，多个sentinel设置的quorum参数可能是不同的，所以可能部分的sentinel认为客观下线，而其他的认为没有客观下线</p></blockquote><h3 id="选举sentinel领头者"><a href="#选举sentinel领头者" class="headerlink" title="选举sentinel领头者"></a>选举sentinel领头者</h3><p>当一个主服务器被判断为下线时，监视这个服务器sentinel的会进行协商，选举出一个领头的sentinel，由这个领头的sentinel执行故障转移操作</p><p><strong>选举领头sentinel的规则和方法</strong>：</p><ul><li>所有在线的sentinel都有被选为领头sentinel的资格</li><li>每次进行领头sentinel选举的时候，不论选举是否成功，所有sentinel的配置纪元的值都会+1；（配置的纪元就是个计数器）</li><li>每个配置的纪元里面，所有sentinel都有一票将某个sentinel设置为局部领头sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能更改了</li><li>每个发现主服务器下线的sentinel，都会要求其他sentinel将自己设置为领头sentinel</li><li>sentinel设置局部领头sentinel的选票规则是先到先得；最先向目标sentinel“索要投票” 将会得到该票，后续“索票”的sentinel将会被拒绝；</li><li>源sentinel收到目标sentinel的回复后，会解析回复中的leader_epoch；如果leader_epoch和源sentinel的一致，那么源sentinel会继续解析leader_runid参数；<br>如果leader_runid和源sentinel的run_id一致，说明目标sentinel将源sentinel设为了领头sentinel；</li><li>如果某sentinel被半数以上sentinel设置为了领头sentinel，那么这个sentinel将会成为领头sentinel；</li><li>如果给定的时间限制内，没有选举出领头sentinel，那么将在一段时间后重新选举，直到选举出为止；</li></ul><p>在这里和区块链选举比较相似</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选举出的领头sentinel将会已下线的主服务器进行下线操作，下线操作分为以下三个操作：</p><ol><li>在已下线的主服务的所有从服务器中，挑选出一个从服务器，将其转换为主服务器；</li><li>将已下线的主服务的所有从服务器，复制新的主服务器；</li><li>设置已经下线的主服务为从服务，并复制新的主服务，当下线的主服务重新上线后，就会复制新的主服务了；</li></ol><h4 id="选取新的主服务器步骤"><a href="#选取新的主服务器步骤" class="headerlink" title="选取新的主服务器步骤"></a>选取新的主服务器步骤</h4><ol><li>领头的sentinel会将下线的主服务的所有从服务放到一个列表里，然后按照以下规则对列表中一个个的过滤：</li><li>过滤掉已经断线的从服务器；</li><li>过滤掉最近5s内没有回复过sentinel 的info命令的从服务；</li><li>过滤掉与主服务器连接断开时间超过（down-after-millseconds * 10）毫秒的从服务器；这样可以保证剩余从服务器的数据比较新；</li><li>然后从剩余从服务器中选举优先级高的从服务器；</li><li>如果服务器优先级相同，则选取复制偏移量大的（复制偏移量大，说明数据新）；</li><li>至此，如果还没有选举出，则对运行id进行排序，选举出运行id最小的从服务器；</li></ol><p>选举出新的主服务后，sentinel将向新的主服务器发送slave no one ，转换成新的主服务器<br>然后领头sentinel以每秒一次的频率向新的主服务发送info命令,用于判断“切换主服务操作”是否成功（当新的主服务器角色由salve变成master，说明已经切换成功了）</p><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><p>新的主服务出现后，sentinel就会让所有从服务器去复制新的主服务器（通过salveof 命令实现）</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211126111618727.png" alt="image-20211126111618727"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211126111640191.png" alt="image-20211126111640191"></p><h4 id="修改旧的主服务器的为从服务器"><a href="#修改旧的主服务器的为从服务器" class="headerlink" title="修改旧的主服务器的为从服务器"></a>修改旧的主服务器的为从服务器</h4><p>最后，将已经下线的主服务设置为从服务器，并复制新的主服务；</p><p>注意：因为这时旧的主服务已经下线，所以这时这个操作先保存到sentinel对应的实例结构中，等到旧的主服务重新上线后，sentinel就会向他发送slaveof命令，将他设置为从服务器；</p><h3 id="tilt模式"><a href="#tilt模式" class="headerlink" title="tilt模式"></a>tilt模式</h3><p>Redis哨兵依赖于系统时间,为了了解某个实例是否是可用的,其会记住最后一次成功回复PING命令的时间,然后与现在时间进行比较判断生存时间.<br>但是如果计算机时间发生了意外的变化,或者计算机现在非常忙碌,或者进程因为某些原因阻塞,哨兵可能会有意料之外的行为</p><p>TILT是一个特殊的保护模式,Sentinel的Tilt模式会在以下两种情况下开启：</p><ol><li>Sentinel进程被阻塞超过SENTINEL_TILT_TRIGGER时间（默认为2s），可能因为进程或系统I/O（内存，网络，存储）请求过多。</li><li>系统时钟调整到之前某个时间值。</li></ol><p>进入tilt模式会降低系统的可靠性(因为此时故障转移无法进行).sentinel计时器中断一般一秒十次.我们希望两次定时器中断的时间内控制在大约100毫秒.</p><p>当进入TILT模式时哨兵将会继续监视所有内容,但是</p><ul><li>停止所有的动作</li><li>会开始否定<code>SENTINEL is-master-down-by-addr</code>命令因为其不信任故障检测的能力</li></ul><p>如果30秒以内一切正常则退出TILT模式.<br>注意可以使用很多内核提供的单调时钟API已替换TILT模式.但是尚不清楚这是否是一个好的解决方案,因为当前系统避免了如果进程只是被挂起或长时间未由调度程序执行这种问题.</p><p>在计算机时间发生严重变化的时候进入<code>TILT模式</code>,并禁止除了监控以外的操作,因为此时sentinel依赖于时间,判断某个节点下线是根据PING的间隔来实现的,如果进入<code>TILT模式</code>证明时钟出现问题,此时这个sentinel已经不能被相信了.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis客户端与服务器</title>
      <link href="/2022/01/27/redis-ke-hu-duan/"/>
      <url>/2022/01/27/redis-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="redis客户端与服务器"><a href="#redis客户端与服务器" class="headerlink" title="redis客户端与服务器"></a>redis客户端与服务器</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li><p>cli命令行</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">{</span>    <span class="token comment">//参数</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>    <span class="token comment">//参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>    <span class="token comment">//命令指针</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span><span class="token punctuation">}</span> multiCmd<span class="token punctuation">;</span></code></pre></li><li><p>client结构(直接对于所有的数据结构进行了解释)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//I/O复用,所以需要为每个客户端维持一个状态,多个客户端在服务器用链表链接</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span>    <span class="token comment">//client的id</span>    <span class="token class-name">uint64_t</span> id<span class="token punctuation">;</span>            <span class="token comment">/* Client incremental unique ID. */</span>    connection <span class="token operator">*</span>conn<span class="token punctuation">;</span>    <span class="token comment">//协议版本</span>    <span class="token keyword">int</span> resp<span class="token punctuation">;</span>               <span class="token comment">/* RESP protocol version. Can be 2 or 3. */</span>    <span class="token comment">//当前正在使用的数据库</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>            <span class="token comment">/* Pointer to currently SELECTed DB. */</span>    <span class="token comment">//客户端名字</span>    robj <span class="token operator">*</span>name<span class="token punctuation">;</span>             <span class="token comment">/* As set by CLIENT SETNAME. */</span>    <span class="token comment">//缓冲区,用于储存指令</span>    sds querybuf<span class="token punctuation">;</span>           <span class="token comment">/* Buffer we use to accumulate client queries. */</span>    <span class="token comment">//在指令缓冲区中已经读到的位置</span>    <span class="token class-name">size_t</span> qb_pos<span class="token punctuation">;</span>          <span class="token comment">/* The position we have read in querybuf. */</span>    sds pending_querybuf<span class="token punctuation">;</span>   <span class="token comment">/* If this client is flagged as master, this buffer                               represents the yet not applied portion of the                               replication stream that we are receiving from                               the master. */</span>    <span class="token comment">//最近时间内缓冲区长度最大值</span>    <span class="token class-name">size_t</span> querybuf_peak<span class="token punctuation">;</span>   <span class="token comment">/* Recent (100ms or more) peak of querybuf size. */</span>    <span class="token comment">//当前指令的参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>               <span class="token comment">/* Num of arguments of current command. */</span>    <span class="token comment">//当前指令参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>            <span class="token comment">/* Arguments of current command. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数数量</span>    <span class="token keyword">int</span> original_argc<span class="token punctuation">;</span>      <span class="token comment">/* Num of arguments of original command if arguments were rewritten. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>original_argv<span class="token punctuation">;</span>   <span class="token comment">/* Arguments of original command if arguments were rewritten. */</span>    <span class="token class-name">size_t</span> argv_len_sum<span class="token punctuation">;</span>    <span class="token comment">/* Sum of lengths of objects in argv list. */</span>    <span class="token comment">//记录客户端执行的命令</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token operator">*</span>lastcmd<span class="token punctuation">;</span>  <span class="token comment">/* Last command executed. */</span>    <span class="token comment">//与之前定义的user对应,从而赋予相应的权限,NULL是管理员</span>    user <span class="token operator">*</span>user<span class="token punctuation">;</span>             <span class="token comment">/* User associated with this connection. If the                               user is set to NULL the connection can do                               anything (admin). */</span>    <span class="token comment">//指令类型,一条指令还是多条(内联)</span>    <span class="token keyword">int</span> reqtype<span class="token punctuation">;</span>            <span class="token comment">/* Request protocol type: PROTO_REQ_* */</span>    <span class="token comment">//还未读取的指令数量</span>    <span class="token keyword">int</span> multibulklen<span class="token punctuation">;</span>       <span class="token comment">/* Number of multi bulk arguments left to read. */</span>    <span class="token comment">//未读指令的</span>    <span class="token keyword">long</span> bulklen<span class="token punctuation">;</span>           <span class="token comment">/* Length of bulk argument in multi bulk request. */</span>    <span class="token comment">//回复链表</span>    list <span class="token operator">*</span>reply<span class="token punctuation">;</span>            <span class="token comment">/* List of reply objects to send to the client. */</span>    <span class="token comment">//回复链表中对象的总大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> reply_bytes<span class="token punctuation">;</span> <span class="token comment">/* Tot bytes of objects in reply list. */</span>    <span class="token comment">// 已发送字节，用于处理 short write </span>    <span class="token class-name">size_t</span> sentlen<span class="token punctuation">;</span>         <span class="token comment">/* Amount of bytes already sent in the current                               buffer or object being sent. */</span>    <span class="token comment">//创建客户端时间</span>    <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span>           <span class="token comment">/* Client creation time. */</span>    <span class="token keyword">long</span> duration<span class="token punctuation">;</span>          <span class="token comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span>    <span class="token comment">// 客户端最后一次和服务器互动的时间</span>    <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span> <span class="token comment">/* Time of the last interaction, used for timeout */</span>    <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span>    <span class="token comment">//客户端状态CLIENT_*</span>    <span class="token class-name">uint64_t</span> flags<span class="token punctuation">;</span>         <span class="token comment">/* Client flags: CLIENT_* macros. */</span>    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>      <span class="token comment">/* Needed when the default user requires auth. */</span>    <span class="token comment">//复制状态</span>    <span class="token keyword">int</span> replstate<span class="token punctuation">;</span>          <span class="token comment">/* Replication state if this is a slave. */</span>    <span class="token keyword">int</span> repl_put_online_on_ack<span class="token punctuation">;</span> <span class="token comment">/* Install slave write handler on first ACK. */</span>    <span class="token comment">// 用于保存主服务器传来的 RDB 文件的文件描述符</span>    <span class="token keyword">int</span> repldbfd<span class="token punctuation">;</span>           <span class="token comment">/* Replication DB file descriptor. */</span>    <span class="token comment">// 读取主服务器传来的 RDB 文件的偏移量</span>    <span class="token class-name">off_t</span> repldboff<span class="token punctuation">;</span>        <span class="token comment">/* Replication DB file offset. */</span>    <span class="token comment">// 主服务器传来的 RDB 文件的大小</span>    <span class="token class-name">off_t</span> repldbsize<span class="token punctuation">;</span>       <span class="token comment">/* Replication DB file size. */</span>    sds replpreamble<span class="token punctuation">;</span>       <span class="token comment">/* Replication DB preamble. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> read_reploff<span class="token punctuation">;</span> <span class="token comment">/* Read replication offset if this is a master. */</span>    <span class="token comment">// 主服务器的复制偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> reploff<span class="token punctuation">;</span>      <span class="token comment">/* Applied replication offset if this is a master. */</span>    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_off<span class="token punctuation">;</span> <span class="token comment">/* Replication ack offset, if this is a slave. */</span>    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 的时间</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_time<span class="token punctuation">;</span><span class="token comment">/* Replication ack time, if this is a slave. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_last_partial_write<span class="token punctuation">;</span> <span class="token comment">/* The last time the server did a partial write from the RDB child pipe to this replica  */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> psync_initial_offset<span class="token punctuation">;</span> <span class="token comment">/* FULLRESYNC reply offset other slaves                                       copying this slave output buffer                                       should use. */</span>    <span class="token comment">// 主服务器的 master run ID</span>    <span class="token comment">// 保存在客户端，用于执行部分重同步</span>    <span class="token keyword">char</span> replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Master replication ID (if master). */</span>    <span class="token comment">// 从服务器的监听端口号</span>    <span class="token keyword">int</span> slave_listening_port<span class="token punctuation">;</span> <span class="token comment">/* As configured with: REPLCONF listening-port */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>slave_addr<span class="token punctuation">;</span>       <span class="token comment">/* Optionally given by REPLCONF ip-address */</span>    <span class="token keyword">int</span> slave_capa<span class="token punctuation">;</span>         <span class="token comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span>    <span class="token comment">//事务状态</span>    multiState mstate<span class="token punctuation">;</span>      <span class="token comment">/* MULTI/EXEC state */</span>    <span class="token comment">//阻塞类型</span>    <span class="token keyword">int</span> btype<span class="token punctuation">;</span>              <span class="token comment">/* Type of blocking op if CLIENT_BLOCKED. */</span>    <span class="token comment">//阻塞状态</span>    blockingState bpop<span class="token punctuation">;</span>     <span class="token comment">/* blocking state */</span>    <span class="token comment">// 最后被写入的全局复制偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> woff<span class="token punctuation">;</span>         <span class="token comment">/* Last write global replication offset. */</span>    list <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>     <span class="token comment">/* Keys WATCHED for MULTI/EXEC CAS */</span>    <span class="token comment">// 这个字典记录了客户端所有订阅的频道</span>    <span class="token comment">// 键为频道名字，值为 NULL</span>    <span class="token comment">// 也即是，一个频道的集合</span>    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment">/* channels a client is interested in (SUBSCRIBE) */</span>    <span class="token comment">// 链表，包含多个 pubsubPattern 结构</span>    <span class="token comment">// 记录了所有订阅频道的客户端的信息</span>    <span class="token comment">// 新 pubsubPattern 结构总是被添加到表尾</span>    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment">/* patterns a client is interested in (SUBSCRIBE) */</span>    sds peerid<span class="token punctuation">;</span>             <span class="token comment">/* Cached peer ID. */</span>    sds sockname<span class="token punctuation">;</span>           <span class="token comment">/* Cached connection target address. */</span>    listNode <span class="token operator">*</span>client_list_node<span class="token punctuation">;</span> <span class="token comment">/* list node in client list */</span>    listNode <span class="token operator">*</span>paused_list_node<span class="token punctuation">;</span> <span class="token comment">/* list node within the pause list */</span>    RedisModuleUserChangedFunc auth_callback<span class="token punctuation">;</span> <span class="token comment">/* Module callback to execute                                               * when the authenticated user                                               * changes. */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>auth_callback_privdata<span class="token punctuation">;</span> <span class="token comment">/* Private data that is passed when the auth                                   * changed callback is executed. Opaque for                                   * Redis Core. */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>auth_module<span class="token punctuation">;</span>      <span class="token comment">/* The module that owns the callback, which is used                             * to disconnect the client if the module is                             * unloaded for cleanup. Opaque for Redis Core.*/</span>    <span class="token comment">/* If this client is in tracking mode and this field is non zero,     * invalidation messages for keys fetched by this client will be send to     * the specified client ID. */</span>    <span class="token class-name">uint64_t</span> client_tracking_redirection<span class="token punctuation">;</span>    rax <span class="token operator">*</span>client_tracking_prefixes<span class="token punctuation">;</span> <span class="token comment">/* A dictionary of prefixes we are already                                      subscribed to in BCAST mode, in the                                      context of client side caching. */</span>    <span class="token comment">/* In clientsCronTrackClientsMemUsage() we track the memory usage of     * each client and add it to the sum of all the clients of a given type,     * however we need to remember what was the old contribution of each     * client, and in which category the client was, in order to remove it     * before adding it the new value. */</span>    <span class="token class-name">uint64_t</span> client_cron_last_memory_usage<span class="token punctuation">;</span>    <span class="token keyword">int</span>      client_cron_last_memory_type<span class="token punctuation">;</span>    <span class="token comment">/* Response buffer */</span>    <span class="token comment">// 回复偏移量</span>    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> buf_usable_size<span class="token punctuation">;</span> <span class="token comment">/* Usable size of buffer. */</span>    <span class="token comment">/* Note that 'buf' must be the last field of client struct, because memory     * allocator may give us more memory than our apply for reducing fragments,     * but we want to make full use of given memory, i.e. we may access the     * memory after 'buf'. To avoid make others fields corrupt, 'buf' must be     * the last one. */</span>    <span class="token comment">//回复缓冲区</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>PROTO_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> client<span class="token punctuation">;</span></code></pre><p>所有的client属性连成了一个链表,保存在redisServer的clients属性中,对于不同状态的client也有其他的链表保存.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token comment">//链表,保存了所有的客户端状态</span>    list <span class="token operator">*</span>clients<span class="token punctuation">;</span>              <span class="token comment">/* List of active clients */</span>    <span class="token comment">//保存所有的待关闭客户端</span>    list <span class="token operator">*</span>clients_to_close<span class="token punctuation">;</span>     <span class="token comment">/* Clients to close asynchronously */</span>    <span class="token comment">//将要写的客户端列表</span>    list <span class="token operator">*</span>clients_pending_write<span class="token punctuation">;</span> <span class="token comment">/* There is to write or install handler. */</span>    <span class="token comment">//将要读的客户端列表(已经知道有指令输入了)</span>    list <span class="token operator">*</span>clients_pending_read<span class="token punctuation">;</span>  <span class="token comment">/* Client has pending read socket buffers. */</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>包含通用属性(所有客户端执行基础功能都必须需要的)和特定功能(执行特定功能)相关的属性</p><ul><li><p>套接字描述符uint64_t id;</p><ul><li>伪客户端:id为-1,载入AOF文件时使用,或者是执行Lua脚本中包含的redis命令</li><li>普通客户端的id大于-1,表示是正常的客户端</li></ul></li><li><p>名字robj *name;</p><ul><li>可有可无,一个robj对象,没有的时候指定为NULL</li></ul></li><li><p>标志uint64_t flags;</p><ul><li><p>表示了当前客户端的角色和状态</p></li><li><p>可以是单个也可以是多个标志的二进制取或.见CLIENT_*的定义可知,都是一位表示的</p></li><li><p>源代码：</p><pre class="language-c#" data-language="c#"><code class="language-c#">/* Client flags *///主从服务器进行复制时,相互都是客户端的关系,slave和master区分两个服务器#define CLIENT_SLAVE (1&lt;&lt;0)   /* This client is a replica */#define CLIENT_MASTER (1&lt;&lt;1)  /* This client is a master *///正在执行monitor指令,是一个从客户端#define CLIENT_MONITOR (1&lt;&lt;2) /* This client is a slave monitor, see MONITOR *///执行事务#define CLIENT_MULTI (1&lt;&lt;3)   /* This client is in a MULTI context *///客户端被阻塞#define CLIENT_BLOCKED (1&lt;&lt;4) /* The client is waiting in a blocking operation *///事务使用WATCH监视的数据库键已经被修改,EXEC执行过程中会直接fail#define CLIENT_DIRTY_CAS (1&lt;&lt;5)//用户对这个客户端执行了 CLIENT KILL命令或者客户端发送给服务器的命令中协议内容有误, //服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端,然后关闭客户端#define CLIENT_CLOSE_AFTER_REPLY (1&lt;&lt;6) /* Close after writing entire reply. *///从阻塞中解除,只有在之前阻塞过才可用#define CLIENT_UNBLOCKED (1&lt;&lt;7) /* This client was unblocked and is stored in                                  server.unblocked_clients *///专门处理Lua脚本的客户端#define CLIENT_LUA (1&lt;&lt;8) /* This is a non connected client used by Lua *///客户端向集群节点（ 运行在集群模式下的服务器） 发送了ASKING 命令#define CLIENT_ASKING (1&lt;&lt;9)     /* Client issued the ASKING command *///客户端的输出缓冲区大小超出了服务器允许的范围，//服务器会在下一次执行 serverCron 函数时关闭这个客户端,以免影响服务器的稳定性//积存在输出缓冲区中的所有内容会直接被释放,不会返回给客户端.#define CLIENT_CLOSE_ASAP (1&lt;&lt;10)/* Close this client ASAP *///服务器使用 UNIX 套接字来连接客户端#define CLIENT_UNIX_SOCKET (1&lt;&lt;11) /* Client connected via Unix domain socket *///事务在命令入队时出现了错误, 和CLIENT_DIRTY_CAS 都表示了事务不安全,EXEC会执行失败#define CLIENT_DIRTY_EXEC (1&lt;&lt;12)  /* EXEC will fail for errors while queueing *///在主从服务器进行命令传播期间,从服务器需要向主服务器发送REPLICATION ACK命令//发送命令之前需要打开这个标志以允许发送操作执行#define CLIENT_MASTER_FORCE_REPLY (1&lt;&lt;13)  /* Queue replies even if is master *///执行PUBSUB指令时打开,强制服务器将当前执行的命令写人到 AOF 文件里面#define CLIENT_FORCE_AOF (1&lt;&lt;14)   /* Force AOF propagation of current cmd. *///执行SCRIPT LOADD指令时打开,强制主服务器将当前执行的命令复制给所有从服务器#define CLIENT_FORCE_REPL (1&lt;&lt;15)  /* Force replication of current cmd. *///主服务器不能使用PSYNC命令与当前低版本从服务器进行同步.//这个标志只能在 REDIS_SLAVE 标志处于打开状态时使用#define CLIENT_PRE_PSYNC (1&lt;&lt;16)   /* Instance don't understand PSYNC. */#define CLIENT_READONLY (1&lt;&lt;17)    /* Cluster client is in read-only state. */#define CLIENT_PUBSUB (1&lt;&lt;18)      /* Client is in Pub/Sub mode. */#define CLIENT_PREVENT_AOF_PROP (1&lt;&lt;19)  /* Don't propagate to AOF. */#define CLIENT_PREVENT_REPL_PROP (1&lt;&lt;20)  /* Don't propagate to slaves. */#define CLIENT_PREVENT_PROP (CLIENT_PREVENT_AOF_PROP|CLIENT_PREVENT_REPL_PROP)#define CLIENT_PENDING_WRITE (1&lt;&lt;21) /* Client has output to send but a write                                        handler is yet not installed. */#define CLIENT_REPLY_OFF (1&lt;&lt;22)   /* Don't send replies to client. */#define CLIENT_REPLY_SKIP_NEXT (1&lt;&lt;23)  /* Set CLIENT_REPLY_SKIP for next cmd */#define CLIENT_REPLY_SKIP (1&lt;&lt;24)  /* Don't send just this reply. */#define CLIENT_LUA_DEBUG (1&lt;&lt;25)  /* Run EVAL in debug mode. */#define CLIENT_LUA_DEBUG_SYNC (1&lt;&lt;26)  /* EVAL debugging without fork() */#define CLIENT_MODULE (1&lt;&lt;27) /* Non connected client used by some module. */#define CLIENT_PROTECTED (1&lt;&lt;28) /* Client should not be freed for now. */#define CLIENT_PENDING_READ (1&lt;&lt;29) /* The client has pending reads and was put                                       in the list of clients we can read                                       from. */#define CLIENT_PENDING_COMMAND (1&lt;&lt;30) /* Indicates the client has a fully                                        * parsed command ready for execution. */#define CLIENT_TRACKING (1ULL&lt;&lt;31) /* Client enabled keys tracking in order to                                   perform client side caching. */#define CLIENT_TRACKING_BROKEN_REDIR (1ULL&lt;&lt;32) /* Target client is invalid. */#define CLIENT_TRACKING_BCAST (1ULL&lt;&lt;33) /* Tracking in BCAST mode. */#define CLIENT_TRACKING_OPTIN (1ULL&lt;&lt;34)  /* Tracking in opt-in mode. */#define CLIENT_TRACKING_OPTOUT (1ULL&lt;&lt;35) /* Tracking in opt-out mode. */#define CLIENT_TRACKING_CACHING (1ULL&lt;&lt;36) /* CACHING yes/no was given,                                              depending on optin/optout mode. */#define CLIENT_TRACKING_NOLOOP (1ULL&lt;&lt;37) /* Don't send invalidation messages                                             about writes performed by myself.*/#define CLIENT_IN_TO_TABLE (1ULL&lt;&lt;38) /* This client is in the timeout table. */#define CLIENT_PROTOCOL_ERROR (1ULL&lt;&lt;39) /* Protocol error chatting with it. */#define CLIENT_CLOSE_AFTER_COMMAND (1ULL&lt;&lt;40) /* Close after executing commands                                               * and writing entire reply. */#define CLIENT_DENY_BLOCKING (1ULL&lt;&lt;41) /* Indicate that the client should not be blocked.                                           currently, turned on inside MULTI, Lua, RM_Call,                                           and AOF client */#define CLIENT_REPL_RDBONLY (1ULL&lt;&lt;42) /* This client is a replica that only wants RDB without replication buffer. */</code></pre></li><li><p>PUBSUB命令:本身不修改数据库,但是向频道的所有订阅者发送消息的行为带有副作用， 接收到消息的所有客户端的状态都会因为这个命令而改变,所以也需要写入AOF.</p></li><li><p>SCRIPT LOAD命令:类似的,它修改了服务器状态,也带有副作用,同时因为涉及到主从服务器,CLIENT_FORCE_REPL将指令发给所有的从服务器.</p></li></ul></li><li><p>输入缓冲区</p><ul><li><p>源代码：</p><pre class="language-c#" data-language="c#"><code class="language-c#">typedef struct client {//缓冲区,用于储存指令    sds querybuf;           /* Buffer we use to accumulate client queries. */}client;</code></pre></li><li><p>保存用户发送的命令请求,根据输入内容动态变化大小</p></li></ul></li><li><p>命令和命令参数</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span><span class="token comment">//当前指令的参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>               <span class="token comment">/* Num of arguments of current command. */</span>    <span class="token comment">//当前指令参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>            <span class="token comment">/* Arguments of current command. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数数量</span>    <span class="token keyword">int</span> original_argc<span class="token punctuation">;</span>      <span class="token comment">/* Num of arguments of original command if arguments were rewritten. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>original_argv<span class="token punctuation">;</span>   <span class="token comment">/* Arguments of original command if arguments were rewritten. */</span>    <span class="token class-name">size_t</span> argv_len_sum<span class="token punctuation">;</span>    <span class="token comment">/* Sum of lengths of objects in argv list. */</span>    <span class="token punctuation">}</span>client<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>命令实现函数</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span><span class="token comment">//记录客户端执行的命令</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token operator">*</span>lastcmd<span class="token punctuation">;</span>  <span class="token comment">/* Last command executed. */</span><span class="token punctuation">}</span>client<span class="token punctuation">;</span></code></pre></li><li><p>根据项argv[0] 的值,在命令表中査找命令所对应的命令实现函数,找到之后将客户端状态的cmd执行那个在命令表之中的这个结构,这个结构保存了命令的实现函数、 命令的标志 、 命令应该给定的参数个数、 命令的总执行次数和总消耗时长等统计信息  </p></li></ul></li><li><p>输出缓冲区</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token comment">/* Response buffer */</span>    <span class="token comment">// 回复偏移量</span>    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> buf_usable_size<span class="token punctuation">;</span> <span class="token comment">/* Usable size of buffer. */</span>    <span class="token comment">/* Note that 'buf' must be the last field of client struct, because memory     * allocator may give us more memory than our apply for reducing fragments,     * but we want to make full use of given memory, i.e. we may access the     * memory after 'buf'. To avoid make others fields corrupt, 'buf' must be     * the last one. */</span>    <span class="token comment">//回复缓冲区,放在最后,因为内存分配的时候可能多给了一些内存,实际上并没有用到</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>PROTO_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> client<span class="token punctuation">;</span></code></pre></li><li><p>当 buf 数组的空间已经用完,或者回复因为太大而没办法放进 buf 数组里面时， 服务器就会开始使用可变大小缓冲区<code>list *reply;</code>,一个链表连接多个字符串对象,可以保存很长的回复信息</p></li></ul></li><li><p>身份验证</p><ul><li>int authenticated;</li><li>启用了身份验证之后,当属性为0时,除了AUTH指令,其他指令都会被拒绝.</li></ul></li><li><p>时间</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建客户端时间</span>   <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span>           <span class="token comment">/* Client creation time. */</span>   <span class="token keyword">long</span> duration<span class="token punctuation">;</span>          <span class="token comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span>   <span class="token comment">// 客户端最后一次和服务器互动的时间,即客户端空转时间</span>   <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span> <span class="token comment">/* Time of the last interaction, used for timeout */</span><span class="token comment">//达到buf软性限制的时间,太长的话会被kill</span>   <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>限制缓冲区大小</p><ul><li>硬性限制（ hard limit ): 如果输出缓冲区的大小超过了硬性限制所设置的大小， 那么服务器立即关闭客户端。</li><li>软性限制（ softlimit ): 如果输出缓冲区的大小超过了软性限制所设置的大小， 但还没超过硬性限制， 那么服务器将使用客户端状态结构的 <code>obuf_soft_limit_ reached_time </code>属性记录下客户端到达软性限制的起始时间； 之后服务器会继续监视客户端， 如果输出缓冲区的大小一直超出软性限制， 并且持续时间超过服务器设定的时长， 那么服务器将关闭客户端;如果不再超过的话就直接清零属性值,不关闭客户端</li></ul></li></ul><h3 id="客户端的类型"><a href="#客户端的类型" class="headerlink" title="客户端的类型"></a>客户端的类型</h3><ul><li><p>普通客户端</p><ul><li>直接按照之前的模式执行相关程序即可</li></ul></li><li><p>Lua脚本的伪客户端</p><ul><li>Lua_client 伪客户端在服务器初始化的时候就创建了,服务器运行的整个生命期中会一直存在,服务器被关闭时， 这个客户端才会被关闭</li></ul></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>Redis 服务器的命令请求来自 Redis 客户端， 当用户在客户端中键人一个命令请求时，客户端会将这个命令请求转换成协议格式， 然后通过连接到服务器的套接字， 将协议格式的命令请求发送给服务器</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRid1<span class="token text string">[用户]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">键入命令请求</span><span class="token arrow operator">--&gt;</span></span>id2<span class="token text string">[客户端]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">将命令转换为协议的格式并发送</span><span class="token arrow operator">--&gt;</span></span>id3<span class="token text string">[服务器]</span></code></pre><h4 id="读取请求"><a href="#读取请求" class="headerlink" title="读取请求"></a>读取请求</h4><p>客户端与服务器之间的连接套接字因为客户端的写入而变得可读,服务器将调用命令请求处理器:</p><ol><li>读取套接字中协议格式的命令请求， 并保存到客户端的输入缓冲区里面</li><li>对输入缓冲区中的命令请求进行分析， 提取出命令请求中包含的命令参数， 以及命<br>令参数的个数， 然后分别将参数和参数个数保存到客户端的argv属性和argc 属性里面</li><li>调用命令执行器， 执行客户端指定的命令  </li></ol><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><h5 id="查找命令实现"><a href="#查找命令实现" class="headerlink" title="查找命令实现"></a>查找命令实现</h5><p>根据客户端状态的 argv [ 0 ] 参数， 在命令表中查找参数所指定的命令， 并将找到的命令保存到客户端的 cmd 属性.</p><blockquote><p>命令表(redisCommandTable)是一个字典,键是命令名字,值是redisCommand结构,记录了命令的实现信息</p></blockquote><h5 id="执行预备操作"><a href="#执行预备操作" class="headerlink" title="执行预备操作"></a>执行预备操作</h5><p>检查上一步执行结果和执行命令的环境,权限等</p><h5 id="调用命令实现函数"><a href="#调用命令实现函数" class="headerlink" title="调用命令实现函数"></a>调用命令实现函数</h5><p>执行<code>client-&gt;cmd-&gt;proc(client);</code>,执行函数之后产生相应的命令回复,保存在客户端状态的输出缓冲区(buf和reply)</p><h5 id="执行后续工作"><a href="#执行后续工作" class="headerlink" title="执行后续工作"></a>执行后续工作</h5><p>记录日志等后续</p><h4 id="将回复发送给客户端"><a href="#将回复发送给客户端" class="headerlink" title="将回复发送给客户端"></a>将回复发送给客户端</h4><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面， 并为客户端的套接字关联命令回复处理器， 当客户端套接字变为可写状态时， 服务器就会执行命令回复处理器， 将保存在客户端输出缓冲区中的命令回复发送给客户端。  发送完之后将缓冲区清空.</p><h4 id="客户端接受并打印命令回复"><a href="#客户端接受并打印命令回复" class="headerlink" title="客户端接受并打印命令回复"></a>客户端接受并打印命令回复</h4><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112225309381.png" alt="image-20211112225309381"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>SET KEY VALUE</p><ol><li><p>先由客户端转换成协议<code>*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n  </code>并发送给服务器</p></li><li><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112111306721.png" alt="image-20211112111306721"><img src="/2022/01/27/redis-ke-hu-duan/image-20211112111326098.png" alt="image-20211112111326098"></p></li><li><p>命令执行过程</p><ol><li><p>查找命令实现</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112195218882.png" alt="image-20211112195218882"></p></li><li><p>调用实现函数</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112223826504.png" alt="image-20211112223826504"></p></li><li><p>保存回复到缓冲区</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112224130202.png" alt="image-20211112224130202"></p></li></ol></li><li><p>将<code>+OK\r\n</code>发送给客户端</p></li><li><p>客户端转换格式为<code>OK\n</code>并显示</p></li></ol><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><ul><li><p>默认每隔 100 毫秒执行一次</p></li><li><p>负责管理服务器的资源， 并保持服务器自身的良好运转</p></li><li><p>更新的内容:</p><ul><li><p>更新服务器时间缓存</p><p>实时获取系统当前时间开销比较大,对于时间精度要求不是很高的使用地方使用缓存时间就可以.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//保存秒级精度的系统当前UNIX时间戳</span>redisAtomic <span class="token class-name">time_t</span> unixtime<span class="token punctuation">;</span><span class="token comment">//毫秒级精度的当前时间戳</span><span class="token class-name">mstime_t</span> mstime<span class="token punctuation">;</span>            <span class="token comment">//微秒级精度的当前时间戳</span><span class="token class-name">ustime_t</span> ustime<span class="token punctuation">;</span></code></pre><p>serverCron就是定时更新时间缓存的</p></li><li><p>更新LRU时钟</p></li><li><p>更新redis对象的空转时长属性</p></li><li><p>更新服务器每秒执行命令次数</p><p>嵌套调用的trackOperationsPerSecond函数抽样调查服务器一秒执行命令数量</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//抽样记录服务器每秒执行的命令数量</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> last_sample_time<span class="token punctuation">;</span> <span class="token comment">/* Timestamp of last sample in ms */</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> last_sample_count<span class="token punctuation">;</span><span class="token comment">/* Count in last sample */</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> samples<span class="token punctuation">[</span>STATS_METRIC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx<span class="token punctuation">;</span>    <span class="token punctuation">}</span> inst_metric<span class="token punctuation">[</span>STATS_METRIC_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>每次执行和上次执行的记录结果做比较,估算这一秒的执行情况</p></li><li><p>更新服务器内存峰值记录</p><pre class="language-none"><code class="language-none">size_t stat_peak_memory;//已用内存峰值</code></pre><p>查看使用的内存数量,记录使用时的最大值</p></li><li><p>处理sigterm信号</p><p>为信号关联处理器sigtermHandler函数,负责在服务器接到sigterm信号的时候根据shutdown_asap决定是否关闭服务器(关闭之前先完成持久化操作)</p></li><li><p>管理客户端资源</p><p>clientsCron函数对客户端进行检查,连接是否超时,输入缓冲区是否过大.</p></li><li><p>管理数据库资源</p><p>databasesCron函数对数据库和其中的过期键,字典进行检查</p></li><li><p>执行被延迟的BGREWRITEAOGF</p><p>在服务器执行bgsave命令的期间， 如果客户端向服务器发来 BGREWRITEAOF 命令，那 么 服 务 器 会 将 命 令 的 执 行 时 间 延 迟 到 bgsave命 令 执 行 完 毕 之 后 </p></li></ul></li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><h4 id="初始化状态结构"><a href="#初始化状态结构" class="headerlink" title="初始化状态结构"></a>初始化状态结构</h4><p>创建一个<code>struct redisServer</code>实例变量,设置默认值,创建命令表</p><p>主要由initServerConfig函数完成</p><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>根据redis.config文件或者启动时指定的配置项配置其他选项</p><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>创建服务器需要的除命令表之外的其他数据结构,需要用到之前的配置信息</p><p>initServre负责初始化这些数据结构和一些其他的设置操作,包括:</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象： 这些对象包含 Redis 服务器经常用到的一些值， 比如包含”OK”和”ERR”回复的字符串对象， 包含整数 1 到 10000 的字符串对象等等， 服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口， 并为监听套接字关联连接应答事件处理器， 等待服务器正<br>式运行时接受客户端的连接。</li><li>为 serverCron 函数创建时间事件， 等待服务器正式运行时执行 serverCron 函数。</li><li>如果 AOF 持久化功能已经打开， 那么打开现有的 AOF 文件， 如果 AOF 文件不存在，<br>那么创建并打开一个新的 AOF 文件， 为 AOF 写入做好准备。</li><li>初始化服务器的后台 I/O 模块（ bio )， 为将来的 I/O 操作做好准备  </li></ul><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>载入AOF或者RDB文件</p><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>打开事件循环,之后就可以接受命令</p><h1 id="多机数据库实现"><a href="#多机数据库实现" class="headerlink" title="多机数据库实现"></a>多机数据库实现</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>SLAVEOF可以让从服务器复制主服务器的内容,二者保存的数据是一致的</p><h3 id="旧版复制功能"><a href="#旧版复制功能" class="headerlink" title="旧版复制功能"></a>旧版复制功能</h3><p>以前直接在重连的时候复制整个数据库的RDB文件,bgsave开销非常大(相当于重新执行了一次sync,期间对于主服务器不能执行其他命令,需要保存在缓冲区)</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211117222257569.png" alt="image-20211117222257569"></p><p>执行SYNC命令:</p><ul><li>主服务器需要执行BGSAVE命令来生成 RDB 文件， 这个生成操作会耗费主服务器大量的 CPU、 内存和磁盘 I/O 资源。</li><li>主服务器需要将自己生成的 RDB 文件发送给从服务器， 这个发送操作会耗费主从服务器大量的网络资源（ 带宽和流量 ）， 并对主服务器响应命令请求的时间产生影响。</li><li>接收到 RDB 文件的从服务器需要载入主服务器发来的 RDB 文件， 并且在载入期间， 从服务器会因为阻塞而没办法处理命令请求。  </li></ul><p>每次主服务器改数据库之后都要传播该条命令</p><h3 id="新版复制功能"><a href="#新版复制功能" class="headerlink" title="新版复制功能"></a>新版复制功能</h3><p>使用PSYNC实现</p><ul><li>完整重同步:初始复制主服务器,与之前的SYNC没有什么不同</li><li>部分重同步:断线后重连复制,条件允许时直接将断开连接期间的写命令发给从服务器.</li></ul><p>重连之后从服务器发送PSYNC命令,主服务器向从服务器返回+CONTINUE回复,表示执行部分重同步,从服务器接受回复,准备执行部分重同步,主服务器发送断线期间的写命令,从服务器接受并执行,完成同步</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118101021620.png" alt="image-20211118101021620"></p><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从服务器都会维护复制偏移量,主服务器发送n数据,从服务器接受n数据,都会分别给自己的复制偏移量添加n.</p><p>如果master和slave的偏移量是相同的，那么主从数据处于一致的状态</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>主服务器维护的一个FIFO队列,固定默认1MB大小</p><p>当master向slave传播命令时，会将命令<strong>写入到复制积压缓冲区</strong>,复制积压缓冲区记录了最近向slave传播的命令；并且为每个字节记录了相应的复制偏移量</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118105510397.png" alt="image-20211118105510397"></p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118105606106.png" alt="image-20211118105606106"></p><p>当slave断线后重新连接master时，向master发送PSYNC命令会将自己的复制偏移量发送给master。</p><p>master会根据这个偏移量决定对slave执行<strong>部分同步</strong>还是<strong>完全同步；</strong></p><ul><li>slave的偏移量在复制积压缓冲区，执行部分同步 ；</li><li>slave的偏移量不在复制积压缓冲区，则执行完全同步；</li></ul><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>slave对master初次复制时，会保存master的运行id；</p><ul><li><p>当slave重新连接到master时，slave向master发送之前保存的mater run id；</p></li><li><p>如果slave保存的master run id和重新连接的master run id不一致，（换了master），则执行完全同步；</p></li></ul><p>相反，如果一致则尝试执行部分同步</p><h3 id="PSYNC执行过程"><a href="#PSYNC执行过程" class="headerlink" title="PSYNC执行过程"></a>PSYNC执行过程</h3><p><strong>PSYNC命令调用方式有两种：</strong></p><ol><li><p><strong><code>PSYNC ? -1</code> 全量复制</strong><br>当从服务没有复制过主服务器，或者从服务执行过<code>SLAVEOF NO ONE</code>命令（取消复制），那么从服务将发送<code>PSYNC ？-1</code>命令；</p></li><li><p><strong><code>PSYNC &lt;runid&gt; &lt;offset&gt; </code>部分复制</strong><br>从服务已经复制过主服务器，那么从服务将向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>， runid是主服务器的id，offset服务器当前的偏移量；</p><p>主服务器接受到<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令后，主服务会判断是否能“部分同步”，向从服务回复相应的命令；</p></li></ol><p><strong>主服务向从服务的三种回复：</strong></p><ol><li><strong><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code> 执行完全重同步；</strong></li><li><strong><code>+CONTINUE</code> 执行部分重同步；</strong></li><li><strong><code>-ERR</code> 不支持psync同步操作，从服务将发送sync命令到主服务器,执行完全重同步；</strong></li></ol><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118170432055.png" alt="image-20211118170432055"></p><p>注意图片有个情况没写出来</p><ol><li><p>设置主服务器的地址和端口</p><p>通过向从服务器发送SLAVE命令，可以让一个从服务器去复制一个主服务器</p><p>slaveof要做的主要是给“从服务”设置的“主服务”地址和端口，会保存到从服务器的<strong>masterhost</strong>和<strong>masterport</strong>属性中(<strong>replication.c/replicaofCommand</strong>)</p><p>slaveof是一个异步命令，完成设置后，会给客户端返回OK; 实际复制工作将在OK返回后真正开始执行；</p><p>执行<code>SLAVEOF 127.0.0.1&nbsp;6379</code>,设置好之后</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118204602440.png" alt="image-20211118204602440"></p></li><li><p>建立套接字连接</p><p>根据前一步保存的属性开始连接主服务器套接字(<strong>server.c/serverCron</strong> &gt; <strong>replication.c/replicationCron</strong> &gt; <strong>replication.c/connectWithMaster</strong>)</p><p>如果从服务和主服务器连接成功，从服务器会给这个套接字关联一个处理复制工作的文件处理器(<strong>replication.c/syncWithMaster</strong>),处理器完成后续工作,包括接受RDB文件,接受后续传来的写命令</p><p>主服务器在接受（ accept ) 从服务器的套接字连接之后， 将为该套接字创建相应的客户端状态， 并将从服务器看作是一个连接到主服务器的客户端来对待， 这时从服务器将同时具有服务器和客户端两个身份. </p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221239382.png" alt="image-20211118221239382"></p></li><li><p>发送ping命令</p><ul><li>检查套接字连接情况</li><li>检查主服务器是否能正常处理命令</li></ul><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221522707.png" alt="image-20211118221522707"></p></li><li><p>身份验证</p><ul><li>如果从服务器设置了 masterauth 选项， 那么进行身份验证。</li><li>如果从服务器没有设置 masterauth 选项， 那么不进行身份验证。</li></ul><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221720561.png" alt="image-20211118221720561"></p></li><li><p>发送端口信息</p><p>从服务将执行<code>REPLCONF listen-port &lt;port-number&gt;</code>，向主服务器发送从服务监听的端口号</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221853890.png" alt="image-20211118221853890"></p><p>主服务器接受到这个命令后，将从服务的端口号记录到客户端状态中的 slave_listening_port属性中</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221942590.png" alt="image-20211118221942590"></p></li><li><p>同步</p><p>从服务器向主服务器发送PSYNC命令</p><p>在同步操作执行之前， 只有从服务器是主服务器的客户端， 但是在执行同步操作之后， 他们互为客户端,因为主服务器也需要发送写命令给从服务器</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118223802314.png" alt="image-20211118223802314"></p></li><li><p>命令传播</p><p>写命令传播给从服务器</p></li></ol><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务默认每秒一次的频率向主服务器发送 <code>REPLCONF ACK &lt;replicaiotn_offset&gt; </code>(<code>replication_offset</code>是当前从服务器的复制偏移量)</p><p>心跳检测的代码入口位于：<code>server.c/serverCron &gt; replication.c/replicationCron &gt;  replication.c/replicationSendAck</code></p><h4 id="检测与主服务的网络连接状态"><a href="#检测与主服务的网络连接状态" class="headerlink" title="检测与主服务的网络连接状态"></a><strong>检测与主服务的网络连接状态</strong></h4><p>主从服务器通过发送和接受<code>REPLCONF</code> 命令检查网络连接是否正常；<br>如果从服务器超过一秒没有接收到从服务的<code>REPLCONF</code> 命令，主服务器就知道从服务连接出了问题； </p><p>主服务器对每个从服务器保存一个lag值记录上次收到心跳包的时间</p><h4 id="辅助实现min-slave选项"><a href="#辅助实现min-slave选项" class="headerlink" title="辅助实现min-slave选项"></a><strong>辅助实现min-slave选项</strong></h4><p>redis的<code>min-slave-to-write</code>和<code>min-salve-max-lag</code>可以防止主服务在不安全的情况下执行写命令；</p><p>例如 主服务的min-slave-to-write和min-salve-max-lag配置如下：<br>min-salve-max-lag 10<br>min-slave-to-write 3</p><p>那么从服务的数量少于3个，或者3个从服务的延时（lag）值大于等于10秒时，主服务都不能执行写命令；</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a><strong>检测命令丢失</strong></h4><p>如果因为网络原因，主服务传播给从服务的命令丢失了。那么当从服务向主服务器放松RELPCONF ACK 命令时，主服务会发觉 从服务 的复制偏移量少于主服务的复制偏移量；</p><p>然后主服务会将丢失的部分发送给从服务器(这里是没有断线的部分重同步,与断线之后的PSYNC区分)</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211119111122087.png" alt="image-20211119111122087"></p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211119111136634.png" alt="image-20211119111136634"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事件</title>
      <link href="/2022/01/27/redis-shi-jian/"/>
      <url>/2022/01/27/redis-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="redis事件"><a href="#redis事件" class="headerlink" title="redis事件"></a>redis事件</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//事件处理器状态(同时是时间处理器和文件处理器)</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>    <span class="token comment">//当前注册的最大描述符</span>    <span class="token keyword">int</span> maxfd<span class="token punctuation">;</span>   <span class="token comment">/* highest file descriptor currently registered */</span>    <span class="token comment">//当前追踪的最大描述符</span>    <span class="token keyword">int</span> setsize<span class="token punctuation">;</span> <span class="token comment">/* max number of file descriptors tracked */</span>    <span class="token comment">//时间事件的id,时间事件链表中记录了最大的id</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> timeEventNextId<span class="token punctuation">;</span>    <span class="token comment">//已注册的文件事件</span>    aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">/* Registered events */</span>    <span class="token comment">//已经就绪,执行过处理器的文件事件</span>    aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">/* Fired events */</span>    <span class="token comment">//时间事件</span>    aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span>    <span class="token comment">//事件处理器开关</span>    <span class="token keyword">int</span> stop<span class="token punctuation">;</span>    <span class="token comment">//多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>apidata<span class="token punctuation">;</span> <span class="token comment">/* This is used for polling API specific data */</span>    <span class="token comment">//处理事件之前要执行的函数</span>    aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span>    <span class="token comment">//处理事件之后要执行的函数</span>    aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span></code></pre><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>服务器通过套接字和客户端连接,文件事件是对于套接字操作的抽象,通信过程会产生相应文件事件,服务器监听处理这些事件</p><ul><li><strong>本身单线程运行,但是I/O多路复用监听多个套接字</strong></li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* File event structure * * 文件事件结构 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>    <span class="token comment">// 监听事件类型掩码，</span>    <span class="token comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span>    <span class="token comment">// 或者 AE_READABLE | AE_WRITABLE</span>    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">/* one of AE_(READABLE|WRITABLE) */</span>    <span class="token comment">// 读事件处理器</span>    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>    <span class="token comment">// 写事件处理器</span>    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>    <span class="token comment">// 多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span><span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span></code></pre><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul><li><p>套接字</p><ul><li>每当一个套接字准备好执行某项操作时,产生一个文件事件,一个服务器连接了多个套接字,可以产生多个文件事件</li><li>当套接字可读(客户端执行write或者close之后)或者有新的可应答套接字出现(新的connect建立)时,产生AE_READABLE事件;套接字变得可写(客户端执行read操作之后)时,产生AE_WRITABLE事件</li></ul></li><li><p>I/O多路复用程序</p><ul><li>负责监听多个套接字的上述两种事件,向文件事件分派器传送产生了事件的套接字</li><li>多个事件时先处理AE_READABLE事件,先读后写,多个套接字都有事件时按照一个队列传送,当上一个套接字的事件处理完毕之后再处理下一个套接字</li></ul></li><li><p>文件事件分派器</p><ul><li>根据传来的套接字调用相应的事件处理器</li></ul></li><li><p>事件处理器</p><ul><li>执行相关操作的函数</li></ul></li></ul><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><ul><li><p>函数aeCreateFileEvent</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 根据 mask 参数的值，监听 fd 文件的状态， * 当 fd 可用时，执行 proc 函数 * 将给定套接字的给定事件加入到I/O多路复用程序的监听范围 * 将事件和事件处理器关联 */</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        errno <span class="token operator">=</span> ERANGE<span class="token punctuation">;</span>        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 取出文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token comment">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-&gt;</span>mask <span class="token operator">|=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment">// 私有数据</span>    fe<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>    <span class="token comment">// 如果有需要，更新事件处理器的最大 fd</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">)</span>        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeDeleteFileEvent</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 将 fd 从 mask 指定的监听队列中删除 * i/o多路复用程序取消对给定套接字的给定事件的监听 * 取消事件和事件处理器之间的关联 */</span><span class="token keyword">void</span> <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 取出文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 未设置监听的事件类型，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* We want to always remove AE_BARRIER if set when AE_WRITABLE     * is removed. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> mask <span class="token operator">|=</span> AE_BARRIER<span class="token punctuation">;</span>    <span class="token comment">// 取消对给定 fd 的给定事件的监视</span>    <span class="token function">aeApiDelEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算新掩码</span>    fe<span class="token operator">-&gt;</span>mask <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Update the max fd */</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">!=</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeGetFileEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 获取给定 fd 正在监听的事件类型 * 返回正在监视的事件类型 */</span><span class="token keyword">int</span> <span class="token function">aeGetFileEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> fe<span class="token operator">-&gt;</span>mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeWait</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* Wait for milliseconds until the given file descriptor becomes * writable/readable/exception * 在给定毫秒内等待，直到 fd 变成可写、可读或异常 * 事件成功产生或者超时就返回 */</span><span class="token keyword">int</span> <span class="token function">aeWait</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> pfd<span class="token punctuation">;</span>    <span class="token keyword">int</span> retmask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfd<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLIN<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLOUT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> milliseconds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLOUT<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLERR<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLHUP<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">return</span> retmask<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeApiPoll</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*在指定时间内阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件当有至少一个事件产生或者超时返回*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tvp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>apidata<span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">,</span> j<span class="token punctuation">,</span> numevents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>rfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>wfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据select的retval决定之后的操作</span>    retval <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>                <span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//监听得到的事件类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_READABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">)</span><span class="token punctuation">)</span>                mask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_WRITABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">)</span><span class="token punctuation">)</span>                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> j<span class="token punctuation">;</span>            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> mask<span class="token punctuation">;</span>            numevents<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"aeApiPoll: select, %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> numevents<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeProcessEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 调用aeApiPoll等待事件产生,之后遍历所有产生的事件,处理所有已到达的时间事件，以及所有已就绪的文件事件 * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪， * 或者下个时间事件到达（如果有的话） * 根据flag值确定相应的处理步骤 * 函数的返回值为已处理事件的数量*/</span><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> numevents<span class="token punctuation">;</span>    <span class="token comment">/* Nothing to do? return ASAP */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_FILE_EVENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* Note that we want to call select() even if there are no     * file events to process as long as we want to process time     * events, in order to sleep until the next time event is ready     * to fire. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">,</span> <span class="token operator">*</span>tvp<span class="token punctuation">;</span>        <span class="token class-name">int64_t</span> usUntilTimer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 距今最近的时间事件还要多久才能达到,使用usUntilTimer保存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span>            usUntilTimer <span class="token operator">=</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//还没有到达</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>usUntilTimer <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> usUntilTimer <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">;</span>            tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> usUntilTimer <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//如果时间事件已经到达(到达间隔时间为负数),将已到达时间事件的到达时间间隔设置为0</span>            <span class="token comment">/* If we have to check for events but need to return             * ASAP because of AE_DONT_WAIT we need to set the timeout             * to zero */</span>            <span class="token comment">// 执行到这一步，说明没有时间事件即将到达</span>            <span class="token comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 设置文件事件不阻塞,将已到达时间事件的到达时间间隔设置为0</span>                tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">/* Otherwise we can block */</span>                <span class="token comment">// 文件事件可以阻塞直到有事件到达为止,wait时间设置为无穷</span>                tvp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* wait forever */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Call the multiplexing API, will return only on timeout or when         * some event fires. */</span>        <span class="token comment">// 处理文件事件，阻塞时间由 tvp 决定</span>        numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* After sleep callback. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>aftersleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-&gt;</span><span class="token function">aftersleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//从已就绪数组中获取事件</span>            <span class="token keyword">int</span> fd <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> mask <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>            <span class="token keyword">int</span> fired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Number of events fired for current fd. */</span>            <span class="token keyword">int</span> invert <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_BARRIER<span class="token punctuation">;</span>            <span class="token comment">//读取事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//确保读/写事件只能执行其中一个</span>                fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                fired<span class="token operator">++</span><span class="token punctuation">;</span>                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>            <span class="token punctuation">}</span>            <span class="token comment">/* Fire the writable event. */</span>            <span class="token comment">//写事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                    fired<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">/* If we have to invert the call, fire the readable event now             * after the writable one. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>invert<span class="token punctuation">)</span> <span class="token punctuation">{</span>                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                    fired<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            processed<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Check time events */</span>    <span class="token comment">//执行时间事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>        processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> processed<span class="token punctuation">;</span> <span class="token comment">/* return the number of processed file/time events */</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>实现不同的网络通信需求,主要是连接应答处理器,命令请求处理器,命令回复处理器</p><ul><li><p>连接应答处理器</p><ul><li><p>函数acceptTcpHandler对连接服务器监听套接字的客户端进行应答</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建一个TCP连接</span><span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cport<span class="token punctuation">,</span> cfd<span class="token punctuation">,</span> max <span class="token operator">=</span> MAX_ACCEPTS_PER_CALL<span class="token punctuation">;</span>    <span class="token keyword">char</span> cip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//accept客户端连接</span>        cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cport<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//TCP连接函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cfd <span class="token operator">==</span> ANET_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>                    <span class="token string">"Accepting client connection: %s"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>neterr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Accepted %s:%d"</span><span class="token punctuation">,</span> cip<span class="token punctuation">,</span> cport<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 为客户端创建客户端状态（redisClient）</span>        <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span><span class="token function">connCreateAcceptedSocket</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>cip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>redis进行初始化时,将处理器与套接字的AE_READABLE事件连接起来,当由客户端使用sys/socket.h/connect函数连接服务器监听套接字时,套接字产生AE_READABLE事件,引发连接应答处理器执行,并执行相应的套接字应答操作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">连接监听套接字</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:服务器监听套接字产生的AE_READABLE事件,执行连接应答处理器]</span></code></pre></li></ul></li><li><p>命令请求处理器</p><ul><li><p>函数readQueryFromClient从套接字中读入客户端发送的命令请求内容</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 读取客户端的查询缓冲区内容 */</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nread<span class="token punctuation">,</span> big_arg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">;</span>    <span class="token comment">/* Check if we want to read from the client later when exiting from     * the event loop. This is the case if threaded I/O is enabled. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* Update total number of reads on server */</span>    <span class="token comment">//更新server的读入处理计数器</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_reads_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    readlen <span class="token operator">=</span> PROTO_IOBUF_LEN<span class="token punctuation">;</span>    <span class="token comment">/* If this is a multi bulk request, and we are processing a bulk reply     * that is large enough, try to maximize the probability that the query     * buffer contains exactly the SDS string representing the object, even     * at the risk of requiring more read(2) calls. This way the function     * processMultiBulkBuffer() can avoid copying buffers to create the     * Redis Object representing the argument. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_MULTIBULK <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>multibulklen <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">&gt;=</span> PROTO_MBULK_BIG_ARG<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">ssize_t</span> remaining <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bulklen<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>        big_arg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">/* Note that the 'remaining' variable may be zero in some edge case,         * for example once we resume a blocked client after CLIENT PAUSE. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> readlen <span class="token operator">=</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 获取查询缓冲区当前内容的长度</span>    <span class="token comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span>    <span class="token comment">// 这些滞留内容也许不能完整构成一个符合协议的命令</span>    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//为查询缓冲区分配空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>big_arg <span class="token operator">||</span> <span class="token function">sdsalloc</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> PROTO_IOBUF_LEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* When reading a BIG_ARG we won't be reading more than that one arg         * into the query buffer, so we don't need to pre-allocate more than we         * need, so using the non-greedy growing. For an initial allocation of         * the query buffer, we also don't wanna use the greedy growth, in order         * to avoid collision with the RESIZE_THRESHOLD mechanism. */</span>        <span class="token comment">//太长的指令参数只读入一个参数,查询缓冲区不需要多余分配空间,不使用贪心分配空间</span>        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomForNonGreedy</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Read as much as possible from the socket to save read(2) system calls. */</span>        readlen <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//读入内容到查询缓存</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读入出错时</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token operator">==</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Reading from client: %s"</span><span class="token punctuation">,</span><span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment">//遇到EOF</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>verbosity <span class="token operator">&lt;=</span> LL_VERBOSE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sds info <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Client closed connection %s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Append the query buffer to the pending (not applied) buffer         * of the master. We'll use this buffer later in order to have a         * copy of the string applied by the last command executed. */</span>        <span class="token comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span>        <span class="token comment">// 并将 '\0' 正确地放到内容的最后</span>        c<span class="token operator">-&gt;</span>pending_querybuf <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>pending_querybuf<span class="token punctuation">,</span>                                        c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sdsIncrLen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">&lt;</span> qblen<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">=</span> qblen<span class="token punctuation">;</span>    <span class="token comment">// 记录服务器和客户端最后一次互动的时间</span>    c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 如果客户端是 master 的话，更新它的复制偏移量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>read_reploff <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_input_bytes<span class="token punctuation">,</span> nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span>    <span class="token comment">// 清空缓冲区并释放客户端</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>client_max_querybuf_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sds ci <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bytes <span class="token operator">=</span> <span class="token function">sdscatrepr</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span><span class="token punctuation">,</span> ci<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* There is more data in the client input buffer, continue parsing it     * in case to check if there is a full command to execute. */</span>    <span class="token comment">// 从查询缓存重读取内容，创建参数，并执行命令</span>    <span class="token comment">// 函数会执行到缓存中的所有内容都被处理完为止</span>     <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当一个客户端通过连接应答处理器连接到服务器之后,客户端套接字的AE_READABLE事件和命令请求处理器相关联,当客户端向服务器发送命令请求时,产生AE_READABLE事件引发处理器执行,执行相关套接字读入工作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令请求</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:客户端套接字产生AE_READABLE事件,执行命令请求处理器]</span></code></pre></li></ul></li><li><p>命令回复处理器</p><ul><li><p>函数sendReplyToClient将服务器执行相关命令得到的命令回复通过套接字返回给客户端</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 负责传送命令回复的写处理器 */</span> <span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//具体实现</span><span class="token punctuation">}</span></code></pre><p>具体实现的函数如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* Update total number of writes on server */</span>    <span class="token comment">//更新写回复计数器</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_writes_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> objlen<span class="token punctuation">;</span>    clientReplyBlock <span class="token operator">*</span>o<span class="token punctuation">;</span>    <span class="token comment">//一直循环直到回复缓冲区为空</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bufpos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 写入内容到套接字</span>            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时,</span>            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上。</span>            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>buf<span class="token operator">+</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>bufpos<span class="token operator">-</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//出错时跳出循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//写入之后更新写入计数器变量</span>            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            <span class="token comment">/* If the buffer was sent, set bufpos to zero to continue with             * the remainder of the reply. */</span>            <span class="token comment">// 如果缓冲区中的内容已经全部写入完毕</span>            <span class="token comment">// 那么清空客户端的两个计数器变量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> c<span class="token operator">-&gt;</span>bufpos<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>bufpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//取出位于链表最前面的对象</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            objlen <span class="token operator">=</span> o<span class="token operator">-&gt;</span>used<span class="token punctuation">;</span>            <span class="token comment">//空对象不做处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>objlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 写入内容到套接字</span>            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时，</span>            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上</span>            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> o<span class="token operator">-&gt;</span>buf <span class="token operator">+</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//写入出错时跳出</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//成功写入时更新计数器变量</span>            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            <span class="token comment">/* If we fully sent the object on head go to the next one */</span>            <span class="token comment">// 如果缓冲区内容全部写入完毕，那么删除已写入完毕的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> objlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">/* If there are no longer objects in the list, we expect                 * the count of reply bytes to be exactly zero. */</span>                <span class="token comment">//list之中没有对象,reply的字节数设置为0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token function">serverAssert</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 为了避免一个非常大的回复独占服务器，         * 当写入的总数量大于 REDIS_MAX_WRITE_PER_EVENT ，         * 临时中断写入，将处理时间让给其他客户端，         * 剩余的内容等下次写入就绪再继续写入         * 不过，如果服务器的内存占用已经超过了限制，         * 那么为了将回复缓冲区中的内容尽快写入给客户端，         * 然后释放回复缓冲区的空间来回收内存，         * 这时即使写入量超过了 REDIS_MAX_WRITE_PER_EVENT ，         * 程序也继续进行写入*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> NET_MAX_WRITES_PER_EVENT <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>             <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_output_bytes<span class="token punctuation">,</span> totwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//写入出错检测</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span> <span class="token operator">!=</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span>                <span class="token string">"Error writing to client: %s"</span><span class="token punctuation">,</span> <span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* For clients representing masters we don't count sending data         * as an interaction, since we always send REPLCONF ACK commands         * that take some time to just fill the socket output buffer.         * We just rely on data / pings received for timeout detection. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span><span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* Note that writeToClient() is called in a threaded way, but         * adDeleteFileEvent() is not thread safe: however writeToClient()         * is always called with handler_installed set to 0 from threads         * so we are fine. */</span><span class="token comment">//前面应该是aeDeleteFileEvent()</span>        <span class="token comment">//不能直接删除write handler,因为本身调用就是在线程之中了,aeDeleteFileEvent()线程不安全</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>handler_installed<span class="token punctuation">)</span> <span class="token function">connSetWriteHandler</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Close connection after entire reply has been sent. */</span>        <span class="token comment">// 如果指定了写入之后关闭客户端 FLAG ，那么关闭客户端</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当访问有命令回复需要传送给客户端的时候将客户端套接字的AE_WRITABLE事件和命令回复处理器相关联,当客户端准备好接受服务器传回的命令回复时,产生AE_WRITABLE事件引发处理器执行,执行相关套接字写入工作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> RL  a<span class="token text string">[服务器:客户端套接字产生AE_WRITABLE事件,执行命令回复处理器]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令回复</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">((客户端))</span></code></pre><p>回复发送之后就接触命令回复处理器和客户端套接字AE_WRITABLE事件之间的关联</p></li></ul></li><li><p>全过程:</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRa<span class="token text string">[客户端]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送连接请求,服务器执行连接应答处理器</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器]</span>a<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送命令请求,服务器执行命令请求处理器</span><span class="token arrow operator">--&gt;</span></span>bb<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">服务器向客户端发送命令回复,服务器执行命令回复处理器</span><span class="token arrow operator">--&gt;</span></span>a</code></pre></li></ul><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>(如serverCron函数)在给定时间点执行,时间事件就是对定时操作的抽象</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定时事件</li><li>周期性事件</li></ul><h4 id="时间事件的结构"><a href="#时间事件的结构" class="headerlink" title="时间事件的结构"></a>时间事件的结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//时间事件的结构,种类包括定时事件和周期性事件</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>    <span class="token comment">//事件的唯一标识符,从小到大表示从旧到新</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span>    <span class="token comment">//事件的到达时间</span>    monotime when<span class="token punctuation">;</span>    <span class="token comment">//时间事件处理器,一个函数</span>    <span class="token comment">//时间事件的种类决定于这个函数的返回值</span>    <span class="token comment">//AE_NOMORE表示定时事件,到达一次之后被删除并且不会再次到达</span>    <span class="token comment">//返回其他整数n表示周期性事件,服务器对事件的when属性进行更新,使之n毫秒之后再次到达</span>    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>    <span class="token comment">//事件释放函数</span>    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>    <span class="token comment">//多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>    <span class="token comment">//指向上一个和下一个时间事件结构,形成链表</span>    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token comment">//防止在迭代过程中周期性事件被释放</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">/* refcount to prevent timer events from being     * freed in recursive time event calls. */</span><span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span></code></pre><p>服务器将时间事件都放在一个链表中,每当时间事件处理器执行时遍历链表,对所有已到达的时间事件调用相应的事件处理器.</p><p>新事件放在链表头部,所以链表的头部事件id较大,无序是指when的无序</p><h4 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h4><ul><li><p>函数aeCreateTimeEvent将一个新的时间事件加入到服务器,在当前时间的milliseconds毫秒之后到达</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建事件计数器</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">,</span>        aeTimeProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span>        aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//更新时间计数器</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> id <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//创建时间事件结构</span>    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>    te <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token comment">//设置id</span>    te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token comment">//设置事件</span>    te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> milliseconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token comment">//设置事件处理器</span>    te<span class="token operator">-&gt;</span>timeProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>finalizerProc <span class="token operator">=</span> finalizerProc<span class="token punctuation">;</span>    <span class="token comment">//私有数据</span>    te<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>    <span class="token comment">//将事件插入链表</span>    te<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>next <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>refcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>        te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token punctuation">;</span>    eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token punctuation">;</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeDeleteTimeEvent删除给定id的时间事件</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//删除给定的时间事件</span><span class="token keyword">int</span> <span class="token function">aeDeleteTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    <span class="token comment">//遍历链表</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//发现目标事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//修改id之后,在processTimeEvents的时候删除</span>            te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>            <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span> <span class="token comment">/* NO event with the specified ID found  */</span><span class="token punctuation">}</span></code></pre></li><li><p>函数usUntilEarliestTimer返回到达时间距离当前时间最近的时间事件到达耗时</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//返回距离第一个时间事件触发的毫秒数</span><span class="token comment">//需要遍历链表,定时一般来说时间事件不多,遍历时间很短</span><span class="token keyword">static</span> <span class="token class-name">int64_t</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    aeTimeEvent <span class="token operator">*</span>earliest <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>earliest <span class="token operator">||</span> te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span>            earliest <span class="token operator">=</span> te<span class="token punctuation">;</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>now <span class="token operator">&gt;=</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> earliest<span class="token operator">-&gt;</span>when <span class="token operator">-</span> now<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数processTimeEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//处理到达的时间事件</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> maxId<span class="token punctuation">;</span>    <span class="token comment">//遍历链表执行已到达的事件</span>    te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span><span class="token comment">//指向链表头部</span>    maxId <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>        <span class="token comment">/* Remove events scheduled for deletion. */</span>        <span class="token comment">//之前id已经设置为AE_DELETED_EVENT_ID的事件需要删除掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> AE_DELETED_EVENT_ID<span class="token punctuation">)</span> <span class="token punctuation">{</span>            aeTimeEvent <span class="token operator">*</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token comment">/* If a reference exists for this timer event,             * don't free it. This is currently incremented             * for recursive timerProc calls */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>refcount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//有迭代子程序调用的事件不删除</span>                te <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//修改相关的指针</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>prev<span class="token punctuation">)</span>                te<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>                te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>            <span class="token comment">//执行清理处理器</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>finalizerProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>                te<span class="token operator">-&gt;</span><span class="token function">finalizerProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>                now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//释放要删除的时间事件</span>            <span class="token function">zfree</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">;</span>            te <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Make sure we don't process time events created by time events in         * this iteration. Note that this check is currently useless: we always         * add new timers on the head, however if we change the implementation         * detail, this check may be useful again: we keep it here for future         * defense. */</span>        <span class="token comment">//无效事件跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">&gt;</span> maxId<span class="token punctuation">)</span> <span class="token punctuation">{</span>            te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//当前时间大于等于时间事件的when,事件已到达,执行这个事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;=</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> retval<span class="token punctuation">;</span>            id <span class="token operator">=</span> te<span class="token operator">-&gt;</span>id<span class="token punctuation">;</span>            te<span class="token operator">-&gt;</span>refcount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//执行对应的文件处理器,记录返回值</span>            retval <span class="token operator">=</span> te<span class="token operator">-&gt;</span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>            te<span class="token operator">-&gt;</span>refcount<span class="token operator">--</span><span class="token punctuation">;</span>            processed<span class="token operator">++</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//区分是否是定时事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> AE_NOMORE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//retval毫秒之后再次执行</span>                te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> now <span class="token operator">+</span> retval <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">//直接删除</span>                te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> processed<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>serverCron就是非常典型的周期性时间事件,服务器只要在运行就要周期性运行这个函数</p></li></ul><h2 id="redis运行流程"><a href="#redis运行流程" class="headerlink" title="redis运行流程"></a>redis运行流程</h2><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRid1<span class="token text string">[启动服务器]</span><span class="token arrow operator">--&gt;</span>id7<span class="token text string">[配置和加载初始化]</span><span class="token arrow operator">--&gt;</span>id8<span class="token text string">[创建事件循环]</span><span class="token arrow operator">--&gt;</span>id10<span class="token text string">[开始socket监听]</span><span class="token arrow operator">--&gt;</span>id9<span class="token text string">[向循环事件中注册serverCron]</span><span class="token keyword">subgraph</span> 循环id9<span class="token arrow operator">--&gt;</span>id2<span class="token text string">{是否关闭服务器}</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">否</span><span class="token arrow operator">--&gt;</span></span>id4<span class="token text string">[等待文件事件产生]</span>id4<span class="token arrow operator">--&gt;</span>id5<span class="token text string">[处理产生的文件事件]</span><span class="token arrow operator">--&gt;</span>id6<span class="token text string">[处理已到达的时间事件]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">开始新的事件循环</span><span class="token arrow operator">--&gt;</span></span>id2<span class="token keyword">end</span>id2<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">是</span><span class="token arrow operator">--&gt;</span></span>id3<span class="token text string">[关闭服务器]</span></code></pre><p><img src="/2022/01/27/redis-shi-jian/main_start_event_loop-3251881.png" alt="main_start_event_loop"></p><p>两张图的方式都差不多,展示了整个redis的过程</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis单机数据库以及持久化</title>
      <link href="/2022/01/27/redis-dan-ji-shu-ju-ku/"/>
      <url>/2022/01/27/redis-dan-ji-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="单机数据库实现和持久化"><a href="#单机数据库实现和持久化" class="headerlink" title="单机数据库实现和持久化"></a>单机数据库实现和持久化</h1><h2 id="数据库细节实现"><a href="#数据库细节实现" class="headerlink" title="数据库细节实现"></a>数据库细节实现</h2><ul><li><p>数据库的数据结构</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token comment">// 数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>                 <span class="token comment">/* The keyspace for this DB */</span>    <span class="token comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>              <span class="token comment">/* Timeout of keys with a timeout set */</span>    <span class="token comment">// 正处于阻塞状态的键</span>    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>        <span class="token comment">/* Keys with clients waiting for data (BLPOP)*/</span>    <span class="token comment">// 可以解除阻塞的键</span>    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>           <span class="token comment">/* Blocked keys that received a PUSH */</span>    <span class="token comment">// 正在被 WATCH 命令监视的键</span>    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>         <span class="token comment">/* WATCHED keys for MULTI/EXEC CAS */</span>    <span class="token comment">//数据库编码</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                     <span class="token comment">/* Database ID */</span>    <span class="token comment">// 数据库的键的平均 TTL ，统计信息</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>          <span class="token comment">/* Average TTL, just for stats */</span>    <span class="token comment">//过期指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> expires_cursor<span class="token punctuation">;</span> <span class="token comment">/* Cursor of the active expire cycle. */</span>    <span class="token comment">//即将整理的键名称,用一个list保存</span>    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>         <span class="token comment">/* List of key names to attempt to defrag one by one, gradually. */</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></code></pre></li></ul></li></ul><ul><li>Hash table type implementation<ul><li>tryResizeHashTables()用于缩小字典体积：如果字典的使用率比 HASHTABLE_MIN_MINFILL 常量要低，那么通过缩小字典的体积来节约内存,htNeedsResize()就是比较这两个大小的函数,在有孩子进程的时候不会进行resize</li><li>服务器在对数据库执行增删改查命令时会对数据库进行渐进式 rehash ,但如果服务器长期没有执行命令的话，数据库字典的 rehash 就可能一直没办法完成,为了防止出现这种情况，incrementallyRehash()主动 rehash ,执行了rehash之后返回1,否则返回0</li></ul></li></ul><h3 id="过期功能实现"><a href="#过期功能实现" class="headerlink" title="过期功能实现"></a>过期功能实现</h3><ul><li><p>设置生存和过期时间</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211110165635236.png" alt="image-20211110165635236"></p></li><li><p>带有生存和过期时间的数据库</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211110165743757.png" alt="image-20211110165743757"></p><p>添加过期时间就是在过期字典中添加项目,移除过期时间就是在过期字典中删除对应的项目,键过期时间和当前时间做差就可以计算出生存时间.</p></li><li><p>过期键删除:</p><ul><li><p>惰性删除</p><ul><li><p>db.c的expireIfNeeded()函数对于所有的输入键检查是否过期,过期的键直接删除</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111154024925.png" alt="image-20211111154024925"></p><ul><li>定期删除<ul><li>由expire.c中的activeExpireCycle()函数实现定期删除,当服务器定期执行server.c的serverCron()函数时,就会调用,在expire字典中随机检查一部分键的过期时间,并且删除其中的过期键.</li></ul></li></ul></li><li><p>RDB对于过期键处理</p><ul><li>生成时过期键不加入RDB文件中</li><li>主服务器载入时检查键是否过期,过期键不加入数据库;从服务器不检查,但是会和主服务器同步数据,同步的时候也会清除过期键</li></ul></li><li><p>AOF对于过期键处理</p><ul><li><p>写入时如果键过期但没有删除,不会影响,当(惰性或者定期)删除的时候追加一条DEL</p><ul><li><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111214557807.png" alt="image-20211111214557807"></li></ul></li><li><p>重写入的时候检查键是否过期,过期键不加入数据库</p></li></ul></li><li><p>复制对于过期键处理</p><ul><li><p>主服务器处理,之后对从服务器发送DEL,从服务器对于过期键不做处理</p></li><li><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111220239415.png" alt="image-20211111220239415"></p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111220255616.png" alt="image-20211111220255616"></p></li></ul></li></ul></li></ul><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><ul><li><p>可以监视对键的操作情况,或者是监视某个指令的使用情况</p></li><li><p>由notify.c/notifyKeyspaceEvent()函数实现:</p></li></ul></li></ul><pre class="language-c#" data-language="c#"><code class="language-c#">/* The API provided to the rest of the Redis core is a simple function: *实现了发送数据库通知的功能 * notifyKeyspaceEvent(int type, char *event, robj *key, int dbid); * * 'type' is the notification class we define in `server.h`. * type是当前想要发送的通知的类型,根据这个判断通知发送与否,提前在server.h中定义过种类 * 'event' is a C string representing the event name. *  event 参数是一个字符串表示的事件名 * 'key' is a Redis object representing the key name. * key 参数是一个 Redis 对象表示的键名,是产生事件的键 * 'dbid' is the database ID where the key lives. * dbid 参数为键所在(产生事件)的数据库   * 每当一个redis命令需要发送数据库通知的时候,都会调用此函数,向函数传递命令的相关信息*/void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {    sds chan;    robj *chanobj, *eventobj;    int len = -1;    char buf[24];    /* If any modules are interested in events, notify the module system now.     * This bypasses the notifications configuration, but the module engine     * will only call event subscribers if the event type matches the types     * they are interested in. */     moduleNotifyKeyspaceEvent(type, event, key, dbid);    /* If notifications for this class of events are off, return ASAP.     如果给定通知不是服务器允许发送的通知,直接返回*/    if (!(server.notify_keyspace_events &amp; type)) return;    eventobj = createStringObject(event,strlen(event));    /* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */    //发送键空间通知    if (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) {        chan = sdsnewlen("__keyspace@",11);        len = ll2string(buf,sizeof(buf),dbid);        chan = sdscatlen(chan, buf, len);        chan = sdscatlen(chan, "__:", 3);        chan = sdscatsds(chan, key-&gt;ptr);        chanobj = createObject(OBJ_STRING, chan);        pubsubPublishMessage(chanobj, eventobj);//通过publish发送通知        decrRefCount(chanobj);    }    /* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */    //发送键时间通知    if (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) {        chan = sdsnewlen("__keyevent@",11);        //初始化为-1,加入前面发送键空间通知的时候计算过了就不会是-1,少计算一次        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);        chan = sdscatlen(chan, buf, len);        chan = sdscatlen(chan, "__:", 3);        chan = sdscatsds(chan, eventobj-&gt;ptr);        chanobj = createObject(OBJ_STRING, chan);        pubsubPublishMessage(chanobj, key);        decrRefCount(chanobj);    }    decrRefCount(eventobj);}</code></pre><p>​    </p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>redis是内存数据库,RDB持久化将数据库状态保存到磁盘里面,避免数据意外丢失</p><p>RDB文件时压缩的二进制文件,可以用这个文件恢复数据库状态,主要使用save和bgsave实现</p><h3 id="创建和载入"><a href="#创建和载入" class="headerlink" title="创建和载入"></a>创建和载入</h3><ul><li>save创建RDB文件,但是会阻塞服务器;bgsave生成一个子进程,专门负责生成RDB文件</li><li>只要有RDB文件在,就会自动载入RDB文件(如果开启了AOF持久化功能,会优先使用AOF文件还原数据库)</li><li>bgsave执行期间不能执行save,bgsave(防止竞争条件);也不能执行bgrewriteaof,因为都会有大量的磁盘写入</li></ul><h3 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h3><h4 id="设置自动保存条件"><a href="#设置自动保存条件" class="headerlink" title="设置自动保存条件"></a>设置自动保存条件</h4><p>设定自动保存的条件,达到条件时自动运行bgsave</p><p>条件保存在redisServer的saveparams属性中</p><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h4><ul><li>dirty计数器记录上次成功执行save或者bgsave之后服务器对数据库进行修改的次数</li><li>lastsave记录了上次成功save的时间</li></ul><h4 id="检查保存条件"><a href="#检查保存条件" class="headerlink" title="检查保存条件"></a>检查保存条件</h4><p>serverCron函数默认没100ms就要执行一次,维护当前运行的数据库,同时也检查了自动保存条件是否满足,只要有一个条件满足了就要执行bgsave</p><h2 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h2><p>通过保存所有的写命令记录数据库状态</p><p>写命令执行之后加到redisServer的aof_buf缓冲区末尾,在处理事件循环的时候决定是否将缓冲区的值写入到AOF文件</p><p>数据还原的时候先创建不带网络连接的伪客户端,直接使用来自AOF文件中的命令,挨个执行,最终执行完毕就是数据库的状态</p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><ul><li><p>直接读取当前状态,对于每个键直接使用add指令读取最后的状态作为一个add添加进去.</p></li><li><p>开始执行重写之后可能会继续执行指令,对于数据库进行修改,因此建立了AOF重写缓冲区,新指令同时同步到AOF缓冲区和AOF重写缓冲区</p></li><li><p>完成重写之后直接覆盖原来的AOF文件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2022/01/27/redis-ji-chu/"/>
      <url>/2022/01/27/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><ul><li>字符串长度保存在本体中,获取需要常数时间复杂度</li><li>header包含的部分:<ul><li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li><li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li><li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。</li></ul></li><li>缓冲区不会溢出</li><li>减少修改时的内存重分配次数<ul><li>空间预分配</li><li>alloca记录分配的总空间,惰性空间释放</li></ul></li><li>除了自己加上的头部字段,其他和c函数一样,兼容相关函数</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>双向链表</li><li>无环,头指针的prev,尾指针的next都指向null</li><li>自带指向头指针和尾指针的指针</li><li>链表具有链表长度计数器,标识长度</li><li>void *可以保存不同类型的值</li></ul><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>基于哈希表实现,采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子超过预定值时自动扩展内存，引发重哈希,并且在重哈希的过程中,每次增删改查推进一步重哈希,避免重哈希期间单个请求的响应时间剧烈增加.</p><p>实现增量式重哈希，dict的数据结构里包含两个哈希表。在重哈希期间，数据从第一个哈希表向第二个哈希表迁移</p><ul><li><p>hash table结构:</p><ul><li>一个dictEntry指针数组（table）。key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li><li>size：标识dictEntry指针数组的长度。它总是2的指数。</li><li>sizemask：用于将哈希值映射到table的位置索引。它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。</li><li>used：记录dict中现有的数据个数。它与size的比值就是装载因子（load factor）。这个比值越大，哈希值冲突概率越高。</li></ul></li><li><p>单个dictentry结构:</p><ul><li>```c<br>typedef struct dictEntry {<pre><code>void *key;//键union {    void *val;    uint64_t u64;    int64_t s64;    double d;} v;//值struct dictEntry *next;     /* 具有相同的hash值,先通过链表链接起来Next entry in the same hash bucket. */void *metadata[];           /* An arbitrary number of bytes (starting at a                             * pointer-aligned address) of size as returned                             * by dictType's dictEntryMetadataBytes(). */</code></pre>} dictEntry;<pre class="language-none"><code class="language-none">    - dict本身结构:  ```c  //字典本身  struct dict {      dictType *type;//类型函数      /*dictEntry指针数组（table）。      key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。      如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。      只有在重哈希的过程中，ht_table[0]和ht_table[1]才都有效。      而在平常情况下，只有ht_table[0]有效，ht_table[1]里面没有任何数据。*/      dictEntry **ht_table[2];//hash表      /*记录dict中现有的数据个数。      它与size的比值就是装载因子（load factor）。      这个比值越大，哈希值冲突概率越高。*/      unsigned long ht_used[2];      // rehash 索引      // 当 rehash 不在进行时，值为 -1,它的值记录了当前重哈希进行到哪一步了      long rehashidx; /* rehashing not in progress if rehashidx == -1 */        /* Keep small vars at end for optimal (minimal) struct padding */      /* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */      int16_t pauserehash; //大于0表示rehash计算停止,小于0编码错误      signed char ht_size_exp[2]; /* 记录大小的次方,exponent of size. (size = 1&lt;&lt;exp) */  };</code></pre></li></ul></li><li><p>rehash过程:</p><ul><li>大小选择:<ul><li>扩展时第二个hash表的大小是大于等于第一个的used*2的第一个$2^n$</li><li>收缩时第二个hash表的大小是大于等于第一个的used的第一个$2^n$</li></ul></li><li>rehash的时候重新计算键的哈希值和索引值</li><li>所有键值对rehash结束之后就直接把新的hash表当作原来的hash表</li><li>rehash进行时,每次增删改查都会顺带把第一个哈希表上面相应rehashidx索引上面的所有键值对rehash到第二个表上,rehash完成之后将rehashidx值增加一</li><li>当rehash完成之后,rehashidx的值设置成-1</li></ul></li></ul><h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><ul><li><p>基本结构:</p><ul><li>```c<br>typedef struct zskiplistNode {<pre><code>//zadd命令在将数据插入到skiplist里面之前先进行了解码，所以存储的一定是一个sds//为了方便在查找的时候对数据进行字典序的比较，//而且，skiplist里的value部分是数字的可能性也比较小,不是很方便压缩sds ele;double score;//指向链表前一个节点的指针（前向指针）//每个节点只有1个前向指针(没有依靠level分开)，所以只有第1层链表是一个双向链表struct zskiplistNode *backward;//存放指向各层链表后一个节点的指针（后向指针）//是一个柔性数组,占用内存不在zskiplistNode结构里面，需要插入节点的时候单独为它分配//所以skiplist的每个节点所包含的指针数目是不固定的struct zskiplistLevel {    //每层对应1个后向指针，用forward字段表示    struct zskiplistNode *forward;    //表示当前的指针跨越了多少个节点,用于计算元素排名    unsigned long span;} level[];</code></pre>} zskiplistNode;<pre class="language-none"><code class="language-none">- ```c  //真正的skiplist结构  typedef struct zskiplist {      struct zskiplistNode *header, *tail;      unsigned long length;//链表长度,头指针为空,不算在计数中      int level;//总层数  } zskiplist;</code></pre></li></ul></li><li><p>层数随机决定(1-32,幂次随机算法)</p></li><li><p>分值可以相同,但是对应成员必须不一样</p></li></ul><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><ul><li><p>不会出现重复元素</p></li><li><p>结构:</p><ul><li>```c<br>//由整数组成的有序集合,便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合<br>typedef struct intset {<pre><code>//整个统一的数据编码，表示intset中的每个数据元素用几个字节来存储//intset中存储的整数最多只能占用64bit//随着数据添加,可能改变数据编码,比如一些比较大的整数uint32_t encoding;//inset中的元素个数uint32_t length;//一个柔性数组,长度等于encoding * length,用于表达偏移量//contents需要单独为其分配空间，这部分内存不包含在intset结构当中int8_t contents[];</code></pre>} intset;<pre class="language-none"><code class="language-none">- 当原来的encoding大小不够新的数据存储时,需要升级数据编码  - 先扩充整个集合底层数组大小,分配新元素空间  - 原来的数据类型转换  - 添加新元素(一般来说新元素都在开头或者末尾位置)- 有点像数组的排列,中间插入元素需要整个向后移动,修改代价比较高### ziplist- 列表键只包含少量列表键,值的储存是变长的- 将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存- 结构:  - 源代码：        ```c    typedef struct {        /* When string is used, it is provided with the length (slen). */        unsigned char *sval;        unsigned int slen;        /* When integer is used, 'sval' is NULL, and lval holds the value. */        long long lval;    } ziplistEntry;    //ziplist的数据类型，没有用自定义的struct之类的来表达，    //而就是简单的unsigned char *。    //这是因为ziplist本质上就是一块连续内存，    //内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</code></pre></li><li>zlentry结构：<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* We use this function to receive information about a ziplist entry. * Note that this is not how the data is actually encoded, is just what we * get filled by a function in order to operate more easily. */</span><span class="token comment">//每一个entry的格式</span><span class="token comment">//记录长度是为了方便指针运算确定偏移量</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">/* Bytes used to encode the previous entry len*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">/* Previous entry len. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>        <span class="token comment">/* Bytes used to encode this entry type/len.                                    For example strings have a 1, 2 or 5 bytes                                    header. Integers always use a single byte.*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token comment">/* Bytes used to represent the actual entry.                                    For strings this is just the string length                                    while for integers it is 1, 2, 3, 4, 8 or                                    0 (for 4 bit immediate) depending on the                                    number range. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">/* prevrawlensize + lensize. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on                                    the entry encoding. However for 4 bits                                    immediate integers this can assume a range                                    of values and must be range-checked. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>            <span class="token comment">/* Pointer to the very start of the entry, that                                    is, this points to prev-entry-len field. */</span><span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>添加/删除节点的时候很可能出现连锁更新</p></li></ul><h2 id="robj-server-h"><a href="#robj-server-h" class="headerlink" title="robj(server.h)"></a>robj(server.h)</h2><p>对象的类型一般是指value的类型,和key类型无关(key一般都是string)</p><ul><li><p>作用:</p><ul><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul></li><li><p>结构:</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>    <span class="token comment">//对象的数据类型</span>    <span class="token comment">//可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，</span>    <span class="token comment">//分别对应Redis对外暴露的5种数据结构</span>    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">//对象的内部表示方式（也可以称为编码）</span>    <span class="token comment">//可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量</span>    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">//lru算法记录使用的数据</span>    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* LRU time (relative to global lru_clock) or                            * LFU data (least significant 8 bits frequency                            * and most significant 16 bits access time). */</span>    <span class="token comment">//引用计数,允许robj在一定情况下被共享</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment">//数据指针,指向真正的数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">}</span> robj<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>string对象:</p><ul><li>接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象</li><li>然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式</li></ul></li><li><p>list对象</p><ul><li>一般使用ziplist</li></ul></li><li><p>哈希对象</p><ul><li>使用ziplist或者hashtable</li><li>ziplist:<ul><li>键值对相邻,先压入键再压入值</li><li>直接往尾部添加</li></ul></li><li>hashtable:<ul><li>使用dict实现</li><li>dict的键保存键,值保存值</li></ul></li></ul></li><li><p>集合</p><ul><li>使用intset或者hashtable</li><li>使用hashtable实现时,字典每个键都是一个字符串对象,对应一个集合元素,字典值设为null</li></ul></li><li><p>有序集合</p><ul><li>使用ziplist或者skiplist</li></ul></li><li><p>多态指令:</p><ul><li>根据对象的类型编码决定指令的具体函数与实现方式决定要调用的函数</li><li>执行指令前像检查对应键或者值能否正确执行相关函数指令</li></ul></li><li><p>内存回收</p><ul><li>通过引用计数在适当时候释放对象并回收内存<ul><li>创建时引用数加一</li><li>被新程序使用时引用数加一</li><li>程序不再使用,引用数减一</li><li>引用数变成0,内存释放</li></ul></li></ul></li><li><p>对象共享</p><ul><li>共享就是利用refcount实现的,每多一个共享的就加一</li><li>提前准备了0到9999的字符串对象共享</li></ul></li><li><p>空转时长</p><ul><li>lru记录最后一次被程序访问的时间,当前时间减去lru时间就是空转时长</li><li>(打印空转时长并不会更新lru值)</li><li>当内存比较满时,最先被释放的是lru最早的那些键</li></ul></li></ul><h2 id="数据类型实现"><a href="#数据类型实现" class="headerlink" title="数据类型实现"></a>数据类型实现</h2><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><ul><li>setGenericCommand()函数实现了SET,SETEX,PSETEX,SETNX指令<ul><li>expire 定义了 Redis 对象的过期时间</li><li><em>ok_reply 和 abort_reply 决定了命令回复的内容，NX 参数和 XX 参数也会改变回复。</em><ul><li><em>如果 ok_reply 为 NULL ，那么 “+OK” 被返回。如果 abort_reply 为 NULL ，那么 “$-1” 被返回。</em></li></ul></li></ul></li><li>getExpireMillisecondsOrReply()实现了过期处理,从客户请求中处理过期的robj</li><li>parseExtendedStringArgumentsOrReply()判断当前字符串操作指令的有效性</li><li>*getexCommand()*对于GET的多余参数进行处理,和GET不同,这个指令不是仅可读的</li><li>setrangeCommand()函数中感觉有个地方可以优化,sdslen只能为0或者正值,那么可以减少一个地方的判断,少用一个if语句</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3W1H | 关于写博客的反思</title>
      <link href="/2022/01/26/guan-yu-xie-bo-ke-de-si-kao/"/>
      <url>/2022/01/26/guan-yu-xie-bo-ke-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h1 id="3W1H-关于写博客的反思"><a href="#3W1H-关于写博客的反思" class="headerlink" title="3W1H | 关于写博客的反思"></a>3W1H | 关于写博客的反思</h1><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><p>也就是之前只是做了一个比较粗糙的主页，现在想要丰富一下自己的页面</p><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><p>大概就是记录自己学习过程的东西吧，主要做的就是redis方面的</p><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><p>更多只是自己学习方面的记录，我觉得有时间摸摸鱼写一下就是很给博客面子了</p><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2><p>不准备花多少时间哈哈哈哈哈哈我可能就是心血来潮搞一下而已</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/26/hello-world/"/>
      <url>/2022/01/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
