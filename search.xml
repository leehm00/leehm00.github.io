<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机数据字节顺序</title>
      <link href="/2022/04/15/ji-suan-ji-shu-ju-zi-jie-shun-xu/"/>
      <url>/2022/04/15/ji-suan-ji-shu-ju-zi-jie-shun-xu/</url>
      
        <content type="html"><![CDATA[<p>在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。</p><p>这是就可能用到<code>htons(), ntohl(), ntohs()，htons()</code>这4个函数。 </p><p>网络字节顺序与本地字节顺序之间的转换函数：   </p><ul><li>htonl()–”Host to Network Long” </li><li>ntohl()–”Network to Host Long” </li><li>htons()–”Host to Network Short” </li><li>ntohs()–”Network to Host Short”   </li></ul><p>之所以需要这些函数是因为计算机数据表示存在两种字节顺序：NBO与HBO  </p><ul><li>网络字节顺序NBO（Network Byte Order）： 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。   </li><li>主机字节顺序（HBO，Host Byte Order）：    不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。 </li></ul><p>如 Intel  x86结构下,short型数0x1234表示为34  12, int型数0x12345678表示为78  56  34  12   如IBM  power PC结构下,short型数0x1234表示为12  34, int型数0x12345678表示为12  34  56  78   由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power  pc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。</p><p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。 主机字节序就是我们平常说的大端和小端模式：不同的 CPU 有不同的字节序类型，这些字节序是指整数在内存中保存的顺序 这个叫做主机序。</p><p>ntohs()是一个函数名，作用是将一个16位数由网络字节顺序转换为主机字节顺序</p><p>将一个无符号短整型数从网络字节顺序转换为主机字节顺序。 </p><p>#include &lt;netinet/in.h&gt; </p><p>uint16_t ntohs(uint16_t netshort); </p><p>netshort是一个以网络字节顺序表达的16位数。</p><p>本函数将一个16位数从主机字节顺序转换成网络字节顺序。 </p><p>返回值： htons()返回一个网络字节顺序的值。 </p><p>比如网络字节 为 00 01 u_short a如果直接对应的话 a=0100; 为什么呢？因为主机是从高字节到低字节的，所以应该转化后a=ntohs(0001); 这样 a=0001;</p><p>htons和ntohs的使用 网络中抓去的数据包，如果直接按结构体对齐的方式赋值给结构体指针，则结构体中长度大于一个字节的整形数据必须使用htons转换，因为抓取的包字段是按网络字节序排列的，直接通过指针的指向，大于一个字节的数据赋值将与原值不一致，因为内存排列方式不一样</p><p>参考：</p><p><a href="https://blog.csdn.net/qq_38171115/article/details/70232453">ntohs函数的意思</a></p>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis集群</title>
      <link href="/2022/04/14/redis-ji-qun/"/>
      <url>/2022/04/14/redis-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="redis集群理论"><a href="#redis集群理论" class="headerlink" title="redis集群理论"></a>redis集群理论</h1><p>单机遇到内存、并发、流量等瓶颈时，可以采用Cluster架构方案来达到负载均衡</p><h2 id="一-基础理论"><a href="#一-基础理论" class="headerlink" title="一 基础理论"></a>一 基础理论</h2><h3 id="1-1分区规则"><a href="#1-1分区规则" class="headerlink" title="1.1分区规则"></a>1.1分区规则</h3><p>数据集按照分区规则映射到各个节点</p><p><img src="/2022/04/14/redis-ji-qun/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2Mzk5OTkx,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>常见哈希分区：</p><ol><li><p>节点取余分区</p><p>使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式： hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。</p></li></ol><p>   <strong>缺点</strong>：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p><p>   <strong>优点</strong>：这种方式的突出优点是简单，易理解；</p><p>   这种方式常用于数据库的分库分表规则，一般采 用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张 表，保证可支撑未来一段时间的数据量，再根据负载情况将表迁移到其他数 据库中。<br>   扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移 的情况</p><ol start="2"><li><p>一致性哈希分区</p><p>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token（范围一般在0~2^32），这些token构成一个哈希环。</p><p>数据读写 执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点；</p><p><strong>缺点：</strong></p><p>加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。<br>当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此 这种方式不适合少量数据节点的分布式方案。</p><p><strong>优点</strong>：</p><p>相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响</p></li><li><p><strong>虚拟槽分区</strong><br>虚拟槽分区使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）；<br>槽范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383；<br>槽是集群内数据 管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集 群扩展；<br>每个节点会负责一定数量的槽；</p></li></ol><h3 id="1-2redis的数据分区"><a href="#1-2redis的数据分区" class="headerlink" title="1.2redis的数据分区"></a>1.2redis的数据分区</h3><p>Redis Cluser 采用虚拟槽分区，所有的键根据哈希函数映射到 0~16383整 数槽内；</p><p>计算公式：slot=CRC16（ key ） &amp;16383；<br>每一个节点负责维护一部分槽以及槽所映射的键值数据；</p><p>redis虚拟槽分区的特点：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ul><h3 id="1-3集群功能限制"><a href="#1-3集群功能限制" class="headerlink" title="1.3集群功能限制"></a>1.3集群功能限制</h3><ol><li>key批操作命令支持有限。如mset、mget，目前只支持具有相同slot值的 key执行批量操作。</li><li>key事务操作支持有限。只支持多key在同一节点上的事务操 作，当多个key分布在不同的节点上时无法使用事务功能。</li><li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list等映射到不同的节点。</li><li>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模 式下只能使用一个数据库空间，即db0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复 制结构。</li></ol><p> 一个完整的节点</p><p><img src="/2022/04/14/redis-ji-qun/1478675-20190530111414956-1304307578.png" alt="img"></p><h2 id="二-搭建"><a href="#二-搭建" class="headerlink" title="二 搭建"></a>二 搭建</h2><p>搭建集群工作分四步：</p><h3 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h3><p>Redis 集群一般由多个节点组成，节点数量至少为 6个才能保证组成完整高可用的集群。</p><p><strong>cluster-enabled :</strong> 每个节点需要<strong>开启配置</strong> <strong>cluster-enabled yes</strong> ，让 Redis运行在集群模式下。<br><strong>cluster-config-file:</strong> 第一次启动时如果没有【集群配置文件】，它会自动创建一份，该配置文件名称采用cluster-config-file配置参数项控制；<br>节点重启的时候会加载该配置文件进行重用；</p><p>如果集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会自动保存集群状态到配置文件中（ <strong>cluster-config-file</strong>）<br>Redis自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错乱。</p><p> <img src="/2022/04/14/redis-ji-qun/image-20211127143430284.png" alt="image-20211127143430284"></p><h3 id="节点握手cluster-meet"><a href="#节点握手cluster-meet" class="headerlink" title="节点握手cluster meet"></a>节点握手cluster meet</h3><p>节点握手是指一批运行在集群模式下的节点通过 Gossip协议彼此通信， 达到感知对方的目的。</p><p>由客户端使用命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cluster meet <span class="token punctuation">{</span>ip<span class="token punctuation">}</span> <span class="token punctuation">{</span>port<span class="token punctuation">}</span></code></pre><p>cluster meet命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信；</p><p>我们只需要在集群内任意节点上执行cluster meet命令加入新节点，握手 状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程</p><p>节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止</p><p>由于目前所有的槽没有分配到节点，因此集群无法完成槽到节点的映射。</p><p>只有当 16384 个槽全部分配给节点后，集群才进入在线状态。</p><h3 id="分配槽cluster-addslots"><a href="#分配槽cluster-addslots" class="headerlink" title="分配槽cluster addslots"></a><strong>分配槽</strong>cluster addslots</h3><p>通过 cluster addslots命令为节点分配槽:</p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46379</span> cluster addslots <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2730</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46380</span> cluster addslots <span class="token punctuation">{</span><span class="token number">2731</span><span class="token punctuation">..</span><span class="token number">5461</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46381</span> cluster addslots <span class="token punctuation">{</span><span class="token number">5462</span><span class="token punctuation">..</span><span class="token number">7211</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46382</span> cluster addslots <span class="token punctuation">{</span><span class="token number">7212</span><span class="token punctuation">..</span><span class="token number">10922</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46383</span> cluster addslots <span class="token punctuation">{</span><span class="token number">10923</span><span class="token punctuation">..</span><span class="token number">12331</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46384</span> cluster addslots <span class="token punctuation">{</span><span class="token number">12332</span><span class="token punctuation">..</span><span class="token number">16383</span><span class="token punctuation">}</span></code></pre><h3 id="设置主从关系cluster-replicate"><a href="#设置主从关系cluster-replicate" class="headerlink" title="设置主从关系cluster replicate"></a>设置主从关系cluster replicate</h3><p>作为一个完整的集群，每个负责处理槽的 节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。</p><p>集群模式下， Reids 节点角色分为主节点和从节点。</p><p>首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">cluster replicate<span class="token punctuation">{</span>nodeId<span class="token punctuation">}</span>命令让一个节点成为从节点</code></pre><p>注意：在集群模式下slaveof添加从节点操作不再支持</p><p>cluster info命令可以获取集群当前状态：<br>cluster nodes命令可以看到节点和槽的分配关系：</p><h2 id="三-节点通信"><a href="#三-节点通信" class="headerlink" title="三 节点通信"></a>三 节点通信</h2><p>在分布式存储中需要提供维护节点元数据信息的机制。<br>所谓元数据是 指：节点负责哪些数据，是否出现故障等状态信息。<br>常见的元数据维护方式 分为：集中式和P2P方式。<br>Redis集群采用P2P的Gossip（流言）协议， Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息。</p><h3 id="3-1通信流程"><a href="#3-1通信流程" class="headerlink" title="3.1通信流程"></a>3.1通信流程</h3><ol><li>集群中的每个节点都会单独开辟一个 TCP通道，用于节点之间彼此通信，默认通信端口号在基础端口上加 10000（也可通过 <code>cluter meet &lt;ip&gt; &lt;port&gt; [cport]</code> 的cport的参数指定端口） 。</li><li>每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。</li><li>接收到 ping 消息的节点用 pong 消息作为响应。</li></ol><p>当节点出故障、新节点加入、主从角色变化、槽信息 变更等事件发生时，通过不断的ping/pong消息通信</p><p>经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。</p><h3 id="3-2-Gossip消息"><a href="#3-2-Gossip消息" class="headerlink" title="3.2 Gossip消息"></a>3.2 Gossip消息</h3><p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的 Gossip 消息；</p><p>常用的 Gossip 消息可分为： ping 消息、 pong 消息、 meet 消息、 fail 消息等:</p><ul><li><p>meet消息：用于通知新节点加入。<br>消息发送者通知接收者加入到当前集群， meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping 、 pong 消息交换。</p></li><li><p>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。<br>ping消息发送封装了自身节点和部分其他节点的状态数据。</p></li><li><p>pong 消息：当接收到 ping 、 meet消息时，作为响应消息回复给发送方确认消息正常通信。<br>pong 消息内部封装了自身状态数据。<br>节点也可以向集群内 广播自身的 pong 消息来通知整个集群对自身状态进行更新。</p></li><li><p>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail 消息<br>其他节点接收到 fail 消息之后把对应节点更新为下线状态。</p></li></ul><h3 id="3-3节点选择"><a href="#3-3节点选择" class="headerlink" title="3.3节点选择"></a>3.3节点选择</h3><p>虽然 Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。</p><p>由于内部需要频繁地进行节点信息交换，而 ping/pong消息会携带当前节点和部分其他节点的状态数据，会加重带宽和计算的负担。</p><p>因此节点每次选择需 要通信的节点列表变得非常重要;</p><ul><li><p>通信节点选择过多，虽然可以做到信息及时 交换但成本过高。</p></li><li><p>节点选择过少会降低集群内所有节点彼此信息交换频率， 从而影响故障判定、新节点发现等需求的速度。</p></li></ul><ol><li><p><strong>选择发送消息的节点数量</strong></p><p>集群内每个节点维护定时任务默认每秒执行 10 次，每秒会随机选取 5个节点找出最久没有通信的节点发送 ping 消息，用于保证 Gossip信息交换的随机性。<br>每 100 毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于 cluster_node_timeout/2 ，则立刻发送ping消息，防止该节点信息太长时间未更新。</p><p>因此 cluster_node_timeout参数对消息发送的节点数量影响非常大。</p><p>当我们的带宽资源紧张时，可以适当调大这个参数，如从默认 15 秒改为 30秒来降低带宽占用率。</p><p>过度调大 cluster_node_timeout 会影响消息交换的频率从而影响故障转移、槽信息更新、新节点发现的速度。</p><p>因此需要根据业务容忍度和资源消耗进行平衡。同时整个集群消息总交换量也跟节点数成正比。</p></li><li><p><strong>消息数据量</strong></p><p>每个 ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是 myslots[CLUSTER_SLOTS/8] ，占用 2KB，这块空间占用相对固定。<br>消息体会携带一定数量的其他节点信息用于信息交换。</p></li></ol><h2 id="四-集群伸缩"><a href="#四-集群伸缩" class="headerlink" title="四 集群伸缩"></a>四 集群伸缩</h2><p>Redis集群可以实现对节点的灵活上下线控制。其中原理可抽象为槽和对应数据在不同节点之间灵活移动。</p><h3 id="4-1扩容集群"><a href="#4-1扩容集群" class="headerlink" title="4.1扩容集群"></a>4.1扩容集群</h3><p>扩容可以分为如下步骤：</p><p><strong>1.准备新节点</strong></p><p><strong>2.加入集群</strong><br>准备好新节点后，依然采用 cluster meet 命令，将新的节点加入到集群<br>新节点加入到集群后，还没有负责的槽，所以还不能接受任何读写操作；对新节点的后续操作一般有两种选择：<br>（1）作为其他主节点的从节点，负责故障转移<br>（2）为他迁移槽和数据，实现扩容</p><blockquote><p>注意：<br>手动执行 cluster meet 命令加入已经存在于其他集群的节点，会造成被加入节点的集群合并到现有集群的情况从而造成数据丢失和错乱，</p><p>后果非常严重，线上谨慎操作。</p><p><strong>正式环境建议使用redis-trib.rb add-node命令加入新节点，该命令内部会执行新节点状态检查</strong><br>如果新节点已经加入其他集群或者包含数据，则放弃集群加入操作</p></blockquote><p><strong>3.迁移槽和数据</strong><br>最后 迁移槽和数据 是扩容最核心的环节，槽在迁移过程中集群仍然可以正常提供读写服务；<br>槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。<br>迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀。</p><p>迁移具体操作步骤如下：</p><ol><li>对目标节点发送 cluster setslot {slot} importing {sourceNodeId}命令，让目标节点准备导入槽的数据。</li><li>对源节点发送 cluster setslot {slot} migrating {targetNodeId}命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行 cluster getkeysinslot {slot} {count} 命令，获取 count个属于槽 {slot} 的键。</li><li>在源节点上执行migrate{targetIp}{targetPort}””0{timeout}keys{keys…}命令，把获取的键通过流水线（ pipeline ）机制批量迁移到目标节点。</li><li>重复执行步骤 3 ）和步骤 4）直到槽下所有的键值数据迁移到目标节点。</li><li>向集群内所有主节点发送 cluster setslot {slot} node {targetNodeId}命令，通知槽分配给目标节点。</li></ol><blockquote><p> todo：如果是迁移过程中的修改如何体现在新节点？</p><ol><li>储存迁移期间的指令？</li><li>转移整个槽？</li></ol></blockquote><h3 id="4-2收缩集群"><a href="#4-2收缩集群" class="headerlink" title="4.2收缩集群"></a>4.2收缩集群</h3><p>收缩集群意味着缩减规模，需要从现有集群中安全下线部分节点；</p><p>操作流程如下：</p><ol><li>确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。</li></ol><p>   原理与上面 节点扩容的迁移槽过程一致。</p><ol start="2"><li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。</li></ol><p>   Redis 提供了cluster forget {downNodeId} 命令实现该功能。</p><p>   当节点接收到 cluster forget{down NodeId} 命令后，会把 nodeId指定的节点加入到禁用列表中，在禁用列表内的节点不再发送 Gossip消息。<br>   禁用列表有效期是 60 秒，超过 60秒节点会再次参与消息交换。</p><p>   也就是说当第一次forget 命令发出后，我们有 60 秒的时间让集群内的所有节点忘记下线节点。</p><blockquote><p>线上操作不建议直接使用 cluster forget命令下线节点，需要跟大量节点命令交互，<br>实际操作起来过于繁琐并且容易遗漏 forget 节点。<br>建议使用redis-trib.rb del-node{host ： port} {downNodeId} 命令</p></blockquote><h2 id="五-请求路由"><a href="#五-请求路由" class="headerlink" title="五 请求路由"></a>五 请求路由</h2><h3 id="5-1请求重定向"><a href="#5-1请求重定向" class="headerlink" title="5.1请求重定向"></a>5.1请求重定向</h3><p>在集群模式下， Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；</p><p>否则回复MOVED重定向错误，通知客户端请求正确的节点。 这个过程称为MOVED重定向；</p><p>用 redis-cli 命令时，可以加入-c参数支持自动重定向，简化手动发起重定向操作；</p><p>redis-cli 自动帮我们连接到正确的节点执行命令，这个过程是在redis-cli内部维护；<br>实质上是 client 端接到 MOVED 信息之后再次发起请求，并不在Redis节点中完成请求转发；</p><blockquote><p>Redis计算键所对应的槽时<br>如果键内容包含{和}两种大括号字符，则计算槽的有效部分是括号内的内容；否则采用键的全内容计算槽。</p></blockquote><h3 id="5-2-smart客户端"><a href="#5-2-smart客户端" class="headerlink" title="5.2 smart客户端"></a>5.2 smart客户端</h3><p>Smart 客户端通过在内部维护 slot→node的映射关系，本地就可实现键到节点的查找，从而保证 IO 效率的最大化，</p><p>而 MOVED 重定向负责协助 Smart客户端更新 slot→node映射。</p><p>对 Smart客户端成本和可能存在的问题：</p><ul><li>客户端内部维护 slots缓存表，并且针对每个节点维护连接池，当集群规模非常大时，客户端会维护非常多的连接并消耗更多的内存。</li></ul><h3 id="5-3ASK重定向"><a href="#5-3ASK重定向" class="headerlink" title="5.3ASK重定向"></a>5.3ASK重定向</h3><p>Redis 集群支持在线迁移槽（ slot ）和数据来完成水平伸缩，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。</p><p>例如当一个 slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点；</p><p>当出现上述情况时，客户端键命令执行流程将发生变化：</p><ol><li>客户端根据本地 slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端。</li><li>如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK 重定向异常。<br>格式如下：（ error ） ASK{slot}{targetIP} ： {targetPort} 。</li><li>客户端从 ASK 重定向异常提取出目标节点信息，发送 asking命令到目标节点打开客户端连接标识，再执行键命令。</li></ol><blockquote><p>ASK 与 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别。</p><p>ASK 重定向说明集群正在进行 slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slots 缓存；</p><p>但是MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存；</p></blockquote><h1 id="redis集群代码实现"><a href="#redis集群代码实现" class="headerlink" title="redis集群代码实现"></a>redis集群代码实现</h1><h2 id="一-节点部分实现"><a href="#一-节点部分实现" class="headerlink" title="一 节点部分实现"></a>一 节点部分实现</h2><h3 id="1-1节点数据结构"><a href="#1-1节点数据结构" class="headerlink" title="1.1节点数据结构"></a>1.1节点数据结构</h3><p>集群中每个节点都会使用clusterNode结构记录自己的状态，并为集群中的其他节点都创建一个clusterNode结构记录其他节点状态：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>    <span class="token comment">//节点创建时间</span>    mstime_t ctime<span class="token punctuation">;</span> <span class="token comment">/* Node object creation time. */</span>    <span class="token comment">//节点的名字</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Node name, hex string, sha1-size */</span>    <span class="token comment">//节点标识,节点的角色和状态等信息</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>      <span class="token comment">/* CLUSTER_NODE_... */</span>    <span class="token comment">//节点当前配置的纪元</span>    <span class="token keyword">uint64_t</span> configEpoch<span class="token punctuation">;</span> <span class="token comment">/* Last configEpoch observed for this node */</span>    <span class="token comment">//二进制数组,这个节点所持有的slots</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* slots handled by this node */</span>    <span class="token comment">//用string标识的slots的具体信息</span>    sds slots_info<span class="token punctuation">;</span> <span class="token comment">/* Slots info represented by string. */</span>    <span class="token comment">//记录节点的槽数量</span>    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>   <span class="token comment">/* Number of slots handled by this node */</span>    <span class="token comment">//拥有的slave的数量,前提是这个节点是master</span>    <span class="token keyword">int</span> numslaves<span class="token punctuation">;</span>  <span class="token comment">/* Number of slave nodes, if this is a master */</span>    <span class="token comment">//具体拥有哪些slave数组</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span><span class="token operator">*</span>slaves<span class="token punctuation">;</span> <span class="token comment">/* pointers to slave nodes */</span>    <span class="token comment">//当前节点是slave,指向他的master(也可能是空,当前没有master节点)</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>slaveof<span class="token punctuation">;</span> <span class="token comment">/* pointer to the master node. Note that it                                    may be NULL even if the node is a slave                                    if we don't have the master node in our                                    tables. */</span>    <span class="token comment">//节点最近一次发送ping的时间</span>    mstime_t ping_sent<span class="token punctuation">;</span>      <span class="token comment">/* Unix time we sent latest ping */</span>    <span class="token comment">//节点最近一次接收到ping的时间</span>    mstime_t pong_received<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received the pong */</span>    <span class="token comment">//接收到数据的时间</span>    mstime_t data_received<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received any data */</span>    mstime_t fail_time<span class="token punctuation">;</span>      <span class="token comment">/* Unix time when FAIL flag was set */</span>    mstime_t voted_time<span class="token punctuation">;</span>     <span class="token comment">/* Last time we voted for a slave of this master */</span>    mstime_t repl_offset_time<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received offset for this node */</span>    mstime_t orphaned_time<span class="token punctuation">;</span>     <span class="token comment">/* Starting time of orphaned master condition */</span>    <span class="token comment">//最近的偏移量,用处很多</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_offset<span class="token punctuation">;</span>      <span class="token comment">/* Last known repl offset for this node. */</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Latest known IP address of this node */</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span>                   <span class="token comment">/* Latest known clients port (TLS or plain). */</span>    <span class="token keyword">int</span> pport<span class="token punctuation">;</span>                  <span class="token comment">/* Latest known clients plaintext port. Only used                                   if the main clients port is for TLS. */</span>    <span class="token keyword">int</span> cport<span class="token punctuation">;</span>                  <span class="token comment">/* Latest known cluster port of this node. */</span>    <span class="token comment">//保存与当前节点有链接的节点</span>    clusterLink <span class="token operator">*</span>link<span class="token punctuation">;</span>          <span class="token comment">/* TCP/IP link with this node */</span>    list <span class="token operator">*</span>fail_reports<span class="token punctuation">;</span>         <span class="token comment">/* List of nodes signaling this as failing */</span><span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre><p>clusterNode中link属性保存了连接节点所需要的有关信息（与redisClient结构的连接到客户端有所不同，用于连接其他的节点）：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterLink</span> <span class="token punctuation">{</span>    <span class="token comment">//连接创建时间</span>    mstime_t ctime<span class="token punctuation">;</span>             <span class="token comment">/* Link creation time */</span>    <span class="token comment">//远程连接结构体</span>    connection <span class="token operator">*</span>conn<span class="token punctuation">;</span>           <span class="token comment">/* Connection to remote node */</span>    <span class="token comment">//输出缓冲区,保存需要发送给其他节点的信息</span>    sds sndbuf<span class="token punctuation">;</span>                 <span class="token comment">/* Packet send buffer */</span>    <span class="token comment">//输入缓冲区,报讯其他节点发送过来的消息</span>    <span class="token keyword">char</span> <span class="token operator">*</span>rcvbuf<span class="token punctuation">;</span>               <span class="token comment">/* Packet reception buffer */</span>    size_t rcvbuf_len<span class="token punctuation">;</span>          <span class="token comment">/* Used size of rcvbuf */</span>    size_t rcvbuf_alloc<span class="token punctuation">;</span>        <span class="token comment">/* Allocated size of rcvbuf */</span>    <span class="token comment">//该连接所关联的节点</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>   <span class="token comment">/* Node related to this link if any, or NULL */</span><span class="token punctuation">}</span> clusterLink<span class="token punctuation">;</span></code></pre><p>每个节点都会保存一个clusterState结构（server.h/redisServer –&gt; cluster.h/clusterState）;用来记录当前集群所处的状态；</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * 集群状态 * 入口:  server.h/struct redisServer --&gt; clusterState; * 初始化入口：server.c/initServer() --&gt; cluster.c/clusterInit() */</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>    <span class="token comment">//指向当前服务器节点</span>    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>  <span class="token comment">/* This node */</span>    <span class="token comment">//节点纪元,故障转移使用</span>    <span class="token keyword">uint64_t</span> currentEpoch<span class="token punctuation">;</span>    <span class="token comment">//整个集群的状态,上线/下线</span>    <span class="token keyword">int</span> state<span class="token punctuation">;</span>            <span class="token comment">/* CLUSTER_OK, CLUSTER_FAIL, ... */</span>    <span class="token comment">//集群中至少处理着一个槽的节点的数量</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>             <span class="token comment">/* Num of master nodes with at least one slot */</span>    <span class="token comment">//name-&gt;clusterNode的键值对</span>    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>          <span class="token comment">/* Hash table of name -&gt; clusterNode structures */</span>    dict <span class="token operator">*</span>nodes_black_list<span class="token punctuation">;</span> <span class="token comment">/* Nodes we don't re-add for a few seconds. */</span>    clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//记录槽的指派信息,数组的每个值对应于负责该槽的节点</span>    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    clusterSlotsToKeysData slots_to_keys<span class="token punctuation">;</span>    <span class="token comment">/* The following fields are used to take the slave state on elections. */</span>    <span class="token comment">//选举时获取slave的状态</span>    mstime_t failover_auth_time<span class="token punctuation">;</span> <span class="token comment">/* Time of previous or next election. */</span>    <span class="token comment">//故障转移收到的票数</span>    <span class="token keyword">int</span> failover_auth_count<span class="token punctuation">;</span>    <span class="token comment">/* Number of votes received so far. */</span>    <span class="token comment">//是否已经向其他节点请求投票给自己</span>    <span class="token keyword">int</span> failover_auth_sent<span class="token punctuation">;</span>     <span class="token comment">/* True if we already asked for votes. */</span>    <span class="token keyword">int</span> failover_auth_rank<span class="token punctuation">;</span>     <span class="token comment">/* This slave rank for current auth request. */</span>    <span class="token keyword">uint64_t</span> failover_auth_epoch<span class="token punctuation">;</span> <span class="token comment">/* Epoch of the current election. */</span>    <span class="token comment">//slave节点不能故障转移的原因</span>    <span class="token keyword">int</span> cant_failover_reason<span class="token punctuation">;</span>   <span class="token comment">/* Why a slave is currently not able to                                   failover. See the CANT_FAILOVER_* macros. */</span>            <span class="token comment">//需要手动转移故障,记录当前状态</span>    <span class="token comment">/* Manual failover state in common. */</span>    <span class="token comment">//手动故障切换时间限制（ms unixtime）。</span>    <span class="token comment">//如果没有正在进行的manual failover,则为零</span>    mstime_t mf_end<span class="token punctuation">;</span>            <span class="token comment">/* Manual failover time limit (ms unixtime).                                   It is zero if there is no MF in progress. */</span>    <span class="token comment">/* Manual failover state of master. */</span>    <span class="token comment">//mester的手动故障转移状态</span>    clusterNode <span class="token operator">*</span>mf_slave<span class="token punctuation">;</span>      <span class="token comment">/* Slave performing the manual failover. */</span>    <span class="token comment">/* Manual failover state of slave. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> mf_master_offset<span class="token punctuation">;</span> <span class="token comment">/* Master offset the slave needs to start MF                                   or -1 if still not received. */</span>    <span class="token keyword">int</span> mf_can_start<span class="token punctuation">;</span>           <span class="token comment">/* If non-zero signal that the manual failover                                   can start requesting masters vote. */</span>    <span class="token comment">/* The following fields are used by masters to take state on elections. */</span>    <span class="token keyword">uint64_t</span> lastVoteEpoch<span class="token punctuation">;</span>     <span class="token comment">/* Epoch of the last vote granted. */</span>    <span class="token keyword">int</span> todo_before_sleep<span class="token punctuation">;</span> <span class="token comment">/* Things to do in clusterBeforeSleep(). */</span>    <span class="token comment">/* Messages received and sent by type. */</span>    <span class="token comment">//按照消息类型进行接受和发送</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_bus_messages_sent<span class="token punctuation">[</span>CLUSTERMSG_TYPE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_bus_messages_received<span class="token punctuation">[</span>CLUSTERMSG_TYPE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_pfail_nodes<span class="token punctuation">;</span>    <span class="token comment">/* Number of nodes in PFAIL status,                                       excluding nodes without address. */</span><span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre><p>一个实际的例子：</p><p><img src="/2022/04/14/redis-ji-qun/image-20211127204524760.png" alt="image-20211127204524760"></p><h3 id="1-2-cluster-meet命令的实现"><a href="#1-2-cluster-meet命令的实现" class="headerlink" title="1.2 cluster meet命令的实现"></a>1.2 cluster meet命令的实现</h3><p>[指令实现](#节点握手cluster meet)</p><p>向节点A发送cluster meet将节点B加入到集群中</p><pre class="language-bash" data-language="bash"><code class="language-bash">CLUSTER MEET <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span></code></pre><p>节点握手过程如下图：(类似于TCP的三次握手)<br><img src="/2022/04/14/redis-ji-qun/20210205165842362.png" alt="img"></p><p>cluster meet 命令的入口位于 cluster.c/clusterCommand()</p><h2 id="二-槽指派"><a href="#二-槽指派" class="headerlink" title="二 槽指派"></a>二 槽指派</h2><p>[指令实现](#分配槽cluster addslots)</p><p>每个槽都要有节点处理，要是有槽没有对应的节点，集群就处于下线状态</p><h3 id="2-1节点记录槽信息"><a href="#2-1节点记录槽信息" class="headerlink" title="2.1节点记录槽信息"></a>2.1节点记录槽信息</h3><p><strong>clusterNode</strong>结构体中的slots属性是个二进制数组，数组长度16384/8=2048个字节，记录了节点具体负责了哪个节点；例如，slots[111] = 1,表示该节点负责了编号111的槽；为0就表示不负责</p><p><img src="/2022/04/14/redis-ji-qun/image-20211128131539486.png" alt="image-20211128131539486"></p><p>numslots属性记录了节点负责槽的数量；</p><h3 id="2-2传播节点的槽指派信息"><a href="#2-2传播节点的槽指派信息" class="headerlink" title="2.2传播节点的槽指派信息"></a>2.2传播节点的槽指派信息</h3><p>节点除了会记录自己负责的槽信息，还会将自己负责的槽信息发送给其他节点</p><p>通过发送slots数组信息实现，接收到其他节点发来的消息之后就保存在对应于那个节点的clusterNode结构里面</p><h3 id="2-3记录集群所有槽的指派信息"><a href="#2-3记录集群所有槽的指派信息" class="headerlink" title="2.3记录集群所有槽的指派信息"></a>2.3记录集群所有槽的指派信息</h3><p>每个节点都有的clusterState结构中的slots是clusterNode数组，值是一个指向clusterNode的指针，记录了每个槽是由哪个节点负责的；</p><p>如果槽没有节点负责，则slot对应的数组值是NULL;</p><p>如果需要检查某个槽是否有节点负责，可以通过查询clusterState的slots高效解决；</p><p><img src="/2022/04/14/redis-ji-qun/image-20211128134512270.png" alt="image-20211128134512270"></p><blockquote><p>节点和服务器都有slots数组，节点的本地数组记录了自己管理的槽的信息，而</p></blockquote><h3 id="2-4CLUSTER-ADDSLOTS命令的实现"><a href="#2-4CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="2.4CLUSTER ADDSLOTS命令的实现"></a>2.4CLUSTER ADDSLOTS命令的实现</h3><p>cluster addslots 命令接受一个或者多个槽作为参数，并将输入的槽指派给接受该命令的节点；</p><p>cluster addslots 主要操作可以分为两步：</p><ol><li>更新myself节点的 slots属性bit位置标记为1。标识该槽由myself节点负责</li><li>更新clusterStatus属性的slots 数组对应的槽指向 myself节点；标识对应槽是由哪个节点负责的</li></ol><p><strong>代码入口 cluster.c/clusterCommand() ==&gt;  cluster.c/clusterAddSlot()</strong></p><p>开始创建的一个没有指派任何槽的节点</p><p><img src="/2022/04/14/redis-ji-qun/image-20211128184145276.png" alt="image-20211128184145276"></p><p>执行指令<code>CLUSTER&nbsp;ADDSLOTS&nbsp;1&nbsp;2</code>之后变成：</p><p><img src="/2022/04/14/redis-ji-qun/image-20211128184438831.png" alt="image-20211128184438831"></p><p>还会发布消息告诉其他节点，自己正在负责这些槽</p><p> <strong>cluster.c/clusterAddSlot()</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* Add the specified slot to the list of slots that node 'n' will * serve. Return C_OK if the operation ended with success. * If the slot is already assigned to another instance this is considered * an error and C_ERR is returned. */</span><span class="token comment">//将指定的插槽添加到节点n负责的插槽列表中</span><span class="token keyword">int</span> <span class="token function">clusterAddSlot</span><span class="token punctuation">(</span>clusterNode <span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//插槽已经被分配了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">//更新n的slots属性随用的slot的bit位为1,表示负责这个节点</span>    <span class="token function">clusterNodeSetSlotBit</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>slot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//更新clusterStatus的slots数组,使对应的槽指向myself节点,表示这个槽是由自己负责的</span>    server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三-集群中执行命令"><a href="#三-集群中执行命令" class="headerlink" title="三 集群中执行命令"></a>三 集群中执行命令</h2><p>在集群中执行命令，整理流程如下<br><img src="/2022/04/14/redis-ji-qun/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2Mzk5OTkx,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>例子， 如果我们在之前提到的， 由 7000、 7001、 7002 三个节点组成的集群中， 用客户端连上节点 7000, 并发送以下命令， 那么命令会直接被节点 7000 执行:</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set date "2021-12-31"</code></pre><p>因为键date所在的槽2022刚好是7000负责的，如果是执行</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set msg "happy new year"</code></pre><p>msg所在的槽6257就不是7000负责的了，就需要</p><ul><li>当客户端第一次向节点 7000 发送命令的时候， 节点 7000 会向客户端返回MOVED 错误， 指引客户端转向至节点 7001。</li><li>当客户端转向到节点 7001 之后， 客户端重新向节点 7001 发送命令， 这个命令会被节点 7001 成功执行。</li></ul><p>流程是这样的：</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set msg "happy new year"-&gt;Redirected to slot [ 6257] located at 127.0.0.1:7001OK127.0.0.1:7001&gt;GET msghappy new year</code></pre><p>  用7001可以直接得到msg对应的值，不需要重定向</p><p>命令执行的入口位于：<strong>server.c/processCommand()</strong> ==&gt; <strong>cluster.c/getNodeByQuery()</strong></p><p>计算键属于哪个槽、判断槽是否当前节点负责、MOVED错误 几个关系操作都是由 getNodeByQuery() 完成的；</p><p>执行流程如下</p><p><img src="/2022/04/14/redis-ji-qun/1478675-20190530112923984-1840717246.png" alt="img"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * 返回指向能够为命令提供服务的集群节点的指针。 * 要使函数成功，命令应仅针对以下任一目标： * 1） 命令只有一个key时（甚至像LPOPRPUSH mylist mylist那样多次）。 * 2） 在同一个哈希槽中有多个key，而该槽是稳定的（没有正在进行的重新哈希）。 */</span>clusterNode <span class="token operator">*</span><span class="token function">getNodeByQuery</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>hashslot<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>error_code<span class="token punctuation">)</span> <span class="token punctuation">{</span>    clusterNode <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    robj <span class="token operator">*</span>firstkey <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> multiple_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    multiState <span class="token operator">*</span>ms<span class="token punctuation">,</span> _ms<span class="token punctuation">;</span>    multiCmd mc<span class="token punctuation">;</span>    <span class="token comment">// migrating_slot标记slot正在迁移操作， 当前节点是迁移的源节点</span>    <span class="token comment">// importing_slot标记slot正在迁移操作， 当前节点是迁移的目标节点</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> migrating_slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> importing_slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> missing_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//如果模块禁用了集群重定向,就是允许设置任何key(没有分配槽的说法),直接可以用当前节点处理</span>    <span class="token comment">/* Allow any key to be set if a module disabled cluster redirections. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster_module_flags <span class="token operator">&amp;</span> CLUSTER_MODULE_FLAG_NO_REDIRECTION<span class="token punctuation">)</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">/* Set error code optimistically for the base case. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_NONE<span class="token punctuation">;</span>    <span class="token comment">/* Modules can turn off Redis Cluster redirection: this is useful     * when writing a module that implements a completely different     * distributed system. */</span>    <span class="token comment">//模块可以关闭集群重定向,利于编写实现完全不同的分布式系统的模块</span>    <span class="token comment">/* We handle all the cases as if they were EXEC commands, so we have     * a common code path for everything */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* If CLIENT_MULTI flag is not set EXEC is just going to return an         * error. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MULTI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> myself<span class="token punctuation">;</span>        ms <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">/* In order to have a single codepath create a fake Multi State         * structure if the client is not in MULTI/EXEC state, this way         * we have a single codepath below. */</span>        ms <span class="token operator">=</span> <span class="token operator">&amp;</span>_ms<span class="token punctuation">;</span>        _ms<span class="token punctuation">.</span>commands <span class="token operator">=</span> <span class="token operator">&amp;</span>mc<span class="token punctuation">;</span>        _ms<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>argv <span class="token operator">=</span> argv<span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>argc <span class="token operator">=</span> argc<span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>cmd <span class="token operator">=</span> cmd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//检查所有的key是否在同一个哈希槽中,并且获取槽和负责槽的节点</span>    <span class="token comment">/* Check that all the keys are in the same hash slot, and obtain this     * slot and the node associated. */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ms<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>mcmd<span class="token punctuation">;</span>        robj <span class="token operator">*</span><span class="token operator">*</span>margv<span class="token punctuation">;</span>        <span class="token keyword">int</span> margc<span class="token punctuation">,</span> <span class="token operator">*</span>keyindex<span class="token punctuation">,</span> numkeys<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        mcmd <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cmd<span class="token punctuation">;</span>        margc <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>argc<span class="token punctuation">;</span>        margv <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>argv<span class="token punctuation">;</span>        getKeysResult result <span class="token operator">=</span> GETKEYS_RESULT_INIT<span class="token punctuation">;</span>        numkeys <span class="token operator">=</span> <span class="token function">getKeysFromCommand</span><span class="token punctuation">(</span>mcmd<span class="token punctuation">,</span>margv<span class="token punctuation">,</span>margc<span class="token punctuation">,</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        keyindex <span class="token operator">=</span> result<span class="token punctuation">.</span>keys<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numkeys<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//计算key所属的slot,用thisslot记录下来</span>            robj <span class="token operator">*</span>thiskey <span class="token operator">=</span> margv<span class="token punctuation">[</span>keyindex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> thisslot <span class="token operator">=</span> <span class="token function">keyHashSlot</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>thiskey<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span>                                       <span class="token function">sdslen</span><span class="token punctuation">(</span>thiskey<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstkey <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//key就是这个slot中的第一个节点</span>                <span class="token comment">/* This is the first key we see. Check what is the slot                 * and node. */</span>                firstkey <span class="token operator">=</span> thiskey<span class="token punctuation">;</span>                slot <span class="token operator">=</span> thisslot<span class="token punctuation">;</span>                <span class="token comment">//n获取负责这个slot的节点</span>                n <span class="token operator">=</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">/* Error: If a slot is not served, we are in "cluster down"                 * state. However the state is yet to be updated, so this was                 * not trapped earlier in processCommand(). Report the same                 * error to the client. */</span>                <span class="token comment">/*                 *  如果这个节点还没节点负责，还在cluster down状态；                 *  但是，该状态尚未更新，因此在processCommand（）中没有捕获到该状态。                 * 向客户端报告相同的错误。                 */</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span>                        <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_UNBOUND<span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">/* If we are migrating or importing this slot, we need to check                 * if we have all the keys in the request (the only way we                 * can safely serve the request, otherwise we return a TRYAGAIN                 * error). To do so we set the importing/migrating state and                 * increment a counter for every missing key. */</span>                <span class="token comment">/*                 * 如果要迁移或导入此槽，则需要检查请求中有所有的key                 //（只有这样才能安全地为请求提供服务，否则返回TRYAGAIN错误）                 * 为此，需要设置导入/迁移状态，并为每个缺少的键增加一个计数器。                 */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> myself <span class="token operator">&amp;&amp;</span>                    server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>migrating_slots_to<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment">//标记正在进行迁移,作为源节点</span>                    migrating_slot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>importing_slots_from<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//标记正在迁移,作为目标节点</span>                    importing_slot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">/* If it is not the first key, make sure it is exactly                 * the same key as the first we saw. */</span>                <span class="token comment">//确保后续的key和前面看到的第一个key在同一个槽里面</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">equalStringObjects</span><span class="token punctuation">(</span>firstkey<span class="token punctuation">,</span>thiskey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>slot <span class="token operator">!=</span> thisslot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">//虽然slot最开始初始化为0,但是之前那个if一定是已经执行过一次以上了,</span>                        <span class="token comment">//就保证了一直处理的都是一个slot里面的key</span>                        <span class="token comment">/* Error: multiple keys from different slots. */</span>                        <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span>                            <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_CROSS_SLOT<span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">//标记,记录这个指令包含了不同的key(虽然刚好是同一个slot)</span>                        <span class="token comment">//todo:这个概率是不是很低啊?</span>                        <span class="token comment">/* Flag this request as one with multiple different                         * keys. */</span>                        multiple_keys <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">/* Migrating / Importing slot? Count keys we don't have. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>migrating_slot <span class="token operator">||</span> importing_slot<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">lookupKeyRead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>thiskey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                missing_keys<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//释放keyindex</span>        <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//指令之中本来就没有key</span>    <span class="token comment">/* No key at all in command? then we can serve the request     * without redirections or errors in all the cases. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">//集群并不是在线状态,在allow_reads_when_down打开的时候允许读</span>    <span class="token comment">/* Cluster is globally down but we got keys? We only serve the request     * if it is a read command and when allow_reads_when_down is enabled. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>state <span class="token operator">!=</span> CLUSTER_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>cluster_allow_reads_when_down<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">/* The cluster is configured to block commands when the             * cluster is down. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_STATE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">/* The cluster is configured to allow read only commands */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_RO_STATE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//不做处理,继续执行后面的代码,在本地进行读</span>            <span class="token comment">/* Fall through and allow the command to be executed:             * this happens when server.cluster_allow_reads_when_down is             * true and the command is not a write command */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Return the hashslot by reference. */</span>    <span class="token comment">//返回slot(引用返回,返回多个值的办法)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hashslot<span class="token punctuation">)</span> <span class="token operator">*</span>hashslot <span class="token operator">=</span> slot<span class="token punctuation">;</span>    <span class="token comment">/* MIGRATE always works in the context of the local node if the slot     * is open (migrating or importing state). We need to be able to freely     * move keys among instances in this case. */</span>    <span class="token comment">/*     * 如果槽处于 "迁移或导入状态"，则迁移始终在本地节点的上下文中工作。     * 在这种情况下，我们需要能够在实例之间自由移动键。     */</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>migrating_slot <span class="token operator">||</span> importing_slot<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> migrateCommand<span class="token punctuation">)</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">/* If we don't have all the keys and we are migrating the slot, send     * an ASK redirection. */</span>    <span class="token comment">//节点处于迁移状态，当前节点是迁移的源节点，并且key不在当前节点，返回ASK错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>migrating_slot <span class="token operator">&amp;&amp;</span> missing_keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_ASK<span class="token punctuation">;</span>        <span class="token keyword">return</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>migrating_slots_to<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     * 如果我们正在接收槽，并且client正确地将请求标记为“ASKING”，我们就可以为请求提供服务     * 但是，如果请求涉及多个key，而我们没有全部key，那么唯一的选择就是发送一个trygain错误     * 等待所有的key迁移完毕之后再进行查询     */</span>    <span class="token comment">/* If we are receiving the slot, and the client correctly flagged the     * request as "ASKING", we can serve the request. However if the request     * involves multiple keys and we don't have them all, the only option is     * to send a TRYAGAIN error. */</span>    <span class="token comment">//当前节点是迁移节点的目标节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>importing_slot <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_ASKING <span class="token operator">||</span> cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_ASKING<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple_keys <span class="token operator">&amp;&amp;</span> missing_keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_UNSTABLE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> myself<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Handle the read-only client case reading from a slave: if this     * node is a slave and the request is about a hash slot our master     * is serving, we can reply without redirection. */</span>    <span class="token keyword">int</span> is_write_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span> <span class="token operator">||</span>                           <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_READONLY <span class="token operator">&amp;&amp;</span>        <span class="token operator">!</span>is_write_command <span class="token operator">&amp;&amp;</span>        <span class="token function">nodeIsSlave</span><span class="token punctuation">(</span>myself<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        myself<span class="token operator">-&gt;</span>slaveof <span class="token operator">==</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回moved错误,需要重定向</span>    <span class="token comment">/* Base case: just return the right node. However if this node is not     * myself, set error_code to MOVED since we need to issue a redirection. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> myself <span class="token operator">&amp;&amp;</span> error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_MOVED<span class="token punctuation">;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p> 分别实现如下</p><h3 id="计算节点属于哪个槽"><a href="#计算节点属于哪个槽" class="headerlink" title="计算节点属于哪个槽"></a>计算节点属于哪个槽</h3><p>直接根据key的哈希算法计算当前key应该属于的槽i</p><h3 id="判断槽是否由当前节点处理"><a href="#判断槽是否由当前节点处理" class="headerlink" title="判断槽是否由当前节点处理"></a>判断槽是否由当前节点处理</h3><p>在clusterState.slots[]数组中查找第i项，并与clusterState.myself作比较：</p><ul><li>如果刚好是这个节点负责，就直接处理该指令</li><li>如果不是，根据记录中指定的节点ip和端口号返回moved错误，使客户端指向正确的节点</li></ul><h3 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h3><p>用于引导正确的节点，格式为<code>MOVED&nbsp;&lt;slot&gt;&nbsp;&lt;ip&gt;:&lt;port&gt;</code>，由客户端自动处置，不会在命令行显示出来。</p><p><img src="/2022/04/14/redis-ji-qun/image-20211128221010442.png" alt="image-20211128221010442"></p><h3 id="节点数据库实现"><a href="#节点数据库实现" class="headerlink" title="节点数据库实现"></a>节点数据库实现</h3><p>只能使用一个数据库（0号数据库），其他的实现和单机数据库没有什么区别</p><h2 id="四-重新分片"><a href="#四-重新分片" class="headerlink" title="四 重新分片"></a>四 重新分片</h2><p>重新分片操作可以将任意数量已经指派给某个节点（ 源节点 ） 的槽改为指派给另一个节点（ 目标节点 ）， 并且相关槽所属的键值对也会从源节点被移动到目标节点。<br>重新分片操作可以在线（ online ) 进行， 在重新分片的过程中， 集群不需要下线， 并且源节点和目标节点都可以继续处理命令请求。</p><h2 id="五-ASK错误"><a href="#五-ASK错误" class="headerlink" title="五 ASK错误"></a>五 ASK错误</h2><p>重新分片的过程中可能槽中一部分键在源节点中，而有一部分键已经移动到目标节点了，这时候客户端对于源节点发送针对相关键的请求：</p><ul><li>源节点会先在自己的数据库里面査找指定的键， 如果找到的话， 就直接执行客户端发送的命令。</li><li>相反地， 如果源节点没能在自己的数据库里面找到指定的键， 那么这个键有可能已经被迁移到了目标节点， 源节点将向客户端返回一个 ASK 错误， 指引客户端转向正在导人槽的目标节点， 并再次发送之前想要执行的命令。</li><li>todo：会不会有一个中间状态，两边都没有保存这个key</li></ul><p><img src="/2022/04/14/redis-ji-qun/image-20211129170705088.png" alt="image-20211129170705088"></p><p>客户端也不会显示错误，直接根据返回的ASK错误转向合适的节点请求数据</p><h3 id="Cluster-SetSlot-Importing命令的实现"><a href="#Cluster-SetSlot-Importing命令的实现" class="headerlink" title="Cluster SetSlot Importing命令的实现"></a>Cluster SetSlot Importing命令的实现</h3><p>cluster setslot importing是进行重新分片的第一步，redis-trib向目标节点发送该命令，准备好接收源节点的指定槽。</p><p>关于被导入的数组，是会被记录在目标节点的importing_slots_form数组中的，这个数组是一个clusterNode数组，是用来记录当前节点正在从哪些节点导入槽</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span><span class="token punctuation">(</span><span class="token comment">//..</span>    clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//..</span><span class="token punctuation">)</span>clusterState<span class="token punctuation">;</span></code></pre><p>可以看到这是一个clusterNode数组，但容量却是16384，对应的是槽的数量，使用索引i记录槽</p><p>假如importing_slots_from[i]指向的不是空，而是一个具体的clusterNode结构，那么就代表当前节点正在从这个clusterNode对应的节点导入槽i。</p><p>在对集群进行重新分片的时候，第一个命令是</p><pre class="language-redis" data-language="redis"><code class="language-redis">cluster setslot &lt;i&gt; importing &lt;source_id&gt;</code></pre><p>i代表的是16384个槽中的哪个槽，source_id是代表节点在集群里面的runid</p><p>这条命令的作用其实就是，当目标节点接收到这条命令，<strong>会修改importing_slots_from数组，在索引为i的位置上，放入source_id对应的clusterNode结构</strong>。<br><img src="/2022/04/14/redis-ji-qun/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><h3 id="cluster-setslot-migrating命令的实现"><a href="#cluster-setslot-migrating命令的实现" class="headerlink" title="cluster setslot migrating命令的实现"></a>cluster setslot migrating命令的实现</h3><p>cluster setslot migrating命令是对于第二个步骤，就是redis-trib向源节点发送该命令，让源节点准备发送槽的count个键值对。</p><p>在clusterState结构里面是使用一个migrating_slots_to数组来记录了当前节点正在迁移至其他节点的槽，也是一个clusterNode数组</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span><span class="token punctuation">(</span><span class="token comment">//...</span>    clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">)</span>clusterState<span class="token punctuation">;</span></code></pre><p>这个与importing_slots_from一样，也是使用索引代表槽，然后对应数组的位置有没有节点，去代表该槽是否正在被发送中，发送给里面对应的clusterNode</p><p>在对集群进行重新分片的时候，会向源节点发送命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">cluster setslots <span class="token operator">&lt;</span>i<span class="token operator">&gt;</span> migrating <span class="token operator">&lt;</span>target_id<span class="token operator">&gt;</span></code></pre><p>i就代表槽的位置，target_id对应目标节点在集群中的runid。</p><p><strong>当源节点收到该命令的时候，就会在migrating_slots_to[i]里保存target_id对应的custerNode节点</strong><br><img src="/2022/04/14/redis-ji-qun/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216901.png" alt="在这里插入图片描述"><br>跟importing_slots_from很类似</p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>前面提到过，如果节点收到一个关于键Key的命令请求，会先去计算这个键属于的是哪个槽，然后看这个槽是不是被委派给当前节点，如果是，就自己进行执行，如果不是就发送MOVED指令，指引客户端去找正确的节点。</p><p>假设，现在槽是委派给当前节点的，<strong>那么当前节点就回去数据库（集群节点的数据库只会使用0号数据库）里找，找的时候会先检查自己的clusterState.migrating_slots_to[i]（i是指定的槽）是否为空，如果为空就代表该槽没有进行转移，去数据库里面找，如果不为空，那么发送一个ASK错误，指引客户端到导入槽i的节点去查找键key</strong>。</p><p><strong>接收到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送自己想要执行的命令</strong>。<br><img src="/2022/04/14/redis-ji-qun/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216902.png" alt="在这里插入图片描述"></p><h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的<strong>REDIS_ASKING标识</strong></p><pre class="language-code" data-language="code"><code class="language-code">def ASKING():#打开REDIS_ASKING标识client.flags |= REDIS_ASKING#向客户端返回OK回复reply("ok")12345</code></pre><p>在一般情况下，客户端向节点发送一个关于槽i的命令，而槽又不是被委派给这个节点的，那么是会返回一个MOVED错误给客户端的，<strong>但如果此时该节点的ckusterState.importing_slots_from[i]显示节点正在导入槽i，而且发来的命令带有REDIS_ASKING标识</strong>，那么节点将破例执行这个关于槽i的命令一次。<br><img src="/2022/04/14/redis-ji-qun/image-20211129180546751.png" alt="image-20211129180546751"><br><strong>这里要注意的是，客户端的REDIS_ASKING标识是一个一次性的标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除，以后的命令都不会带有该标识了</strong></p><h3 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h3><p>ASK错误和MOVED错误都会导致客户端转向，他们的区别如下所示</p><ul><li>MOVED错误<strong>代表槽的负责权已经从一个节点转移到了另一个节点</strong>；在客户端收到关于槽i的MOVED错误之后，<strong>客户端下次的每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点（因为已经建立了套接字连接，而且记录了该键是在之前MOVED错误所指向的节点处）</strong></li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施，在客户端收到关于槽i的ASK错误之后，<strong>客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点</strong>，但这种转向客户端并不会记录下来，所以不会对客户端今后发送关于槽i的命令产生任何的影响，客户端发送请求仍然会请求到目前负责处理槽i的节点，除非ASK、MOVED错误出现。</li></ul><p>MOVED错误的过程<br><img src="/2022/04/14/redis-ji-qun/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216914.png" alt="在这里插入图片描述"><br>ASKING错误的过程<br><img src="/2022/04/14/redis-ji-qun/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216915.png" alt="在这里插入图片描述"></p><h2 id="四-复制与故障转移"><a href="#四-复制与故障转移" class="headerlink" title="四 复制与故障转移"></a>四 复制与故障转移</h2><p>Redis中节点分为主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点；</p><p>当主节点下线时，从节点将成为主节点，替代主节点处理命令请求；下线主节点重新上线时，将成为从节点；</p><p>当从节点开始复制主节点，也会通过消息告诉集群中的其他节点</p><h3 id="4-1设置从节点-CLUSTER-REPLICATE"><a href="#4-1设置从节点-CLUSTER-REPLICATE" class="headerlink" title="4.1设置从节点 CLUSTER REPLICATE "></a>4.1设置从节点 CLUSTER REPLICATE <node_id></node_id></h3><p>CLUSTER REPLICATE <node_id> 让接受到命令的节点设置为从节点， 复制node_id节点；</node_id></p><p>CLUSTER REPLICATE命令的实现入口位于：<strong>cluster.c/clusterCommand</strong> ==&gt; replicate</p><p>clusterCommand函数接受到replicate命令后主要做了一下几件事：</p><ul><li>在自己的clusterState的nodes属性中查找参数的node节点；</li><li>判断当前节点是否可以设置复制。<br>是否是自己复制自己？<br>参数中的node节点是否是从节点？<br>当前节点是否分配了槽？<br>……</li></ul><p>复合要求设置条件后，调用clusterSetMaster函数，clusterSetMaster主要用于修正clusterState中的属性值（可以参考下面贴出的注释）；</p><p> 之后还需要设置当前节点为从节点，代码实现在<strong>clster.c/clusterSetMaster</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将指定的节点n设置成当前节点的master，如果当前节点是master也会转换成slave</span><span class="token keyword">void</span> <span class="token function">clusterSetMaster</span><span class="token punctuation">(</span>clusterNode <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//复制的对象不能是自己</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当前节点没有分配槽</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>numslots <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">nodeIsMaster</span><span class="token punctuation">(</span>myself<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//当前节点是master</span>        <span class="token comment">//将当前节点的CLUSTER_NODE_MASTER和CLUSTER_NODE_MIGRATE_TO取反(因为时slave不可以再MIGRATE_TO)</span>        myself<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>CLUSTER_NODE_MASTER<span class="token operator">|</span>CLUSTER_NODE_MIGRATE_TO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将点钱节点设置为slave</span>        myself<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLUSTER_NODE_SLAVE<span class="token punctuation">;</span>        <span class="token function">clusterCloseAllSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//当前节点不是master</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>slaveof<span class="token punctuation">)</span>            <span class="token comment">//将当前节点从原来的master的slave列表中移除</span>            <span class="token function">clusterNodeRemoveSlave</span><span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>slaveof<span class="token punctuation">,</span>myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//设置当前节点复制指定的节点n</span>    myself<span class="token operator">-&gt;</span>slaveof <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token comment">//给节点n添加当前节点作为slave</span>    <span class="token function">clusterNodeAddSlave</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//复制n的信息</span>    <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>ip<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resetManualFailover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/04/14/redis-ji-qun/image-20211129185032653.png" alt="image-20211129185032653"></p><p><img src="/2022/04/14/redis-ji-qun/image-20211129190657841.png" alt="image-20211129190657841"></p><h3 id="4-2故障检测"><a href="#4-2故障检测" class="headerlink" title="4.2故障检测"></a>4.2故障检测</h3><p>集群中每个节点会定期向其他节点发送PING消息，如果规定时间内没有返回PONG消息，则会将该节点标记为P_FAIL(疑似下线 probable fail)；</p><p><img src="/2022/04/14/redis-ji-qun/image-20211129190723670.png" alt="image-20211129190723670"></p><p>各个节点会相互交换消息，确认各个节点的状态</p><p>当节点A通过消息得知节点B认为节点C疑似下线之后，就会在自己的clusterState.nodes 字典中找到主节点 C 所对应的 clusterNode 结构，将节点B 的下线报告（ failure report ) 添加到节点c的clusterNode 结构的 fail_reports  链表中。</p><p>节点的下线报告结构如下：（记录的就是发出报告的节点指针和上次报告的时间）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterNodeFailReport</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>  <span class="token comment">/* Node reporting the failure condition. */</span>    <span class="token class-name">mstime_t</span> time<span class="token punctuation">;</span>             <span class="token comment">/* Time of the last report from this node. */</span><span class="token punctuation">}</span> clusterNodeFailReport<span class="token punctuation">;</span></code></pre><p><img src="/2022/04/14/redis-ji-qun/image-20211129194942175.png" alt="image-20211129194942175"></p><p>注意这个是保存在7001那里的，前面还有他的ClusterState结构，指向7001保存的7000node相关信息。</p><p>如果某节点发现集群中超过半数已经以上的主节点 将x节点标记为P_FAIL,那么x节点将被标记为FAIL（客观下线），这个节点还会向集群广播x节点的FAIL下线消息，收到消息的节点都会直接把x节点标记为下线</p><h3 id="4-3故障转移"><a href="#4-3故障转移" class="headerlink" title="4.3故障转移"></a>4.3故障转移</h3><p>当一个从节点得知自己复制的master进入FAIL下线状态时，从节点将开始对主节点进行故障转移：</p><ul><li>从slave中选取一个主节点；（通过其他所有负责槽的主节点投票产生，也使用了配置纪元的设置，与选举新的sentinel的方式比较相似，基于Raft算法实现）</li><li>被选中的slave执行 salveof no one命令，成为新的master</li><li>新的master会撤销已下线master的槽指派，将槽指派给自己；</li><li>新的master向集群广播一条PONG消息，告知新的master已经上线；</li><li>新的节点接受命令，故障转移完成；</li></ul><h2 id="五-集群间消息"><a href="#五-集群间消息" class="headerlink" title="五 集群间消息"></a>五 集群间消息</h2><p>集群各节点通过互相发送消息来进行通信， 集群间的消息可以大致分为以下几种：</p><ul><li><p>MEET消息：当节点接受客户端发送的CLUSTER MEET命令时，节点会向其他节点会发送meet消息，请求加入到集群；</p></li><li><p>PING消息：集群中每个节点默认每间隔一秒，会从节点列表中<strong>随机</strong>选举出5个节点，在从这5个节点中选一个最长时间没有通信的，发送PING消息；</p></li><li><p>PONG消息：当节点接受到PING 、MEET消息时，会向发送者回复PONG消息； 节点也可以主动向集群广播PONG消息，通知其他节点更新该节点信息；</p></li><li><p>FAIL消息：当一个主节点判断另个主节点已经下线时，节点会向集群广播一条FAIL消息；</p></li><li><p>PUBLISH消息：当节点接受到一个PUBLISH命令时，节点会立即执行该命令，并向集群广播PUBLISH消息；</p></li></ul><h3 id="5-1消息头"><a href="#5-1消息头" class="headerlink" title="5.1消息头"></a>5.1消息头</h3><p>节点消息都会包裹在一个消息头，消息头的定义位于cluster.h/clusterMsg</p><p>消息头中clusterMsgData 联合体 （刚好对应几种消息类型）记录消息的正文；</p><h3 id="5-2-MEET-PING-PONG消息的实现"><a href="#5-2-MEET-PING-PONG消息的实现" class="headerlink" title="5.2 MEET PING PONG消息的实现"></a>5.2 MEET PING PONG消息的实现</h3><p>Redis集群中个节点是通过GOSSIP协议来交换各个节点状态信息，gossip协议由MEET、PING、PONG三种消息组成的：</p><p>因为MEET 、PING、PONG是相同的消息体，所以节点是通过消息头中的type属性来区分PING、PONG、MEET消息的；</p><p>发送pong 、ping、meet消息的入口位于cluster.c/clusterCron ==&gt;cluster.c/clusterSendPing； （ping、pong、meet消费发送都是通过clusterSendPing函数实现的）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//向指定的链接link(对应于节点)发送PIGNG或者PONG数据包,确保要加入足够的gossip信息</span><span class="token keyword">void</span> <span class="token function">clusterSendPing</span><span class="token punctuation">(</span>clusterLink <span class="token operator">*</span>link<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    clusterMsg <span class="token operator">*</span>hdr<span class="token punctuation">;</span>    <span class="token comment">//已经加入的gossip目标</span>    <span class="token keyword">int</span> gossipcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Number of gossip sections added so far. */</span>    <span class="token comment">//需要加入的gossip目标数</span>    <span class="token keyword">int</span> wanted<span class="token punctuation">;</span> <span class="token comment">/* Number of gossip sections we want to append if possible. */</span>    <span class="token keyword">int</span> totlen<span class="token punctuation">;</span> <span class="token comment">/* Total packet length. */</span>    <span class="token comment">/* freshnodes is the max number of nodes we can hope to append at all:     * nodes available minus two (ourself and the node we are sending the     * message to). However practically there may be less valid nodes since     * nodes in handshake state, disconnected, are not considered. */</span>    <span class="token comment">//除去自身和发送目标节点之外的节点数</span>    <span class="token keyword">int</span> freshnodes <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">/* How many gossip sections we want to add? 1/10 of the number of nodes     * and anyway at least 3. Why 1/10?     *     * If we have N masters, with N/10 entries, and we consider that in     * node_timeout we exchange with each other node at least 4 packets     * (we ping in the worst case in node_timeout/2 time, and we also     * receive two pings from the host), we have a total of 8 packets     * in the node_timeout*2 failure reports validity time. So we have     * that, for a single PFAIL node, we can expect to receive the following     * number of failure reports (in the specified window of time):     *     * PROB * GOSSIP_ENTRIES_PER_PACKET * TOTAL_PACKETS:     *     * PROB = probability of being featured in a single gossip entry,     *        which is 1 / NUM_OF_NODES.     * ENTRIES = 10.     * TOTAL_PACKETS = 2 * 4 * NUM_OF_MASTERS.     *     * If we assume we have just masters (so num of nodes and num of masters     * is the same), with 1/10 we always get over the majority, and specifically     * 80% of the number of nodes, to account for many masters failing at the     * same time.     *     * Since we have non-voting slaves that lower the probability of an entry     * to feature our node, we set the number of entries per packet as     * 10% of the total nodes we have. */</span>    <span class="token comment">//希望添加的gossip目标数是节点数除以十,且至少是3</span>    wanted <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wanted <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> wanted <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wanted <span class="token operator">&gt;</span> freshnodes<span class="token punctuation">)</span> wanted <span class="token operator">=</span> freshnodes<span class="token punctuation">;</span>    <span class="token comment">/* Include all the nodes in PFAIL state, so that failure reports are     * faster to propagate to go from PFAIL to FAIL state. */</span>    <span class="token comment">//对于疑似下线的节点要及时发送ping测试连通性</span>    <span class="token keyword">int</span> pfail_wanted <span class="token operator">=</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>stats_pfail_nodes<span class="token punctuation">;</span>    <span class="token comment">/* Compute the maximum totlen to allocate our buffer. We'll fix the totlen     * later according to the number of gossip sections we really were able     * to put inside the packet. */</span>    totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> clusterMsgData<span class="token punctuation">)</span><span class="token punctuation">;</span>    totlen <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsgDataGossip<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>wanted<span class="token operator">+</span>pfail_wanted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Note: clusterBuildMessageHdr() expects the buffer to be always at least     * sizeof(clusterMsg) or more. */</span>    <span class="token comment">//消息长度太短的情况需要补全</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totlen <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token punctuation">)</span> totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr <span class="token operator">=</span> <span class="token punctuation">(</span>clusterMsg<span class="token operator">*</span><span class="token punctuation">)</span> buf<span class="token punctuation">;</span>    <span class="token comment">/* Populate the header. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>link<span class="token operator">-&gt;</span>node <span class="token operator">&amp;&amp;</span> type <span class="token operator">==</span> CLUSTERMSG_TYPE_PING<span class="token punctuation">)</span>        link<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>ping_sent <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">clusterBuildMessageHdr</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Populate the gossip fields */</span>    <span class="token keyword">int</span> maxiterations <span class="token operator">=</span> wanted<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>freshnodes <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gossipcount <span class="token operator">&lt;</span> wanted <span class="token operator">&amp;&amp;</span> maxiterations<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//todo:这里使用的随机算法其实会比较耗时,为什么不直接遍历整个词典呢?</span>        dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        clusterNode <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Don't include this node: the whole packet header is about us         * already, so we just gossip about other nodes. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">==</span> myself<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* PFAIL nodes will be added later. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_PFAIL<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* In the gossip section don't include:         * 1) Nodes in HANDSHAKE state.         * 3) Nodes with the NOADDR flag set.         * 4) Disconnected nodes if they don't have configured slots.         */</span>        <span class="token comment">//对于在HANDSHAKE的节点,NOADDR的节点,断开连接的节点就不用gossip了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLUSTER_NODE_HANDSHAKE<span class="token operator">|</span>CLUSTER_NODE_NOADDR<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>link <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> this<span class="token operator">-&gt;</span>numslots <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            freshnodes<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">/* Technically not correct, but saves CPU. */</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Do not add a node we already have. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clusterNodeIsInGossipSection</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>this<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* Add it */</span>        <span class="token function">clusterSetGossipEntry</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        freshnodes<span class="token operator">--</span><span class="token punctuation">;</span>        gossipcount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* If there are PFAIL nodes, add them at the end. */</span>    <span class="token comment">//最后添加哪些疑似下线的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pfail_wanted<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dictIterator <span class="token operator">*</span>di<span class="token punctuation">;</span>        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pfail_wanted <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            clusterNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_HANDSHAKE<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_NOADDR<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_PFAIL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">clusterSetGossipEntry</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            freshnodes<span class="token operator">--</span><span class="token punctuation">;</span>            gossipcount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">/* We take the count of the slots we allocated, since the             * PFAIL stats may not match perfectly with the current number             * of PFAIL nodes. */</span>            pfail_wanted<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Ready to send... fix the totlen field and queue the message in the     * output buffer. */</span>    <span class="token comment">//准备发送阶段,在buf中排队</span>    totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> clusterMsgData<span class="token punctuation">)</span><span class="token punctuation">;</span>    totlen <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsgDataGossip<span class="token punctuation">)</span><span class="token operator">*</span>gossipcount<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr<span class="token operator">-&gt;</span>count <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>gossipcount<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr<span class="token operator">-&gt;</span>totlen <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">clusterSendMessage</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当 接 收 者 收 到 MEET、 PING、 PONG 消 息 时， 接 收 者 会 访 问 消 息 正 文 中 的 两 个clusterMsgDataGossip 结构， 并根据自己是否认识 clusterMsgDataGossip 结构中记录的被选中节点来选择进行哪种操作：</p><ul><li>如果被选中节点不存在于接收者的已知节点列表， 那么说明接收者是第一次接触到被选中节点， 接收者将根据结构中记录的 IP 地址和端口号等信息， 与被选中节点进行握手。</li><li>如果被选中节点已经存在于接收者的已知节点列表， 那么说明接收者之前已经与被选中节点进行过接触， 接收者将根据 clusterMsgDataGossip 结构记录的信息，对被选中节点所对应的 clusterNode 结构进行更新。  </li></ul><h3 id="5-3FAIL消息的实现"><a href="#5-3FAIL消息的实现" class="headerlink" title="5.3FAIL消息的实现"></a>5.3FAIL消息的实现</h3><p>在集群节点数量较多时，使用Gossip协议来传播下线消息 会是下线消息传播延时；</p><p>而发送FAIL消息可以让集群中所有节点知道节点下线，从而尽快判断集群是否下线，对下线主节点执行故障转移操作；</p><p>FAIL消息体的定义位于cluster.h/clusterMsgDataFail</p><p> 发送FAIL消息的入口位于cluster.c/clusterSendFail</p><h3 id="5-4PUBLISH消息的实现"><a href="#5-4PUBLISH消息的实现" class="headerlink" title="5.4PUBLISH消息的实现"></a>5.4PUBLISH消息的实现</h3><p><code>PUBLISH&nbsp;&lt;channel&gt;&nbsp;&lt;msg&gt;</code></p><p>当某节点接受到PUBLISH 消息，不仅会向自己的channel发送msg消息，还会向集群广播一条PUBLISH消息，是集群中所有节点都对于自己的channel发送一条msg消息；</p><p>publish消息的消息体定义位于cluster.h/clusterMsgDataPublish</p><pre class="language-c#" data-language="c#"><code class="language-c#">typedef struct {    uint32_t channel_len;    uint32_t message_len;    //八字节是为了对齐,实际长度是保存的内容决定的    unsigned char bulk_data[8]; /* 8 bytes just as placeholder. */} clusterMsgDataPublish;</code></pre><p>bulk_data的0到channel_len-1字节保存的是channel，channel_len到channel_len+message_len-1字节保存的是message的内容。</p><p>对于消息<code>PUBLISH "news.it" "hello"</code>，保存的结构如图：</p><p><img src="/2022/04/14/redis-ji-qun/image-20211129214514368.png" alt="image-20211129214514368"></p><p>处理publish命令的入口位于<code>pubsub.c/publishCommand ==&gt;cluster.c/clusterPropagatePublish==&gt;cluster.c/clusterSendPublish</code></p><p>为了保证所有的节点通过发送和接受消息进行通信，所以客户端不会直接给所有的节点都发送PUBLISH（好像其实客户端也没有所有节点的信息，必须要先访问某个节点得知所有节点的信息之后才能向所有的节点都发送PUBLISH）</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EC-Cache: Load-Balanced, Low-Latency Cluster Caching with Online Erasure Coding,osdi’16</title>
      <link href="/2022/04/12/reading-ec-cache-load-balanced-low-latency-cluster-caching-with-online-erasure-coding-osdi-16/"/>
      <url>/2022/04/12/reading-ec-cache-load-balanced-low-latency-cluster-caching-with-online-erasure-coding-osdi-16/</url>
      
        <content type="html"><![CDATA[<p><em>这其实是一个<strong>读</strong>占大多数的系统</em></p><ul><li>实际上小文件占用磁盘空间不是很大，大文件读的占比更多</li></ul><blockquote><p>Large Object Reads are Prevalent</p><p>only 7% (11%) of the reads are smaller than 1 (10) MB, but their total size in terms of storage usage is miniscule.</p><p>Furthermore, 28% of the objects are less than 100 MB in size with less than 5% storage footprint. </p></blockquote><ul><li><p>小文件</p><blockquote><p>a small fraction of the objects are highly popular</p></blockquote></li></ul><p>网络分布不是很均衡</p><p>突发高流量的情况很常见</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>overleaf guide</title>
      <link href="/2022/04/08/overleaf-guide/"/>
      <url>/2022/04/08/overleaf-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="Overleaf-指南：30-分钟-LaTeX-入门"><a href="#Overleaf-指南：30-分钟-LaTeX-入门" class="headerlink" title="Overleaf 指南：30 分钟 LaTeX 入门"></a>Overleaf 指南：30 分钟 LaTeX 入门</h1><p>本文是对 Overleaf 提供的 <a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes">Learn LaTeX in 30 minutes</a> （30 分钟 LaTeX 入门指南）的中文翻译。</p><p>在这份指南中，我们希望给你关于 \LaTeXLATEX 的首个介绍。这份指南不需要你在之前有任何关于 \LaTeXLATEX 的知识，跟随这份指南你将完成你的第一份 \LaTeXLATEX 文档，并将对 \LaTeXLATEX 提供的一些基本功能有很好的了解。</p><p>大纲 [<a href="https://imztj.cn/?p=3073#">隐藏</a>]</p><ul><li><a href="https://imztj.cn/?p=3073#_LaTeX">1 什么是 LaTeX</a></li><li><a href="https://imztj.cn/?p=3073#_LaTeX-2">2 为什么要学习 LaTeX</a></li><li><a href="https://imztj.cn/?p=3073#_LaTeX-3">3 编写你的第一段 LaTeX</a></li><li><a href="https://imztj.cn/?p=3073#i">4 文档的序言</a></li><li><a href="https://imztj.cn/?p=3073#i-2">5 添加标题、作者和日期</a></li><li><a href="https://imztj.cn/?p=3073#i-3">6 添加注释</a></li><li><a href="https://imztj.cn/?p=3073#i-4">7 加粗、斜体和下划线</a></li><li>8 添加图片<ul><li><a href="https://imztj.cn/?p=3073#i-6">8.1 标题、标签和引用</a></li></ul></li><li>9 在 LaTeX 中创建列表<ul><li><a href="https://imztj.cn/?p=3073#i-7">9.1 无序列表</a></li><li><a href="https://imztj.cn/?p=3073#i-8">9.2 有序列表</a></li></ul></li><li><a href="https://imztj.cn/?p=3073#_LaTeX-5">10 在 LaTeX 中添加数学表达式</a></li><li>11 基本格式<ul><li><a href="https://imztj.cn/?p=3073#i-10">11.1 概要</a></li><li><a href="https://imztj.cn/?p=3073#i-11">11.2 段落和新行</a></li></ul></li><li><a href="https://imztj.cn/?p=3073#i-12">12 章节和分段</a></li><li>13 创建表格<ul><li><a href="https://imztj.cn/?p=3073#_LaTeX-6">13.1 在 LaTeX 中创建一个简单的表格</a></li><li><a href="https://imztj.cn/?p=3073#i-14">13.2 添加边框</a></li><li><a href="https://imztj.cn/?p=3073#i-15">13.3 标题、标签和引用</a></li></ul></li><li><a href="https://imztj.cn/?p=3073#i-16">14 添加目录</a></li><li><a href="https://imztj.cn/?p=3073#i-17">15 下载你完成了的文档</a></li></ul><h2 id="什么是-LaTeX"><a href="#什么是-LaTeX" class="headerlink" title="什么是 LaTeX"></a>什么是 LaTeX</h2><p>\LaTeXLATEX（发音为 <em>LAY-tek</em> 或 <em>LAH-tek</em>）是一个用于创建具有专业外观的文档的工具。它基于所见即所得的思想，这意味着写作者只需要关注文档的内容，而计算机负责将其格式化。用户不再需要像 Microsoft Word 或 LibreOffice Writer 中那样，在页面上用空格来控制格式，而是只需要输入纯文本，让 \LaTeXLATEX 处理剩下一切。</p><h2 id="为什么要学习-LaTeX"><a href="#为什么要学习-LaTeX" class="headerlink" title="为什么要学习 LaTeX"></a>为什么要学习 LaTeX</h2><p>\LaTeXLATEX 被广泛应用于科学文档、书籍以及许多其他出版物。它不仅可以创建精美的排版文档，而且还使得用户可以很快速地处理复杂的排版问题，比如输入数学公式、创建目录、管理引用、创建书目、保持布局一致等等。由于可用的开源软件包数量众多（稍后会详细介绍），因此 \LaTeXLATEX 有无限的可能性。这些软件包赋予了用户更多的能力，例如添加脚注，绘制原理图，创建表格等。<br>人们使用 \LaTeXLATE​X 的最重要原因之一就是它分离了文档的内容与样式。这意味着你只需要编写文档的内容，我们就可以轻松更改其外观。同样，你也可以创建一个文档模板，用它来统一许多不同文档的外观，这样学术期刊可以创建投稿模板。这些模板具有预制的布局，只需要往里面添加内容即可。实际上，\LaTeXLATE​X 有数百种模板，覆盖从简历到幻灯片的所有内容。</p><h2 id="编写你的第一段-LaTeX"><a href="#编写你的第一段-LaTeX" class="headerlink" title="编写你的第一段 LaTeX"></a>编写你的第一段 LaTeX</h2><p>第一步是创建一个新的 \LaTeXLATEX 项目。你可以在自己的电脑上创建 <code>.tex</code> 文件，也可以 <a href="https://www.overleaf.com/learn/Creating_a_document_in_Overleaf">在 Overleaf 中启动新项目</a>。让我们从最简单的示例开始：</p><pre class="language-tex" data-language="tex"><code class="language-tex">\documentclass{article}\begin{document}First document. This is a simple example, with noextra parameters or packages included.\end{document}</code></pre><p>Copy</p><p><img src="/2022/04/08/overleaf-guide/20200221204925.png" alt="img"></p><p>可以看到，\LaTeXLATEX 已经对文本进行了格式化（如，首行缩进）。下面我们仔细看一下上面这段代码每个部分的功能。</p><p>代码的第一行声明了文档的类型，称为 *类 (class)*。类控制文档的整体外观，不同类型的文档需要选择不同的类，比如，简历与论文需要不同的类。在这个例子中，类是 <code>article</code>，是最简单和最常见的 \LaTeXLATEX 类。其他类型的文档可能需要使用不同的类，例如 <strong>book</strong> 或 <strong>report</strong>。</p><p>然后，在 <code>\begin {document}</code> 和 <code>\end {document}</code> 这两个标记之间写入文档内容。这部分就是文档的 *主体 (body)*，你可以在此处开始编写和更改文本。要在 PDF 中查看更改的结果，必须首先编译文档。在 Overleaf 中只需单击 <strong>重新编译（Recompile）</strong>。还可以单击重新编译按钮旁边的小箭头，并将 “自动编译” 设置为 “开”，这样编辑文件时项目将会自动重新编译。</p><p>如果你使用的是文本编辑器，例如 gedit、emacs、vim、sublime、记事本等，就必须手动编译文档。编译文档的命令是 <code>pdflatex &lt;your document&gt;</code>。更多关于编译的信息请 <a href="https://en.wikibooks.org/wiki/LaTeX/Basics#Compilation">参见此处</a>。</p><p>如果你使用的是专用的 LaTeX 编辑器（例如 TeXmaker 或 TeXworks），也只需单击 “重新编译” 按钮。如果不确定位置在哪里，请查阅程序文档。</p><p>现在我们已经了解了如何向我们的文档中添加内容，下一步就是撰写标题。为此，我们必须讲一下文档的 <strong>序言 (preamble)</strong></p><h2 id="文档的序言"><a href="#文档的序言" class="headerlink" title="文档的序言"></a>文档的序言</h2><p>在上一个示例中，文本是在 <code>\begin {document}</code> 命令之后输入的。在这个命令之前 <code>.tex</code> 文件中的所有内容都称为 **序言 (preamble)**。在序言中，可以定义要编写的文档的类型，要编写的语言，要使用的包（稍后会详细介绍）和其他的元素。例如，普通文档的序言如下所示：</p><pre class="language-tex" data-language="tex"><code class="language-tex">\documentclass[12pt, letterpaper]{article}\usepackage[utf8]{inputenc}</code></pre><p>Copy</p><p>下面我们详细解释一下这两行的作用。</p><pre class="language-none"><code class="language-none">\documentclass[12pt, letterpaper]{article}</code></pre><p>如前所述，这条命令定义了文档的类型。跟上个示例不一样的是，方括号中还有两个参数，这些参数必须用逗号分隔。在这个示例中，这两个额外的参数分别设置字体大小（<code>12pt</code>）和纸张大小（<code>letterpaper</code>）。当然，可以使用其他字体大小（<code>9pt</code>，<code>11pt</code>，<code>12pt</code> 等等），但是如果未指定，则默认的字体大小为 <code>10pt</code>。纸张尺寸还可以设置为 <code>a4paper</code> 和 <code>Legalpaper</code>；更多有关 <a href="https://www.overleaf.com/learn/Page_size_and_margins">页面大小和边距</a> 的信息，可以参阅这篇文章。</p><pre class="language-none"><code class="language-none">\usepackage[utf8]{inputenc}</code></pre><p>这行命令指定了文档的编码，可以省略或更改为其他编码，但建议使用 utf-8。除非特别需要其他编码，否则请将此行添加到序言中。</p><h2 id="添加标题、作者和日期"><a href="#添加标题、作者和日期" class="headerlink" title="添加标题、作者和日期"></a>添加标题、作者和日期</h2><p>要将标题、作者和日期添加到文档中，就必须 <strong>在序言中</strong>（不是文章的主体中）添加下面三行。它们是：</p><p><code>\title{First document}</code><br>这是文章的标题。</p><p><code>\author{Hubert Farnsworth}</code><br>在此处输入作者的姓名。</p><p><code>\thanks{funded by the Overleaf team}</code><br>在 <code>author</code> 命令的大括号里添加这条命令，可以添加上标和脚注。如果你需要在文章中感谢一个机构，这个功能将非常有用。</p><p><code>\date{February 2014}</code><br>你可以手动输入日期，或使用 <code>\today</code> 命令，以便在编译文档时自动更新日期。</p><p>现在，序言部分应该长这样：</p><pre class="language-tex" data-language="tex"><code class="language-tex">\documentclass[12pt, letterpaper, twoside]{article}\usepackage[utf8]{inputenc}\title{First document}\author{Hubert Farnsworth \thanks{funded by the Overleaf team}}\date{February 2017}</code></pre><p>Copy</p><p>现在，你已经为文档指定了标题、作者和日期，现在可以使用 <code>\maketitle</code> 命令在文档上打印这些信息。这条命令应该写在文档 <strong>主体 (body)</strong> 中你想要打印标题的位置。</p><pre class="language-tex" data-language="tex"><code class="language-tex">\begin{document}\maketitleWe have now added a title, author and date to our first \LaTeX{} document!\end{document}</code></pre><p>Copy</p><p><img src="/2022/04/08/overleaf-guide/20200221221110.png" alt="img"></p><h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>与其他代码一样，注释是非常有用的。注释文本不会被打印，也不会以任何方式影响文档。在调试时，注释文本对于组织工作，做笔记或注释行 / 节很有用。要在 \LaTeXLATEX 中添加注释，只需在行首写一个％符号，如下所示：</p><pre class="language-tex" data-language="tex"><code class="language-tex">\begin{document}\maketitleWe have now added a title, author and date to our first \LaTeX{} document!% This line here is a comment. It will not be printed in the document.\end{document}</code></pre><p>Copy</p><h2 id="加粗、斜体和下划线"><a href="#加粗、斜体和下划线" class="headerlink" title="加粗、斜体和下划线"></a>加粗、斜体和下划线</h2><p>现在让我们来看一些简单的格式化命令。</p><ul><li><strong>加粗</strong>：在 \LaTeXLATEX 中，加粗字体使用 <code>\textbf{}</code> 命令。</li><li><em>斜体</em>：在 \LaTeXLATEX 中，斜体使用 <code>\textit{}</code> 命令。</li><li>下划线：在 \LaTeXLATEX 中，下划线使用 <code>\underline{}</code> 命令。</li></ul><p>下面是示例：</p><pre class="language-tex" data-language="tex"><code class="language-tex">Some of the \textbf{greatest}discoveries in \underline{science}were made by \textbf{\textit{accident}}.</code></pre><p>Copy</p><p><img src="/2022/04/08/overleaf-guide/20200222143339.png" alt="img"></p><p>另一个非常有用的命令是 <code>\emph{...}</code> 命令。 <code>\emph</code> 是强调文本命令，她完成的操作取决于上下文：在普通文本中，强调的文本是斜体，但是如果在斜体文本中使用，则将文字变为普通文本，请参见以下示例：</p><pre class="language-tex" data-language="tex"><code class="language-tex">Some of the greatest \emph{discoveries}in sciencewere made by accident.\textit{Some of the greatest \emph{discoveries}in sciencewere made by accident.}\textbf{Some of the greatest \emph{discoveries}in sciencewere made by accident.}</code></pre><p>Copy</p><p><img src="/2022/04/08/overleaf-guide/20200222143939.png" alt="img"></p><p>不过，有一些包（例如 <a href="https://www.overleaf.com/learn/Beamer">Beamer</a>），会改变 <code>\emph</code> 命令的作用。</p><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>现在我们来看，如何向 \LaTeXLATEX 文档添加图片。在 Overleaf 中，你需要首先上传图片。</p><p>下面是一个如何添加图片的示例：</p><pre class="language-tex" data-language="tex"><code class="language-tex">\documentclass{article}\usepackage{graphicx}\graphicspath{{images/} }\begin{document}The universe is immense and it seems to be homogeneous,in a large scale, everywhere we look at.\includegraphics{universe}There's a picture of a galaxy above\end{document}</code></pre><p>Copy</p><p><img src="/2022/04/08/overleaf-guide/20200222145159.png" alt="img"></p><p>\LaTeXLATEX 本身不能管理图像，因此需要使用一个 *包 (package)*。包可用于更改 \LaTeXLATEX 文档的默认外观，或实现更多功能。在这个例子中，要实现在文档中添加图片，因此需要使用 <code>graphicx</code> 包。<code>graphicx</code> 包提供了新的命令 <code>\includegraphics{...}</code> 和 <code>\graphicspath{...}</code>。要使用 <code>graphicx</code> 软件包，要现在序言中添加：<code>\usepackage{graphicx}</code></p><p>`\graphicspath</p>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make a perfect pre</title>
      <link href="/2022/04/08/make-a-perfect-pre/"/>
      <url>/2022/04/08/make-a-perfect-pre/</url>
      
        <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>演讲者不自信<ul><li>肢体语言不协调</li><li>说话声音比较小</li><li>直接照着ppt朗读</li></ul></li><li>整体结构不够清晰<ul><li>没有明确的逻辑</li><li>哪一段在介绍背景，方案等</li><li>没有记忆点</li><li>零散信息堆积</li></ul></li><li>可信度低<ul><li>尤其是需要表达观点的pre，需要<strong>论据和解释</strong></li><li>整体信息量不足，装饰表演内容过多</li><li>无关信息过多</li></ul></li><li>无聊<ul><li>和前面的原因有关</li><li>只有讲话和ppt，没有表演的元素</li><li>准备了太多信息，有些不是很必要的东西</li></ul></li><li>幻灯片设计<ul><li>字太多</li><li>太花哨</li><li>模板不合适，一看就知道是套模板</li></ul></li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>形式根据目标决定</p><h3 id="设计结构"><a href="#设计结构" class="headerlink" title="设计结构"></a>设计结构</h3><p>开头$\rightarrow$问题$\rightarrow$解决方案or分析结果$\rightarrow$总结</p><p>每个板块重点罗列</p><h3 id="文稿"><a href="#文稿" class="headerlink" title="文稿"></a>文稿</h3><p>可以是大纲，也可以是稿子</p><h3 id="制作幻灯片"><a href="#制作幻灯片" class="headerlink" title="制作幻灯片"></a>制作幻灯片</h3><p>辅助作用，提炼后的重点</p><p>这样才不会遗漏重点</p><h3 id="练习、删改"><a href="#练习、删改" class="headerlink" title="练习、删改"></a>练习、删改</h3><p>在朋友面前试讲</p><h2 id="明确目标-1"><a href="#明确目标-1" class="headerlink" title="明确目标"></a>明确目标</h2><ol><li>希望通过pre达到的目的</li><li>目标观众是谁<ul><li>根据对象决定语言风格和方式</li></ul></li></ol><h2 id="设计结构-1"><a href="#设计结构-1" class="headerlink" title="设计结构"></a>设计结构</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ol><li>背景介绍</li><li>概述主要内容</li><li>共同的目标<ul><li>和观众的共同的目标，吸引观众注意力，让观众有期待</li></ul></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="阐述需要解决的问题"><a href="#阐述需要解决的问题" class="headerlink" title="阐述需要解决的问题"></a>阐述需要解决的问题</h4><p>现象，疑问，人，事，物，观点</p><h4 id="阐述问题的思路"><a href="#阐述问题的思路" class="headerlink" title="阐述问题的思路"></a>阐述问题的思路</h4><ol><li>具体案例说明问题</li><li>通过对比说明问题<ul><li>介绍产品（有很多同类或者说有不同的环境都可以这样对比）</li></ul></li><li>列举问题<ul><li>问题数量很多，每个问题都很重要，不需要突出</li></ul></li></ol><blockquote><h4 id="为什么讲“问题”"><a href="#为什么讲“问题”" class="headerlink" title="为什么讲“问题”"></a>为什么讲“问题”</h4><p>一定是要解决问题，（一般是改善）才会做pre</p><blockquote><p>Ex：面试时注意力放在公司<strong>需要的人才特点</strong></p><p>我知道你们需要……能力的人，我觉得我正好具有这些能力，因为……</p><p>挖掘问题$\rightarrow$解决问题</p></blockquote><ul><li>问题/矛盾/冲突/需求</li><li>铺垫，吸引注意力</li><li>衬托后续研究/方案的建设性</li></ul></blockquote><h3 id="分析解决"><a href="#分析解决" class="headerlink" title="分析解决"></a>分析解决</h3><ol><li>输出观点</li><li>分析过程</li><li>研究成果</li><li>未来建议</li></ol><p>一个<strong>展示</strong>和<strong>证明</strong>的过程</p><h4 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h4><ol><li>论点一：论据。。。</li><li>论点二：论据。。。</li><li>。。。</li></ol><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>观众理解并相信你</p><h5 id="增强可信度？"><a href="#增强可信度？" class="headerlink" title="增强可信度？"></a>增强可信度？</h5><ol><li>尽量引用权威数据</li><li>提高语言逻辑性<ul><li>因果</li><li>转折</li><li>并列</li><li><strong>递进</strong>：从浅层到深，牵着对方的手理解，更有情感上的影响力，最容易接受<ul><li>读者：害怕长胖的女生</li><li>零食的范围</li><li>零食没有绝对好坏之分</li><li>吃零食会不会长胖</li><li><strong>人与零食的关系是既能拥有零食自由，也能保持身心健康的平衡关系</strong></li></ul></li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>收尾最有印象</p><ol><li>梳理一遍主要内容</li><li>落实目标，首尾呼应</li></ol><h3 id="准备讲稿"><a href="#准备讲稿" class="headerlink" title="准备讲稿"></a>准备讲稿</h3><p>听起来要像是即兴说的，不管有没有提前准备全套</p><p>语言风格：自然，简单，口语化，生动，短句，俗语，互动，对话感，参与感$\rightarrow$沉浸式体验</p><h3 id="制作幻灯片-1"><a href="#制作幻灯片-1" class="headerlink" title="制作幻灯片"></a>制作幻灯片</h3><p>设计结构和ppt呼应，提炼要点决定幻灯片风格排版</p><p>最好别套模板。。。</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ol><li>讲台上一般是深色，但是介绍项目的ppt一般是浅色背景（白色最佳），拒绝花里胡哨</li><li>只保留关键字，多的都不要</li><li>视觉优先，只要能用图表，图标，就别用文字（注意图片风格统一）</li><li>*（不要让观众阅读ppt，不然你讲有什么用呢）<strong>排版是为了快速检索信息。</strong>如果必须要很多文字，学会使用加粗，提行，字体，标题，颜色</li></ol><h3 id="练习删减修改"><a href="#练习删减修改" class="headerlink" title="练习删减修改"></a>练习删减修改</h3><h2 id="English-version"><a href="#English-version" class="headerlink" title="English version"></a>English version</h2><h3 id="English-speaking"><a href="#English-speaking" class="headerlink" title="English speaking"></a>English speaking</h3><p>accent</p><ul><li><p>Clear is okay.</p></li><li><p>Confident.</p></li><li><p>No complex grammar or structure.</p></li></ul><h3 id="Delivering-style"><a href="#Delivering-style" class="headerlink" title="Delivering style"></a>Delivering style</h3><p>performance(not the results)</p><ul><li>Eye contact</li><li>body movement</li><li>Gesture </li><li>voice</li></ul><p>Storytelling(for emotional impact)</p><ul><li>Real-life story</li><li>Personal story</li></ul><h3 id="Avoid-bias"><a href="#Avoid-bias" class="headerlink" title="Avoid bias"></a>Avoid bias</h3><p>Cultural dif(races, skin colors, taboos in different culture)</p><blockquote><p>Policeman/policewoman$\rightarrow$police officer</p><p>no gender-bias and neutral</p></blockquote><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><ol><li>Pronounciation</li><li>Performance </li><li>Respect </li></ol><p>Notes after watching <a href="https://video.weibo.com/show?fid=1034:4662487312957449&amp;mark_id=999_reallog_mark_ad:999%7CWeiboADNatural">Ericaliga’s 如何做好Presentation</a></p>]]></content>
      
      
      <categories>
          
          <category> pre </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文写作分享1</title>
      <link href="/2022/04/08/lun-wen-xie-zuo-fen-xiang-1/"/>
      <url>/2022/04/08/lun-wen-xie-zuo-fen-xiang-1/</url>
      
        <content type="html"><![CDATA[<h2 id="端正态度"><a href="#端正态度" class="headerlink" title="端正态度"></a>端正态度</h2><h3 id="克服写作障碍"><a href="#克服写作障碍" class="headerlink" title="克服写作障碍"></a>克服写作障碍</h3><ul><li>主要是逻辑，而不是语言</li><li>内容比形式更重要</li></ul><h3 id="什么时候开始写"><a href="#什么时候开始写" class="headerlink" title="什么时候开始写"></a>什么时候开始写</h3><p>越早越好，准备时间越长越有时间修改</p><h2 id="论文组织形式"><a href="#论文组织形式" class="headerlink" title="论文组织形式"></a>论文组织形式</h2><h3 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h3><p>Abstract, intro, background, design, implementation, eval, related work, conclusion, references</p><h3 id="一些不同点"><a href="#一些不同点" class="headerlink" title="一些不同点"></a>一些不同点</h3><ul><li><p>background可以与motivation、problem statement、related work按需结合起来</p></li><li><p>implementation可以单独成为一个章节，也可以是design或者eval的一部分</p><ul><li>一般来说只有实现中有非常多过人之处，design中的实现不是很清楚就放在这</li></ul></li><li><p>部分paper还会有case study章节，介绍系统的使用情况</p><ul><li>写好了就相当出彩，抽象的意义可能不是这么大，在具体的case中才会有作用</li></ul></li><li><p>部分paper还会有discussion 章节，讨论文章对未来的影响</p><ul><li>可以提升的地方就在这里找</li></ul></li></ul><blockquote><p>性能上面的提升并不是很重要，其实我们做的事application的system，需要的是自己做出来的对于未来研究的影响</p></blockquote><h2 id="如何开始写作"><a href="#如何开始写作" class="headerlink" title="如何开始写作"></a>如何开始写作</h2><h3 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h3><p>先找几篇相关性强的和最近几年影响力大的文章（在a会议找），认真阅读构建背景体系</p><p>一般5篇就够了，保证自己不要偏题</p><h3 id="storyline-keywords"><a href="#storyline-keywords" class="headerlink" title="storyline+keywords"></a>storyline+keywords</h3><p>一个提纲，keywords之间要有联系，如何联系起来？</p><ul><li>大问题<ul><li>漏斗形</li><li>开篇都是大问题，慢慢缩小到自己的点</li></ul></li><li>小问题</li><li>已有解决方案和不足之处$\rightarrow$潜在的baseline和related work<ul><li>说出别人的好处再说不足</li><li>如何set up a goal</li><li>开篇四句话之内说出自己想做什么</li></ul></li><li>本论文的observation+principle+<strong>novolty</strong><ul><li>说自己花了多少时间没有用，主要是贡献和工作量</li><li>新还得有意义，并不只是新就好</li></ul></li><li>主要的技术贡献点$\rightarrow$design部分的构思<ul><li>逻辑flow在里面，并列还是递进</li></ul></li><li>结果展示$\rightarrow$eval<ul><li>需要知道的不是快了多少，而是快在哪里，哪些东西产生了作用</li><li>自己的亮点和最后作用最大的点要统一</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell输出重定向</title>
      <link href="/2022/04/04/shell-shu-chu-chong-ding-xiang/"/>
      <url>/2022/04/04/shell-shu-chu-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="shell-1-gt-amp-2-2-gt-amp-1-amp-gt-filename重定向的含义和区别"><a href="#shell-1-gt-amp-2-2-gt-amp-1-amp-gt-filename重定向的含义和区别" class="headerlink" title="shell 1>&amp;2 2>&amp;1 &amp;>filename重定向的含义和区别:"></a>shell 1&gt;&amp;2 2&gt;&amp;1 &amp;&gt;filename重定向的含义和区别:</h3><ol><li>当初在shell中, 看到”&gt;&amp;1″和”&gt;&amp;2″始终不明白什么意思.经过在网上的搜索得以解惑.其实这是两种输出.</li><li>在 shell 程式中，最常使用的 FD (file descriptor) 大概有三个, 分别是:</li></ol><p><strong>0 是一个文件描述符，表示标准输入(stdin)</strong></p><p><strong>1 是一个文件描述符，表示标准输出(stdout)</strong></p><p><strong>2 是一个文件描述符，表示标准错误(stderr)</strong></p><ol><li>在标准情况下, 这些FD分别跟如下设备关联:</li></ol><p>stdin(0): keyboard 键盘输入,并返回在前端</p><p>stdout(1): monitor 正确返回值 输出到前端</p><p>stderr(2): monitor 错误返回值 输出到前端</p><h4 id="举例说明吧"><a href="#举例说明吧" class="headerlink" title="举例说明吧:"></a>举例说明吧:</h4><p>当前目录只有一个文件 a.txt.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># ls a<span class="token punctuation">.</span>txt <span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># ls a<span class="token punctuation">.</span>txt b<span class="token punctuation">.</span>txt <span class="token literal-property property">ls</span><span class="token operator">:</span> b<span class="token punctuation">.</span>txt<span class="token operator">:</span> No such file or directory 由于没有b<span class="token punctuation">.</span>txt这个文件<span class="token punctuation">,</span> 于是返回错误值<span class="token punctuation">,</span> 这就是所谓的<span class="token number">2</span>输出 a<span class="token punctuation">.</span>txt 而这个就是所谓的<span class="token number">1</span>输出</code></pre><p>复制</p><h4 id="再接着看"><a href="#再接着看" class="headerlink" title="再接着看:"></a>再接着看:</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># ls a<span class="token punctuation">.</span>txt b<span class="token punctuation">.</span>txt <span class="token number">1</span><span class="token operator">&gt;</span>file<span class="token punctuation">.</span>out <span class="token number">2</span><span class="token operator">&gt;</span>file<span class="token punctuation">.</span>err</code></pre><p>复制</p><p>执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># cat file<span class="token punctuation">.</span>out a<span class="token punctuation">.</span>txt <span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># cat file<span class="token punctuation">.</span>err <span class="token literal-property property">ls</span><span class="token operator">:</span> b<span class="token punctuation">.</span>txt<span class="token operator">:</span> No such file or directory</code></pre><p>复制</p><p>一般来说, “1&gt;” 通常可以省略成 “&gt;”. 即可以把如上命令写成: ls a.txt b.txt &gt;file.out 2&gt;file.err</p><p>有了这些认识才能理解 “1&gt;&amp;2” 和 “2&gt;&amp;1”. 1&gt;&amp;2</p><p>正确返回值传递给2输出通道 &amp;2表示2输出通道 如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中. 2&gt;&amp;1</p><p>错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子."></a>举个例子.</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># ls a<span class="token punctuation">.</span>txt b<span class="token punctuation">.</span>txt <span class="token number">1</span><span class="token operator">&gt;</span>file<span class="token punctuation">.</span>out <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>email <span class="token keyword">protected</span><span class="token punctuation">]</span> box<span class="token punctuation">]</span># cat file<span class="token punctuation">.</span>out <span class="token literal-property property">ls</span><span class="token operator">:</span> b<span class="token punctuation">.</span>txt<span class="token operator">:</span> No such file or directory a<span class="token punctuation">.</span>txt</code></pre><p>复制</p><p>现在, 正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.</p><p>补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.</p><p><strong>&gt; 是重定向符，就是把前面输出的内容重定向到后面指定的位置，比如（例1）：</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">echo <span class="token string">"一些内容"</span> <span class="token operator">&gt;</span> filename<span class="token punctuation">.</span>txt上面例子会把 <span class="token string">"一些内容"</span> 写入到 filename<span class="token punctuation">.</span>txt 文件中。</code></pre><p>复制</p><p><strong>&gt; 前是可以加数字来说明把什么内容重定向到文件中，默认是把标准输出重定向到文件中，所以下面这个例子和上面那个是一样的（例2）</strong>：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">echo <span class="token string">"一些内容"</span> <span class="token number">1</span><span class="token operator">&gt;</span> filename<span class="token punctuation">.</span>txt</code></pre><p>复制</p><p><strong>如果是错误信息就不会输出到filename.txt（例3）：</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ ls nodir <span class="token number">1</span><span class="token operator">&gt;</span> filename<span class="token punctuation">.</span>txt$ ls<span class="token operator">:</span> nodir<span class="token operator">:</span> No such file or directory</code></pre><p>复制</p><p>上面这个例子中nodir不存在，所以通过ls命令查询时错误信息会输出到 2(stderr)，但我们指定的是把1重定向到filename.txt，所以上面命令执行完后，filename.txt中是没有内容的。但是执行下面命令就会把错误信息写入到filename.txt中（例4）：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ ls nodir <span class="token number">2</span><span class="token operator">&gt;</span> filename<span class="token punctuation">.</span>txt$ cat filename<span class="token punctuation">.</span>txt$ ls<span class="token operator">:</span> nodir<span class="token operator">:</span> No such file or directory</code></pre><p>复制</p><p>&amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</p><p>1&gt;&amp;2 意思是把标准输出重定向到标准错误。</p><p>2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</p><p>&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中。</p><p>我们再看一个例子（列5）：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ ls nodir <span class="token number">1</span><span class="token operator">&gt;</span> filename<span class="token punctuation">.</span>txt <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>$ cat filename<span class="token punctuation">.</span>txt$ ls<span class="token operator">:</span> nodir<span class="token operator">:</span> No such file or directory</code></pre><p>复制</p><p>上面例子把 <strong>标准输出</strong> 重定向到文件 <strong>filename.txt</strong> 然后把 <strong>标准错误</strong> 重定向到 <strong>标准输出</strong>，所以最后的错误信息也通过标准输出写入到了文件中，比较例3，4，5，就能明白其作用。</p><p>下面是来自百度知道的内容，大家可以参考下：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">问：Linux重定向中 <span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span> 怎么理解？问题补充：echo <span class="token string">"aaaaaaaaaaaaaaaa"</span> <span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span> 怎么理解？</code></pre><p>复制</p><p>答：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span> 即 <span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span> 也就是把结果输出到和标准错误一样；之前如果有定义标准错误重定向到某log文件，那么标准输出也重定向到这个log文件如：ls <span class="token number">2</span><span class="token operator">&gt;</span>a1 <span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span> （等同 ls <span class="token operator">&gt;</span>a1 <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>）把标准输出和标准错误都重定向到a1，终端上看不到任何信息。</code></pre><p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1139965#:~:text=2%3E%261%20%E6%84%8F%E6%80%9D%E6%98%AF%E6%8A%8A,%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6filename%E4%B8%AD%E3%80%82&amp;text=%E4%B8%8A%E9%9D%A2%E4%BE%8B%E5%AD%90%E6%8A%8A%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA,%E5%B0%B1%E8%83%BD%E6%98%8E%E7%99%BD%E5%85%B6%E4%BD%9C%E7%94%A8%E3%80%82">shell 1&gt;&amp;2 2&gt;&amp;1 &amp;&gt;filename重定向的含义和区别</a></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tc控制带宽等网络资源</title>
      <link href="/2022/04/01/tc-kong-zhi-dai-kuan-deng-wang-luo-zi-yuan/"/>
      <url>/2022/04/01/tc-kong-zhi-dai-kuan-deng-wang-luo-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="限制单个网卡带宽"><a href="#限制单个网卡带宽" class="headerlink" title="限制单个网卡带宽"></a>限制单个网卡带宽</h2><h3 id="使用-TC-下载限制单个-IP-进行速度控制"><a href="#使用-TC-下载限制单个-IP-进行速度控制" class="headerlink" title="使用 TC 下载限制单个 IP 进行速度控制"></a>使用 TC 下载限制单个 IP 进行速度控制</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除原有规则</span><span class="token function">sudo</span> tc qdisc del dev ens4f1 root<span class="token function">sudo</span> tc qdisc <span class="token function">add</span> dev ens4f1 root handle <span class="token number">1</span>: htb r2q <span class="token number">1</span><span class="token function">sudo</span> tc class <span class="token function">add</span> dev ens4f1 parent <span class="token number">1</span>: classid <span class="token number">1</span>:1 htb rate 20mbit ceil 25mbit<span class="token function">sudo</span> tc  filter <span class="token function">add</span> dev ens4f1 parent <span class="token number">1</span>: protocol <span class="token function">ip</span> prio <span class="token number">16</span> u32 match <span class="token function">ip</span> dst <span class="token number">10.0</span>.0.62  flowid <span class="token number">1</span>:1</code></pre><p>就可以限制 192.168.1.2 的下载速度为 30Mbit 最高可以 60Mbit ,其中 r2q,是指没有 default 的root,使整个网络的带宽没有限制</p><h3 id="使用-TC-对整段-IP-进行速度控制"><a href="#使用-TC-对整段-IP-进行速度控制" class="headerlink" title="使用 TC 对整段 IP 进行速度控制"></a>使用 TC 对整段 IP 进行速度控制</h3><pre class="language-bash" data-language="bash"><code class="language-bash">tc qdisc <span class="token function">add</span> dev eth0 root handle <span class="token number">1</span>: htb r2q <span class="token number">1</span> tc class <span class="token function">add</span> deveth0 parent <span class="token number">1</span>: classid <span class="token number">1</span>:1 htb rate 50mbit ceil 1000mbit tc filter <span class="token function">add</span> dev eth0 parent <span class="token number">1</span>: protocol <span class="token function">ip</span> prio <span class="token number">16</span> u32 match <span class="token function">ip</span> dst <span class="token number">192.168</span>.111.0/24 flowid <span class="token number">1</span>:1</code></pre><p>就可以限制 192.168.111.0 到 255 的带宽为 3000k 了,实际下载速度为 200k 左右。这种情况下,这个网段所有机器共享这 200k 的带宽。</p><h3 id="加入一个-sfq-随机公平队列"><a href="#加入一个-sfq-随机公平队列" class="headerlink" title="加入一个 sfq(随机公平队列)"></a>加入一个 sfq(随机公平队列)</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript">tc qdisc add dev eth0 root handle <span class="token number">1</span><span class="token operator">:</span> htb r2q <span class="token number">1</span> tc <span class="token keyword">class</span> <span class="token class-name">add</span> dev eth0 parent <span class="token number">1</span><span class="token operator">:</span> classid <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span> htb rate 3000kbit burst 10k tc qdisc add dev eth0 parent <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span> handle <span class="token number">10</span><span class="token operator">:</span> sfq perturb <span class="token number">10</span> tc filter add dev eth0 parent <span class="token number">1</span><span class="token operator">:</span> protocol ip prio <span class="token number">16</span> u32 match ip dst <span class="token number">192.168</span><span class="token number">.111</span><span class="token number">.168</span> flowid <span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span></code></pre><p>sfq可以防止一个段内的一个 ip 占用整个带宽。使用 TC 控制服务器对外的速度为 10M</p><h2 id="模拟网络抖动"><a href="#模拟网络抖动" class="headerlink" title="模拟网络抖动"></a>模拟网络抖动</h2><pre class="language-bash" data-language="bash"><code class="language-bash">tc qdisc <span class="token function">add</span> dev eth0 root netem delay 100ms</code></pre><p>该命令将 eth0 网卡的传输设置为延迟 100 毫秒发送。</p><p>更真实的情况下,延迟值不会这么精确,会有一定的波动,我们可以用下面的情况来模拟出</p><h3 id="带有波动性的延迟值"><a href="#带有波动性的延迟值" class="headerlink" title="带有波动性的延迟值:"></a>带有波动性的延迟值:</h3><pre class="language-bash" data-language="bash"><code class="language-bash">tc qdisc <span class="token function">add</span> dev eth0 root netem delay 100ms 10ms</code></pre><p>该命令将 eth0 网卡的传输设置为延迟 100ms ± 10ms (90 ~ 110 ms 之间的任意值)发送。</p><p>还可以更进一步加强这种波动的随机性:</p><pre class="language-bash" data-language="bash"><code class="language-bash">tc qdisc <span class="token function">add</span> dev eth0 root netem delay 100ms 10ms <span class="token number">30</span>%</code></pre><p>该命令将 eth0 网卡的传输设置为 100ms ,同时,大约有 30% 的包会延迟 ± 10ms 发送。现在 ping 一下机器可以看出数据明显的波动性。</p><pre class="language-none"><code class="language-none">tc qdisc add dev eth0 root netem loss 1%</code></pre><p>该命令将 eth0 网卡的传输设置为随机丢掉 1% 的数据包。示例:在 216 上执行</p><pre class="language-none"><code class="language-none">tc qdisc add dev eth0 root netem loss 10%</code></pre><p>显示 16 个包只有 13 个收到了。也可以设置丢包的成功率:</p><pre class="language-none"><code class="language-none"># tc qdisc add dev eth0 root netem loss 1% 30%</code></pre><p>该命令将 eth0 网卡的传输设置为随机丢掉 1% 的数据包,成功率为 30% 。</p><h3 id="删除网卡上面的相关配置"><a href="#删除网卡上面的相关配置" class="headerlink" title="删除网卡上面的相关配置"></a>删除网卡上面的相关配置</h3><p>将之前命令中的 add 改为 del 即可删除配置:</p><pre class="language-none"><code class="language-none"># tc qdisc del dev eth0 XXXXXXXXXXX</code></pre><p>(自己加的配置)该命令将 删除 eth0 网卡的相关传输配置</p><p>至此,我们已经可以通过 TC 在测试环境中模拟一定的网络延时和丢包的情况。下面是关于tc 更多的应用和介绍</p><h3 id="模拟包重复"><a href="#模拟包重复" class="headerlink" title="模拟包重复"></a>模拟包重复</h3><pre class="language-none"><code class="language-none">tc qdisc add dev eth0 root netem duplicate 1%</code></pre><p>该命令将 eth0 网卡的传输设置为随机产生 1% 的重复数据包 。</p><h3 id="模拟数据包损坏"><a href="#模拟数据包损坏" class="headerlink" title="模拟数据包损坏"></a>模拟数据包损坏</h3><pre class="language-none"><code class="language-none">tc qdisc add dev eth0 root netem corrupt 0.2%</code></pre><p>该命令将 eth0 网卡的传输设置为随机产生 0.2% 的损坏的数据包 。 (内核版本需在 2.6.16 以上)</p><h3 id="模拟数据包乱序"><a href="#模拟数据包乱序" class="headerlink" title="模拟数据包乱序"></a>模拟数据包乱序</h3><pre class="language-none"><code class="language-none">tc qdisc change dev eth0 root netem delay 10ms reorder 25% 50%</code></pre><p>该命令将 eth0 网卡的传输设置为:有 25% 的数据包(50%相关)会被立即发送,其他的延迟10 秒。</p><p>新版本中,如下命令也会在一定程度上打乱发包的次序:# tc qdisc add dev eth0 root netem delay 100ms 10ms</p><h2 id="查看已经配置的网络条件"><a href="#查看已经配置的网络条件" class="headerlink" title="查看已经配置的网络条件"></a>查看已经配置的网络条件</h2><pre class="language-none"><code class="language-none">tc qdisc show dev eth0</code></pre><p>该命令将 查看并显示 eth0 网卡的相关传输配置</p><h2 id="删除tc规则"><a href="#删除tc规则" class="headerlink" title="删除tc规则"></a>删除tc规则</h2><p>tc qdisc del dev eth0 root</p><p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1772836?from=15425">linux下使用tc控制和模拟网络流量</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp连接数限制因素</title>
      <link href="/2022/04/01/tcp-lian-jie-shu-xian-zhi-yin-su/"/>
      <url>/2022/04/01/tcp-lian-jie-shu-xian-zhi-yin-su/</url>
      
        <content type="html"><![CDATA[<p>一般来说一台服务器建立的tcp连接数是有限的，主要是如下原因：</p><h2 id="打开文件数量方面的系统限制"><a href="#打开文件数量方面的系统限制" class="headerlink" title="打开文件数量方面的系统限制"></a>打开文件数量方面的系统限制</h2><p>最高的tcp连接并发数量要受到系统对用户单一进程同时可打开文件数量的限制</p><p>系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ unlimit -n<span class="token number">1024</span></code></pre><p>unlimit可以查看单个进程打开的文件数限制</p><p>linux系统对于用户的打开文件数有软限制和硬限制。</p><p>软限制（soft limit）：内核实际执行的限制，任何进程都可以将软限制设置为小于或等于对进程限制的硬限制的值、最大线程数和文件数。可用getrlimit读取，setrlimit设置，参数struct rlimitr.lim_cur. 软限制是限制的当前值，小于等于 硬限制，实际进程可以调用setrlimit增长到硬限制值。也就是说，软限制对进程并不是真正的限制。</p><p>硬限制（hard limit）：可以在任何时候任何进程中设置，但硬限制需要由超级用户修改。对进程的资源数的限制的最大值，也可以用getrlimit读取/setrlimit设置，参数struct rlimitr.rlim_max. 硬限制是绝对上限值，进程增长资源数不会超过硬限制。</p><h2 id="内存资源耗尽"><a href="#内存资源耗尽" class="headerlink" title="内存资源耗尽"></a>内存资源耗尽</h2><p>影响一个socket占用内存的参数包括：</p><p>rmem_max</p><p>wmem_max</p><p>tcp_rmem</p><p>tcp_wmem</p><p>tcp_mem</p><p>grep skbuff /proc/slabinfo</p><p>每个tcp链接相当于打开了一个文件，文件就是保存在内存中的，当连接数增加时文件数量也会快速增长，虽然文件不大但是蚁多压死象啊。</p><h2 id="端口限制"><a href="#端口限制" class="headerlink" title="端口限制"></a>端口限制</h2><p>一般来说这个不是限制因素</p><h2 id="查看服务器tcp连接数"><a href="#查看服务器tcp连接数" class="headerlink" title="查看服务器tcp连接数"></a>查看服务器tcp连接数</h2><pre class="language-bash" data-language="bash"><code class="language-bash">ss  -tan<span class="token operator">|</span><span class="token function">awk</span> 'NR<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">{</span>++S<span class="token punctuation">[</span><span class="token variable">$1</span><span class="token punctuation">]</span><span class="token punctuation">}</span>END<span class="token punctuation">{</span>for <span class="token punctuation">(</span>a <span class="token keyword">in</span> S<span class="token punctuation">)</span> print a,S<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">}</span>’</code></pre><p>通过上述命令可以统计出TCP连接中处于各个状态的连接数，在经过Ng代理之后需要真实的连接数需要除以2，因为Client——Nginx——Mqtt其实算是两个TCP连接。</p><p>参考：</p><p><a href="https://www.cnblogs.com/fortunely/p/14855912.html">软限制和硬限制</a></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apple script使用</title>
      <link href="/2022/03/22/apple-script-shi-yong/"/>
      <url>/2022/03/22/apple-script-shi-yong/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7711b0d1baf5fd453e57cdaec105cc95e1e3ea63a68f8cb5783020d778eebca3">4630436162ade97ba2718b7d0c4b3b633ddab527e8c3104da6e64d99fec75d5d569e756205306750c8095417fdb69288f84f561fbc835125dc93984fbe3fcc7ef4542519193c4807f44135e23593d03616a1b0ba30e3e554cd7815528286697a0a051155c5895ee5c72f2d635edd746276226d465d4131f2c76312ffa2e8abec097912ce8df8698cf5a9fc67c3b5f3c9dfbdc7bc047ad3c35b40e9facf34fd7acfa0d7a865fd7d4fe2506a500a63bc3dad5344463d0109cc9912d734b4563816233fc9a2e6b6d062eaaf79a4b0ae651d10ce43aa87e069171199253686426f0b1a164df7a7c22f5f5e00af455743e7accf20fdb2fb6b5a6a52c3b2bd4973c25e48bfa73b5b284a4b4e7988c21f9a0bb174b131f43495773c89a19cdfb9f80c9ad0667f7fd16564ba450c7af8db85c37360302142f9842c56f8b6b2141be353c5a1c3424f2126662700e6af6ea4f00f971ffe4f7439e597f6451507c3b97482bd3071daa98ec35f8ec35b57d9b3b44affb10d67e0f0a97a8b6ab917ef371c145cfa2b7b47fe29b93ccb81aa10f203a34bd52951cc15a9415369c9037a21d43eaf127a35b3cf862ebe20939ceeb7d6f4abe3585653a313f963c9846e6ed115e7f0b9ce959db271ad9e599db08f185f153a0732d279cbd8b5b95cbf58c2dd1434f3f1eea08511e80acd7db7a71c4a04ecdf644cee026a8419f4b872e1926ed72ec5ebafb96d5635fa9f9882e2adb4dd407916aed899e001ad290dc6ccd371eb5bf847214f6347a68f2a8e831207c621a65db1d75951e81160148884ec0735b418011b7b244e295a59147b49f60ba704a3dac792bb54ed6a3d9e8f293a008bf12f728347e2f42664b6ac2ceff1e10ac5eb48a99ea6fd5fe2190d310fb99cc83161224e330484dadb4041e55f8b5a08b01c0d89196a9fcf8d9fb513071ef58777d75ca1f752da1ca9944e8fa7a861e845baf1b4fb1176fef3599b17fb38fc4a5f2d17b8ccde7671256a1352ee5de0f62e95dfb976381c21d601c273dc8ae451a332e7c1651be823604f53d93c62f5dbb63bde7e1b310032890d0c8bed95c2fc52d82cb1a68d7bee3bd007c1b403863680d96864230af88101de2330129ffdd392d4e7f92e0a278f715e93d27b09fe94e33a1121fe5d212c65c8df305e7988910ab05f52d4af4a6db4904c66071c03b1d620c09ef7d12ae98b643eacd55e46449ac3c1b4cfef51bf864618563600e63fe0143e5eab2e521cf03ad73c61cd1339c74951a292cbaa1ab56a7b39db9311f915614fe3b31a60b4258520db5a0e703e3dfc3c45bfa840332099c51d2b082fe083b0ed9e451ab7ff6f2394ec192a1793ca40c0082447a4295f74ad730110b5da267d40adc436e4da20f2888bda4abbd8556606511309785a33ab026df65f1c18fdb55faa3804bf61ca82d658eb992de674b23f438c9f9f7ca834dea945d39e8d749a14b442041cfb33ec4a5fe39fe1cf2654ea27fa3cba183d185a2adb69f424915a9815b37eacf8d3d9d1b64a6aec12419e1289edee28ec072f2791109ee611ee04879f66ffe8efcf9b5ec6deeea8ff947104754d73ee92b55c5d3b4fd00da74140872a2a88e45f6db7d80dc481e36f912aee3ddb2a1dc831fb0e5db9907b3193e2c6370f6abb9e25731fe12f9e54a2f2924950962ce9c295cb7e80c11ffedbc28bf16f303b4a2514f88cc0aaf8751f8e183a55e4d69bce1950ff3cad8c8ce72dd006b65b32f48ae40a7e12daaff0050800460deed1bd853534ad16995e276fe5d2dcab55c7f35a19df7cbc5c3c5d3f0f3cceb31641aea9aed5a1a13943fee6b2b1cb0c2162ecd4ef050579d5917f30a8208ad6e11a79eb3400511b6dca6ae975f12c4833daaa61c7c0cbeb353c08d73b2a48a3e1d0f1b33ece45c2910f60ebe6ce73332c286a7d2940eb09d13565e20a8bd6dd9d1fcf81ba294404f2f3950aac14d7634b12334759bc37ff34df284a58d19a21173577bbc8846a100627d7d9d4b0349a8a866d9187004d13b4fc6f2fb822bf806a339130d7d10fb35a6e69e9d04f0380d1ad483b543d231aa3768c5daf35d8ca5112363aea2026e36febdd5f38d6118e7191e7ff352ef7b3c764063e1e5a784a459eefb4b77aad2eff339cd739b8c93a6437a53525fef7879f7d42baccd61d1b07011e55981ee486120d4ef847ded267b3ae2b13fb556753e526e4f46c738af53b0c722783b3a23d862d93dc3a9d9c425a1a37d44642fb30121212e1cde2ebcfd2b062235a2dd39b7db33f75fd2148b2abacd8992fa82587c78f42370d5511dc007031c7b968063ffed534c9160f0c564774b08522b4d2a1b5ea9b800a02fa862619e3cbe9bbefbb2dd3251ace6e0bb4d5ffe9d477a01dab14305610d054e535371e310e63e9652570f8b887eb3787c7a47bc715d660f9af0be72fcff4c7b6458b25f6c2542cef495de955afacd92b2cf42ed2b7f9ac126c0da95887d3cad51f9bf60cc1cda154df920d12d38a56c27af8af21a88f5f7d4f57b551c77536eceee7c9f67e457dd99245baab776d42b7c7a82e4ca822a57a33a0ccf9bbf0269c3682add5a5f13e962a18769c69bab28437aa75a2ca3841d7bcabab884a733cfac1e1193be2337084d6d9c37c39ec303afab64928ec17a90b1b1e543f57dd9a25c7a71ddde0115bc53a81c0f768059ff2f25b4183834e195356fdabeaca85fa073118534370f5ef093051d5fcf8df4d1a11a8ff22fe7254aecbcd8b8fe5101a2413382ab9c272d38ff40976ab977ad0645607a1d3c0f20e8e9ee8ffb7d91b2e4eaa78380e5e8f9611c139b0bce8d2d6a611255c651d6d9acb919dc008d4d4596dd8571b08c36c33ca2a89b7a7c81e8ca90bcdb721e47f515a85d5e6422d196f9aee99c059310f0682181f3726f9250bb5c455590e4758bf6ab78c066828f7ea02e6dfa57cd1bb8dedd04c351f77ee2ec4bf02ada172c420157a2362c872fb1e18c8b4ea3a21164703f679b9b4ab0ef901df3b7d828d5039389345f0d88c68c115e2c63dd28457c2ef7a17af69601ccbd1a11a438c5963b4ca37565a65f24e4bef23914cc4470fd29c125a9a2a357bc0fa484d5cb26735c4352620c35a44cf0ca68857ca47375e9f5da1a45a7d8bf9344da531c03e057e25ef3a51ce0be5b7185f089cb57798c44058c9254abc7dc29adb809a53886dff11da4e7695d9e6c90123624e66986c235062a91634c8ca1fb3768a40feab06ca3dda23dcd87861e5bbfed9d982092d066982eb50f7e928f3f1506cd2da0a553c429b6be8045b455a5298c8e83b4bcfd38543baaadbdf2eb95e1f3aabe6558421031cdbcc1400241eb2ec2c6c1cf17e12fc89d42d503231666785615e61e4a516980f57e396caa061d79754134a9e63f4a73f7bc2f8396868866e24ce5539304876e9189ed16a0702f0a0757f93bde176f4e0dcda58257096a5d52a52ce6c4c777a2ebe7dc9b4622666f7a4c89551e4b0f4ef722666ed38fc20230dd9157c5d5fc1f913239166b526753fc05f2870dc661ab14986a1641272a8614e1fe3b3f5f2bba30d62865302dd55fe511d9f859e84814aa6ad0248cd5ed1b17e74715b19c423305ecfab8715582571f0f96f8dc28bb04a634f2d73998d03e12fb72826c5a6fd747c7266ed88a5901b42795ad8b3203eab433e6864c2cb18fd9c3b98e7911c401b7eb98d2cd8ae297903967634659aa7d91d694df9fbb1983ff7b9a6945f4ccd983a1404e6240879ba3ed3938b2ea75dbe0dab86411277c1eb6dd69ce8e10618068cbfd7b71b4e33b15b7d42ac09e364666624965fed1efc738e330ba049092357d337e8dba7ec3ef3e1ec22b0e5b6150ee1356c971c5a562bc6876429a15a29b71d4b7b23fa2797b754d3934b0e4f8e9445bcbb3e310a6aa981482ca15c8f11e33f331ed29d22d342bab3e1aa933169f1a9da21f18ce26321c9de4a9cc40a16044c6605b764cc7b9804bc7bb0c3e797e8aaee003e66b8d499614f2abee4957e835b44b38b776495e1ef90ff89b9f1999093e0b39f51ad0e24c3db61ff8e44994f2887fc7f18add99af3d5dbb58fad42458e7052a63d2d53849eb0030d5e7f6bb848502cc5ece6d21e9dd94ac2b8f8969798d3dcea41aeb368c2d619bb020dd4819d680dc1859dbb002763e18fba7d4788532b4c2e73dd92ca37e252ae41585d60f30dde8791cc4b4165370a8023331c344d2d7a601455760757d4bcf4a4a67de21ac0907caaf7775a462e43f00694dfb894012fe817f9b69d022409171810b6e0f06677b680a406a108f282c838aa61f0824200c61b46154907a1737ef14d0a433cf75e1aa5bed2e38e82d09604ee75accbf220433af8c2887b0cd574bc4a0e7ee18a7181500c7da291ce7dcdd249d6bc0f6be5368387704997a6dc45a62792e17cdb2998c7bee5cb9a0f752fb2e3fdf55fe225c51c1d49d8cb4e9ff5142d2ce7f3e33a8c1123a024e2c5203faef75bd696e8b97aff9b091b3243ca1a113c73a05f904f8a8a5472e650eeaca48ca29b7b53d68d43971c89a64f3e34f6a44a8951a58e038d94fb064245ea2001e0cc10d6dbc3f1954d2ea06e15ae7bd8148b3c78cd665fbe7a42765004a65e2dfe400c8932c24c31ed2bf1ff87115917b95c56bf9235e579c941d129fa637b9ded77c60c37d8b30171f10751c21d6176985b40479688c1077d611854920148f7674af5737e125062158978742593e65e5cf9710d47f300b4c2b6f1f65e6f664d7c03e3f94e1cfcb586f3a5311279a3455342ccfc0bc83f12660c2f59418a4129b6fda5182c9076151e09e0c32bcdff6529a9c2ffc05c65bd3907fea42ad4c2e1be7e72522c190e3b314423156bd23c6fb9b9fbe0c21983ace84eefad820b333c55e5f2aa119ef186055645dd4c9de451c998d8865c5228ccb8a71a4fa084d379fbc89eff966e1f03872e474dcd901a7c77aa575d4071647918456d82e2c38baa52534602e06a21f427ffa4ae3793a30ed6ada9952a066314fa05be9101f3a8f13ee5c055a450a25234fcc4276fd9a76a43254e9f14fb2f06a03bd27e43b1e3ad997f4adaa796b765f8d668d606108d16f7bd4955116767f8ba5a1f23eb4741c813d486f8bf6dad45d147f8bac3082cd7b14efc2486bfc508800b581665198d51379ba2eb639b28ac136b273ed46ed8c2d368ae9c178600ade31192ed5a354666dde45e0dc5b186fe106abc3fb60f83b7ec0d4682945313150fd90ee5cb6885ab52c7d6581a5204a24ed657c489b4587171a78dffeab88ab5af0739769a11061ffe1f40086934688427ed0e67f302bb64ac7f9282b406b7261894a136</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>build cluster with bash on one node</title>
      <link href="/2022/03/16/build-cluster-with-bash-on-one-node/"/>
      <url>/2022/03/16/build-cluster-with-bash-on-one-node/</url>
      
        <content type="html"><![CDATA[<p>在我自己的机器上进行实验，sh文件实现一条命令部署单个节点集群</p><p>下面是解析步骤</p><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>定义在另一个文件中</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># Redis_Cluster</span><span class="token comment"># REDIS_SERVER_BIN="/home/k8s/homie/redis/src/redis-server"</span><span class="token assign-left variable">BASE_DIR</span><span class="token operator">=</span>/home/k8s/homie<span class="token assign-left variable">REDIS_SERVER_BIN</span><span class="token operator">=</span><span class="token variable">$BASE_DIR</span>/redis/src/redis-server<span class="token assign-left variable">REDIS_CLI_BIN</span><span class="token operator">=</span><span class="token variable">$BASE_DIR</span>/redis/src/redis-cli<span class="token assign-left variable">REDIS_CLUSTER_BASE</span><span class="token operator">=</span><span class="token variable">$BASE_DIR</span>/redis_cluster<span class="token assign-left variable">NODELIST</span><span class="token operator">=</span><span class="token string">"node2 node3 node4 node5"</span><span class="token assign-left variable">PORTS</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> <span class="token number">7000</span> <span class="token number">7005</span><span class="token variable">`</span></span><span class="token assign-left variable">BASEPORT</span><span class="token operator">=</span><span class="token variable">${ENTRY_PORT}</span><span class="token assign-left variable">HG_BASEPORT</span><span class="token operator">=</span><span class="token variable">${HG_PORT}</span></code></pre><p>根据自己需要进行修改</p><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Check redis command</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token variable">$REDIS_SERVER_BIN</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Redis not ready, please install redis firstly!"</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span>  <span class="token builtin class-name">echo</span> <span class="token string">"===== Install redis as follows ====="</span>  <span class="token builtin class-name">cd</span> <span class="token variable">$BASE_DIR</span>  <span class="token function">wget</span> http://download.redis.io/releases/redis-6.2.2.tar.gz  <span class="token function">tar</span> -zxvf ./redis-6.2.2.tar.gz  <span class="token function">mv</span> redis-6.2.2 redis  <span class="token builtin class-name">cd</span> redis  <span class="token function">make</span>  <span class="token builtin class-name">cd</span> <span class="token variable">$BASE_DIR</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Redis Server Installation Finished!"</span><span class="token keyword">fi</span></code></pre><p>没有安装redis的话就安装，这里使用的是6.2.2版本。</p><h2 id="删除节点配置函数"><a href="#删除节点配置函数" class="headerlink" title="删除节点配置函数"></a>删除节点配置函数</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">remove_cluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment"># kill redis servers</span>  <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> redis-server <span class="token operator">|</span> <span class="token function">grep</span> cluster <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span> -9   <span class="token comment"># disable systemd</span>  <span class="token comment"># systemctl disable redis-cluster.service</span>  <span class="token comment"># rm cluster data</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$REDIS_CLUSTER_BASE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">rm</span> -rf <span class="token variable">$REDIS_CLUSTER_BASE</span>  <span class="token keyword">fi</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">"--remove"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  remove_cluster    <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">fi</span></code></pre><p>因为我没有配置随系统开启，所以直接找出进程kill就行</p><h2 id="建立工作文件夹"><a href="#建立工作文件夹" class="headerlink" title="建立工作文件夹"></a>建立工作文件夹</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># enter work directory</span><span class="token function">mkdir</span> -p <span class="token variable">$REDIS_CLUSTER_BASE</span><span class="token builtin class-name">cd</span> <span class="token variable">$REDIS_CLUSTER_BASE</span></code></pre><h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">generate_instance_conf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token builtin class-name">echo</span> <span class="token string">"configuring server <span class="token variable">$1</span>"</span>    <span class="token comment"># clean conf file</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span> <span class="token operator">&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token comment"># write conf</span>  <span class="token builtin class-name">echo</span> <span class="token string">"port <span class="token variable">$1</span>"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"# bind 0.0.0.0"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"dir <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/data"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-enabled yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-config-file nodes-<span class="token variable">$1</span>.conf"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-node-timeout 5000"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-announce-ip 127.0.0.1"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf    <span class="token builtin class-name">echo</span> <span class="token string">"appendonly yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"daemonize yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf<span class="token punctuation">}</span><span class="token comment"># mkdir dirs and setup startup.sh</span><span class="token builtin class-name">echo</span> <span class="token string">"#!/bin/bash"</span> <span class="token operator">&gt;</span> <span class="token variable">$START_UP</span><span class="token assign-left variable">servers</span><span class="token operator">=</span><span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable">$PORTS</span><span class="token punctuation">;</span> <span class="token keyword">do</span>   <span class="token function">mkdir</span> -p <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/data  <span class="token comment"># generate conf files</span>  generate_instance_conf <span class="token variable">$port</span>  <span class="token comment"># </span>  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$REDIS_SERVER_BIN</span> <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/redis.conf"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$START_UP</span>  <span class="token comment"># servers</span>  <span class="token assign-left variable">servers</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$servers</span> 127.0.0.1:<span class="token variable">$port</span> "</span><span class="token keyword">done</span></code></pre><p>最重要的就是这一步，因为以后还要搭建分布式环境所以没有绑定ip，其他可以参考redis/redis.conf解释。</p><h2 id="开始命令文件"><a href="#开始命令文件" class="headerlink" title="开始命令文件"></a>开始命令文件</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x <span class="token variable">$START_UP</span><span class="token builtin class-name">echo</span> <span class="token string">"starting servers..."</span><span class="token variable">$START_UP</span><span class="token function">sleep</span> 5s<span class="token builtin class-name">echo</span> <span class="token string">"servers ready!"</span><span class="token comment"># create cluster</span><span class="token builtin class-name">echo</span> <span class="token string">"configuring cluster..."</span><span class="token variable">$REDIS_CLI_BIN</span> --cluster create <span class="token variable">$servers</span> --cluster-replicas <span class="token number">1</span><span class="token builtin class-name">echo</span> <span class="token string">"configured!"</span></code></pre><p>将启动命令写到新文件中并启动。</p><h2 id="全文件"><a href="#全文件" class="headerlink" title="全文件"></a>全文件</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">source</span> /home/k8s/homie/tools/0_parameters.sh<span class="token assign-left variable">START_UP</span><span class="token operator">=</span><span class="token variable">$REDIS_CLUSTER_BASE</span>/startup.sh<span class="token comment"># Check redis command</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token variable">$REDIS_SERVER_BIN</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Redis not ready, please install redis firstly!"</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span>  <span class="token builtin class-name">echo</span> <span class="token string">"===== Install redis as follows ====="</span>  <span class="token builtin class-name">cd</span> <span class="token variable">$BASE_DIR</span>  <span class="token function">wget</span> http://download.redis.io/releases/redis-6.2.2.tar.gz  <span class="token function">tar</span> -zxvf ./redis-6.2.2.tar.gz  <span class="token function">mv</span> redis-6.2.2 redis  <span class="token builtin class-name">cd</span> redis  <span class="token function">make</span>  <span class="token builtin class-name">cd</span> <span class="token variable">$BASE_DIR</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Redis Server Installation Finished!"</span><span class="token keyword">fi</span><span class="token comment"># 一节点操作多个节点</span><span class="token comment"># selectNode() {</span><span class="token comment">#     nodenum=$1</span><span class="token comment">#     specify_node=$2</span><span class="token comment">#     n_l=(${NODELIST})</span><span class="token comment">#     node=${n_l[@]:0:$nodenum}</span><span class="token comment">#     if [ -n "${specify_node}" ]; then</span><span class="token comment">#         node=${specify_node}</span><span class="token comment">#     fi</span><span class="token comment">#     echo ${node[@]}</span><span class="token comment"># }</span><span class="token comment"># # Remove redis cluster</span><span class="token comment"># stopCluster() {</span><span class="token comment">#     nodenum=$1</span><span class="token comment">#     nodelist=$(selectNode ${nodenum})</span><span class="token comment">#     for n in ${nodelist}; do</span><span class="token comment">#         ssh $n "ps -ef | grep redis-server | grep cluster | awk '{print $2}' | xargs kill -9 "</span><span class="token comment">#         echo ${n}</span><span class="token comment">#         ssh $n "rm -rf "$REDIS_CLUSTER_BASE"/*;"</span><span class="token comment">#     done</span><span class="token comment"># }</span><span class="token comment"># if [ "$1" = "--remove" ]; then</span><span class="token comment">#   stopCluster $2</span><span class="token comment">#   exit 0</span><span class="token comment"># fi</span><span class="token comment"># if [ "$1" = "--help" ]; then</span><span class="token comment">#     echo "--remove nodenum" </span><span class="token comment">#     exit 0</span><span class="token comment"># fi</span><span class="token comment"># Remove redis cluster</span><span class="token keyword">function</span> <span class="token function-name function">remove_cluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment"># kill redis servers</span>  <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> redis-server <span class="token operator">|</span> <span class="token function">grep</span> cluster <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span> -9   <span class="token comment"># disable systemd</span>  <span class="token comment"># systemctl disable redis-cluster.service</span>  <span class="token comment"># rm cluster data</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$REDIS_CLUSTER_BASE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">rm</span> -rf <span class="token variable">$REDIS_CLUSTER_BASE</span>  <span class="token keyword">fi</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">"--remove"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  remove_cluster    <span class="token builtin class-name">exit</span> <span class="token number">0</span><span class="token keyword">fi</span><span class="token comment"># User custom setting</span><span class="token comment"># echo -n "Enter your host's public address(default 127.0.0.1):"</span><span class="token comment"># read cluster_address</span><span class="token comment"># enter work directory</span><span class="token function">mkdir</span> -p <span class="token variable">$REDIS_CLUSTER_BASE</span><span class="token builtin class-name">cd</span> <span class="token variable">$REDIS_CLUSTER_BASE</span><span class="token comment"># generate configuration files</span>  <span class="token comment"># copy of redis.conf</span><span class="token comment"># function generate_instance_conf() {</span><span class="token comment">#   echo "configuring server $1"</span><span class="token comment">#   cp $BASE_DIR/redis/redis.conf $REDIS_CLUSTER_BASE/config/redis-$1.conf</span><span class="token comment">#   cd $REDIS_CLUSTER_BASE/config</span><span class="token comment">#   sed  -i "s@# cluster-config-file nodes-6379.conf@cluster-config-file \"cluster-config-file$REDIS_CLUSTER_BASE/node/redis-$1.conf\"@g" redis-$1.conf</span><span class="token comment">#   sed  -i "s/daemonize no/daemonize yes/g" redis-$1.conf</span><span class="token comment">#   sed  -i "/protected-mode yes/d" redis-$1.conf</span><span class="token comment">#   sed  -i "s/bind 127.0.0.1 -::1/# bind 127.0.0.1 -::1/g" redis-$1.conf </span><span class="token comment">#   sed  -i "s/port 6379/port $1/g" redis-$1.conf</span><span class="token comment">#   sed  -i "s#pidfile /var/run/redis_6379.pid#pidfile /var/run/redis_$1.pid#g" redis-$1.conf</span><span class="token comment">#   sed  -i "s#logfile \"\"#logfile \"$REDIS_CLUSTER_BASE/log/redis-$1.log\"#g" redis-$1.conf</span><span class="token comment">#   sed  -i "s#dir ./#dir $REDIS_CLUSTER_BASE/data#g" redis-$1.conf</span><span class="token comment">#   sed  -i "s/dbfilename dump.rdb/dbfilename dump-$1.rdb/g" redis-$1.conf</span><span class="token comment">#   sed  -i "s/appendonly no/appendonly yes/g" redis-$1.conf</span><span class="token comment">#   sed  -i "s/appendfilename \"appendonly.aof\"/appendfilename \"appendonly-$1.aof\"/g" redis-$1.conf</span><span class="token comment">#   sed  -i "s/# cluster-enabled yes/cluster-enabled yes/g" redis-$1.conf</span><span class="token comment">#   sed  -i "s@# cluster-config-file nodes-6379.conf@cluster-config-file \"$REDIS_CLUSTER_BASE/node/nodes-7000.conf\"@g" redis-$1.conf</span><span class="token comment"># }</span><span class="token comment"># # mkdir dirs and setup startup.sh with copy of redis.conf</span><span class="token comment"># echo "#!/bin/bash" &gt; $START_UP</span><span class="token comment"># servers=</span><span class="token comment"># for port in $PORTS; do </span><span class="token comment">#   # generate conf files</span><span class="token comment">#   generate_instance_conf $port</span><span class="token comment">#   # </span><span class="token comment">#   echo "$REDIS_SERVER_BIN $REDIS_CLUSTER_BASE/config/redis-$port.conf" &gt;&gt; $START_UP</span><span class="token comment">#   # servers</span><span class="token comment">#   servers="$servers 127.0.0.1:$port "</span><span class="token comment"># done</span><span class="token comment"># generate configuration files</span><span class="token keyword">function</span> <span class="token function-name function">generate_instance_conf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token builtin class-name">echo</span> <span class="token string">"configuring server <span class="token variable">$1</span>"</span>    <span class="token comment"># clean conf file</span>  <span class="token builtin class-name">echo</span> <span class="token string">""</span> <span class="token operator">&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token comment"># write conf</span>  <span class="token builtin class-name">echo</span> <span class="token string">"port <span class="token variable">$1</span>"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"# bind 0.0.0.0"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"dir <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/data"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-enabled yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-config-file nodes-<span class="token variable">$1</span>.conf"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-node-timeout 5000"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"cluster-announce-ip 127.0.0.1"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf    <span class="token builtin class-name">echo</span> <span class="token string">"appendonly yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf  <span class="token builtin class-name">echo</span> <span class="token string">"daemonize yes"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$1</span>/redis.conf<span class="token punctuation">}</span><span class="token comment"># mkdir dirs and setup startup.sh</span><span class="token builtin class-name">echo</span> <span class="token string">"#!/bin/bash"</span> <span class="token operator">&gt;</span> <span class="token variable">$START_UP</span><span class="token assign-left variable">servers</span><span class="token operator">=</span><span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable">$PORTS</span><span class="token punctuation">;</span> <span class="token keyword">do</span>   <span class="token function">mkdir</span> -p <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/data  <span class="token comment"># generate conf files</span>  generate_instance_conf <span class="token variable">$port</span>  <span class="token comment"># </span>  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$REDIS_SERVER_BIN</span> <span class="token variable">$REDIS_CLUSTER_BASE</span>/<span class="token variable">$port</span>/redis.conf"</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$START_UP</span>  <span class="token comment"># servers</span>  <span class="token assign-left variable">servers</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$servers</span> 127.0.0.1:<span class="token variable">$port</span> "</span><span class="token keyword">done</span><span class="token comment"># startup instances</span><span class="token function">chmod</span> +x <span class="token variable">$START_UP</span><span class="token builtin class-name">echo</span> <span class="token string">"starting servers..."</span><span class="token variable">$START_UP</span><span class="token function">sleep</span> 5s<span class="token builtin class-name">echo</span> <span class="token string">"servers ready!"</span><span class="token comment"># create cluster</span><span class="token builtin class-name">echo</span> <span class="token string">"configuring cluster..."</span><span class="token variable">$REDIS_CLI_BIN</span> --cluster create <span class="token variable">$servers</span> --cluster-replicas <span class="token number">1</span><span class="token builtin class-name">echo</span> <span class="token string">"configured!"</span><span class="token comment"># generate redis-cluster service file开机自启动</span><span class="token comment"># cat &lt;&lt; EOT &gt; $REDIS_CLUSTER_BASE/redis-cluster.service</span><span class="token comment"># [Unit]</span><span class="token comment"># Description=Redis 5.0 Cluster Service</span><span class="token comment"># After=network.target</span><span class="token comment"># [Service]</span><span class="token comment"># Type=forking</span><span class="token comment"># ExecStart=/usr/local/redis-cluster/startup.sh</span><span class="token comment"># [Install]</span><span class="token comment"># WantedBy=default.target</span><span class="token comment"># EOT</span><span class="token comment"># # create service</span><span class="token comment"># echo "Creating redis cluster service..."</span><span class="token comment"># ln -s $REDIS_CLUSTER_BASE/$SERVICE /etc/systemd/system/$SERVICE </span><span class="token comment"># sudo systemctl daemon-reload &amp;&amp; sudo systemctl enable $SERVICE &amp;&amp; sudo systemctl start $SERVICE</span><span class="token comment"># Cluster OK</span><span class="token builtin class-name">echo</span> <span class="token string">""</span><span class="token builtin class-name">echo</span> <span class="token string">"Completed!"</span><span class="token builtin class-name">echo</span> <span class="token string">""</span><span class="token builtin class-name">echo</span> <span class="token string">"Test cluster with: <span class="token variable">$REDIS_CLI_BIN</span> -h 127.0.0.1 -p 7000"</span><span class="token builtin class-name">echo</span> <span class="token string">""</span><span class="token builtin class-name">echo</span> <span class="token string">"127.0.0.1:7000&gt;cluster nodes"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis cluster build</title>
      <link href="/2022/03/09/redis-cluster-build/"/>
      <url>/2022/03/09/redis-cluster-build/</url>
      
        <content type="html"><![CDATA[<h1 id="下载redis6-2-2并安装"><a href="#下载redis6-2-2并安装" class="headerlink" title="下载redis6.2.2并安装"></a>下载redis6.2.2并安装</h1><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">wget</span> http://download.redis.io/releases/redis-6.2.2.tar.gz<span class="token function">tar</span> -zxvf ./redis-6.2.2.tar.gz<span class="token function">mv</span> redis-6.2.2 redis<span class="token builtin class-name">cd</span> redis<span class="token function">make</span></code></pre><h1 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h1><h2 id="1、新建目录，并拷贝出6个节点的配置文件"><a href="#1、新建目录，并拷贝出6个节点的配置文件" class="headerlink" title="1、新建目录，并拷贝出6个节点的配置文件"></a>1、新建目录，并拷贝出6个节点的配置文件</h2><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span>  redis-6.2.2<span class="token function">mkdir</span> -p config<span class="token function">mkdir</span> -p log<span class="token function">mkdir</span> -p data<span class="token function">mkdir</span> -p <span class="token function">node</span><span class="token function">cp</span> redis.conf ./config/redis-7000.conf</code></pre><h2 id="2、修改每个节点的配置文件内容"><a href="#2、修改每个节点的配置文件内容" class="headerlink" title="2、修改每个节点的配置文件内容"></a>2、修改每个节点的配置文件内容</h2><pre class="language-shell" data-language="shell"><code class="language-shell">远程访问需要把bind注释掉        <span class="token comment"># bind 127.0.0.1</span>修改端口号        port <span class="token number">7000</span>默认启动时为后台启动，yes为后台启动        daemonize <span class="token function">yes</span>指定进程信息存储文件        pidfile /var/run/redis_7000.pid指定日志文件<span class="token punctuation">(</span>改成自己的路径<span class="token punctuation">)</span>        logfile <span class="token string">"/home/k8s/homie/redis-6.2.1/log/redis-7000.log"</span> 指定数据文件路径<span class="token punctuation">(</span>改成自己的路径<span class="token punctuation">)</span>        <span class="token function">dir</span> <span class="token string">"/home/k8s/homie/redis-6.2.1/data"</span>指定rdb持久化文件名        dbfilename <span class="token string">"dump-7000.rdb"</span>指定aof持久化文件名（默认情况不会生成，因为默认 appendonly no）          appendonly <span class="token function">yes</span>        appendfilename <span class="token string">"appendonly-7000.aof"</span>以集群方式启动        cluster-enabled <span class="token function">yes</span>集群节点nodes信息配置文件<span class="token punctuation">(</span><span class="token punctuation">)</span>        cluster-config-file <span class="token string">"/home/k8s/homie/redis-6.2.1/node/nodes-7000.conf"</span>设置访问密码        <span class="token comment">#requirepass redis123</span></code></pre><h2 id="3、准备其他节点的配置文件"><a href="#3、准备其他节点的配置文件" class="headerlink" title="3、准备其他节点的配置文件"></a>3、准备其他节点的配置文件</h2><p>将 redis-7000.conf 文件都复制一份并修改，附sed命令：<strong>sed ‘s/要被取代的字串/新的字串/g’</strong></p><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /home/k8s/homie/redis-6.2.1/config<span class="token function">sed</span> <span class="token string">"s/7000/7001/g"</span> redis-7000.conf <span class="token operator">&gt;</span> redis-7001.conf<span class="token function">sed</span> <span class="token string">"s/7000/7002/g"</span> redis-7000.conf <span class="token operator">&gt;</span> redis-7002.conf<span class="token function">sed</span> <span class="token string">"s/7000/7003/g"</span> redis-7000.conf <span class="token operator">&gt;</span> redis-7003.conf<span class="token function">sed</span> <span class="token string">"s/7000/7004/g"</span> redis-7000.conf <span class="token operator">&gt;</span> redis-7004.conf<span class="token function">sed</span> <span class="token string">"s/7000/7005/g"</span> redis-7000.conf <span class="token operator">&gt;</span> redis-7005.conf</code></pre><h1 id="启动6个Redis实列"><a href="#启动6个Redis实列" class="headerlink" title="启动6个Redis实列"></a>启动6个Redis实列</h1><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /home/k8s/homie/redis-6.2.1./src/redis-server ./config/redis-7000.conf./src/redis-server ./config/redis-7001.conf./src/redis-server ./config/redis-7002.conf./src/redis-server ./config/redis-7003.conf./src/redis-server ./config/redis-7004.conf./src/redis-server ./config/redis-7005.conf</code></pre><p>通过 <code>ps -ef | grep redis</code>，查看实例数量，检查是否6个实例已启动。</p><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><pre class="language-shell" data-language="shell"><code class="language-shell">./src/redis-cli --cluster create <span class="token number">127.0</span>.0.1:7000 <span class="token number">127.0</span>.0.1:7001 <span class="token number">127.0</span>.0.1:7002 node5:7000 node5:7001 node5:7002 node2:7000 node2:7001 node2:7002 node3:7000 node3:7001 node3:7002 <span class="token number">127.0</span>.0.1:7003 <span class="token number">127.0</span>.0.1:7004 <span class="token number">127.0</span>.0.1:7005 node5:7003 node5:7004 node5:7005 node2:7003 node2:7004 node2:7005 node3:7003 node3:7004 node3:7005--cluster-replicas <span class="token number">1</span></code></pre><p>​    选项–replicas 1 ： 表示我们希望为集群中的每个主节点创建一个从节点<br>​    前12个是主节点，后面的是从节点（若节点在不同的机器上，注意主节点的书写位置，要避免主节点在同一台机器上，影响性能）</p><h1 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h1><p>一般情况下平均分配好了</p><pre class="language-bash" data-language="bash"><code class="language-bash">./src/redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">7000</span> cluster addslots <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2730</span><span class="token punctuation">}</span>./src/redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">7001</span> cluster addslots <span class="token punctuation">{</span><span class="token number">2731</span><span class="token punctuation">..</span><span class="token number">5461</span><span class="token punctuation">}</span>./src/redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">7002</span> cluster addslots <span class="token punctuation">{</span><span class="token number">5462</span><span class="token punctuation">..</span><span class="token number">7211</span><span class="token punctuation">}</span>./src/redis-cli -h <span class="token number">192.168</span>.1.117 -p <span class="token number">7000</span> cluster addslots <span class="token punctuation">{</span><span class="token number">7212</span><span class="token punctuation">..</span><span class="token number">10922</span><span class="token punctuation">}</span>./src/redis-cli -h  <span class="token number">192.168</span>.1.117 -p <span class="token number">7001</span> cluster addslots <span class="token punctuation">{</span><span class="token number">10923</span><span class="token punctuation">..</span><span class="token number">12331</span><span class="token punctuation">}</span>./src/redis-cli -h  <span class="token number">192.168</span>.1.117 -p <span class="token number">7002</span> cluster addslots <span class="token punctuation">{</span><span class="token number">12332</span><span class="token punctuation">..</span><span class="token number">16383</span><span class="token punctuation">}</span></code></pre><h1 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h1><h2 id="1、查看集群状态"><a href="#1、查看集群状态" class="headerlink" title="1、查看集群状态"></a>1、查看集群状态</h2><pre class="language-bash" data-language="bash"><code class="language-bash">./src/redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">7000</span>  cluster info</code></pre><h2 id="2、查看集群节点信息"><a href="#2、查看集群节点信息" class="headerlink" title="2、查看集群节点信息"></a>2、查看集群节点信息</h2><pre class="language-bash" data-language="bash"><code class="language-bash">./redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">7000</span> cluster nodes</code></pre><p>可以查看到各节点的信息，槽的分配</p><h1 id="集群重启"><a href="#集群重启" class="headerlink" title="集群重启"></a>集群重启</h1><pre class="language-shell" data-language="shell"><code class="language-shell">第一步：先关闭各个Redis节点。./src/redis-cli -p <span class="token number">7000</span> <span class="token function">shutdown</span>./src/redis-cli -p <span class="token number">7001</span> <span class="token function">shutdown</span>./src/redis-cli -p <span class="token number">7002</span> <span class="token function">shutdown</span>./src/redis-cli -p <span class="token number">7003</span> <span class="token function">shutdown</span>./src/redis-cli -p <span class="token number">7004</span> <span class="token function">shutdown</span>./src/redis-cli -p <span class="token number">7005</span> <span class="token function">shutdown</span>第二步：再启动各个Redis节点即可。./src/redis-server ./config/redis-7000.conf./src/redis-server ./config/redis-7001.conf./src/redis-server ./config/redis-7002.conf./src/redis-server ./config/redis-7003.conf./src/redis-server ./config/redis-7004.conf./src/redis-server ./config/redis-7005.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis cluster</title>
      <link href="/2022/03/05/redis-cluster/"/>
      <url>/2022/03/05/redis-cluster/</url>
      
        <content type="html"><![CDATA[<h1 id="redis集群理论"><a href="#redis集群理论" class="headerlink" title="redis集群理论"></a>redis集群理论</h1><p>单机遇到内存、并发、流量等瓶颈时，可以采用Cluster架构方案来达到负载均衡</p><h2 id="一-基础理论"><a href="#一-基础理论" class="headerlink" title="一 基础理论"></a>一 基础理论</h2><h3 id="1-1分区规则"><a href="#1-1分区规则" class="headerlink" title="1.1分区规则"></a>1.1分区规则</h3><p>数据集按照分区规则映射到各个节点</p><p><img src="/2022/03/05/redis-cluster/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2Mzk5OTkx,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>常见哈希分区：</p><ol><li><p>节点取余分区</p><p>使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式： hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。</p></li></ol><p>   <strong>缺点</strong>：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p><p>   <strong>优点</strong>：这种方式的突出优点是简单，易理解；</p><p>   这种方式常用于数据库的分库分表规则，一般采 用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张 表，保证可支撑未来一段时间的数据量，再根据负载情况将表迁移到其他数 据库中。<br>   扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移 的情况</p><ol start="2"><li><p>一致性哈希分区</p><p>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token（范围一般在0~2^32），这些token构成一个哈希环。</p><p>数据读写 执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点；</p><p><strong>缺点：</strong></p><p>加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。<br>当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此 这种方式不适合少量数据节点的分布式方案。</p><p><strong>优点</strong>：</p><p>相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响</p></li><li><p><strong>虚拟槽分区</strong><br>虚拟槽分区使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）；<br>槽范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383；<br>槽是集群内数据 管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集 群扩展；<br>每个节点会负责一定数量的槽；</p></li></ol><h3 id="1-2redis的数据分区"><a href="#1-2redis的数据分区" class="headerlink" title="1.2redis的数据分区"></a>1.2redis的数据分区</h3><p>Redis Cluser 采用虚拟槽分区，所有的键根据哈希函数映射到 0~16383整 数槽内；</p><p>计算公式：slot=CRC16（ key ） &amp;16383；<br>每一个节点负责维护一部分槽以及槽所映射的键值数据；</p><p>redis虚拟槽分区的特点：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ul><h3 id="1-3集群功能限制"><a href="#1-3集群功能限制" class="headerlink" title="1.3集群功能限制"></a>1.3集群功能限制</h3><ol><li>key批操作命令支持有限。如mset、mget，目前只支持具有相同slot值的 key执行批量操作。</li><li>key事务操作支持有限。只支持多key在同一节点上的事务操 作，当多个key分布在不同的节点上时无法使用事务功能。</li><li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list等映射到不同的节点。</li><li>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模 式下只能使用一个数据库空间，即db0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复 制结构。</li></ol><p> 一个完整的节点</p><p><img src="/2022/03/05/redis-cluster/1478675-20190530111414956-1304307578.png" alt="img"></p><h2 id="二-搭建"><a href="#二-搭建" class="headerlink" title="二 搭建"></a>二 搭建</h2><p>搭建集群工作分四步：</p><h3 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h3><p>Redis 集群一般由多个节点组成，节点数量至少为 6个才能保证组成完整高可用的集群。</p><p><strong>cluster-enabled :</strong> 每个节点需要<strong>开启配置</strong> <strong>cluster-enabled yes</strong> ，让 Redis运行在集群模式下。<br><strong>cluster-config-file:</strong> 第一次启动时如果没有【集群配置文件】，它会自动创建一份，该配置文件名称采用cluster-config-file配置参数项控制；<br>节点重启的时候会加载该配置文件进行重用；</p><p>如果集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会自动保存集群状态到配置文件中（ <strong>cluster-config-file</strong>）<br>Redis自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错乱。</p><p> <img src="/2022/03/05/redis-cluster/image-20211127143430284.png" alt="image-20211127143430284"></p><h3 id="节点握手cluster-meet"><a href="#节点握手cluster-meet" class="headerlink" title="节点握手cluster meet"></a>节点握手cluster meet</h3><p>节点握手是指一批运行在集群模式下的节点通过 Gossip协议彼此通信， 达到感知对方的目的。</p><p>由客户端使用命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cluster meet <span class="token punctuation">{</span>ip<span class="token punctuation">}</span> <span class="token punctuation">{</span>port<span class="token punctuation">}</span></code></pre><p>cluster meet命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信；</p><p>我们只需要在集群内任意节点上执行cluster meet命令加入新节点，握手 状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程</p><p>节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止</p><p>由于目前所有的槽没有分配到节点，因此集群无法完成槽到节点的映射。</p><p>只有当 16384 个槽全部分配给节点后，集群才进入在线状态。</p><h3 id="分配槽cluster-addslots"><a href="#分配槽cluster-addslots" class="headerlink" title="分配槽cluster addslots"></a><strong>分配槽</strong>cluster addslots</h3><p>通过 cluster addslots命令为节点分配槽:</p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46379</span> cluster addslots <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2730</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46380</span> cluster addslots <span class="token punctuation">{</span><span class="token number">2731</span><span class="token punctuation">..</span><span class="token number">5461</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46381</span> cluster addslots <span class="token punctuation">{</span><span class="token number">5462</span><span class="token punctuation">..</span><span class="token number">7211</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46382</span> cluster addslots <span class="token punctuation">{</span><span class="token number">7212</span><span class="token punctuation">..</span><span class="token number">10922</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46383</span> cluster addslots <span class="token punctuation">{</span><span class="token number">10923</span><span class="token punctuation">..</span><span class="token number">12331</span><span class="token punctuation">}</span>redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">46384</span> cluster addslots <span class="token punctuation">{</span><span class="token number">12332</span><span class="token punctuation">..</span><span class="token number">16383</span><span class="token punctuation">}</span></code></pre><h3 id="设置主从关系cluster-replicate"><a href="#设置主从关系cluster-replicate" class="headerlink" title="设置主从关系cluster replicate"></a>设置主从关系cluster replicate</h3><p>作为一个完整的集群，每个负责处理槽的 节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。</p><p>集群模式下， Reids 节点角色分为主节点和从节点。</p><p>首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">cluster replicate<span class="token punctuation">{</span>nodeId<span class="token punctuation">}</span>命令让一个节点成为从节点</code></pre><p>注意：在集群模式下slaveof添加从节点操作不再支持</p><p>cluster info命令可以获取集群当前状态：<br>cluster nodes命令可以看到节点和槽的分配关系：</p><h2 id="三-节点通信"><a href="#三-节点通信" class="headerlink" title="三 节点通信"></a>三 节点通信</h2><p>在分布式存储中需要提供维护节点元数据信息的机制。<br>所谓元数据是 指：节点负责哪些数据，是否出现故障等状态信息。<br>常见的元数据维护方式 分为：集中式和P2P方式。<br>Redis集群采用P2P的Gossip（流言）协议， Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息。</p><h3 id="3-1通信流程"><a href="#3-1通信流程" class="headerlink" title="3.1通信流程"></a>3.1通信流程</h3><ol><li>集群中的每个节点都会单独开辟一个 TCP通道，用于节点之间彼此通信，默认通信端口号在基础端口上加 10000（也可通过 <code>cluter meet &lt;ip&gt; &lt;port&gt; [cport]</code> 的cport的参数指定端口） 。</li><li>每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。</li><li>接收到 ping 消息的节点用 pong 消息作为响应。</li></ol><p>当节点出故障、新节点加入、主从角色变化、槽信息 变更等事件发生时，通过不断的ping/pong消息通信</p><p>经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。</p><h3 id="3-2-Gossip消息"><a href="#3-2-Gossip消息" class="headerlink" title="3.2 Gossip消息"></a>3.2 Gossip消息</h3><p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的 Gossip 消息；</p><p>常用的 Gossip 消息可分为： ping 消息、 pong 消息、 meet 消息、 fail 消息等:</p><ul><li><p>meet消息：用于通知新节点加入。<br>消息发送者通知接收者加入到当前集群， meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping 、 pong 消息交换。</p></li><li><p>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。<br>ping消息发送封装了自身节点和部分其他节点的状态数据。</p></li><li><p>pong 消息：当接收到 ping 、 meet消息时，作为响应消息回复给发送方确认消息正常通信。<br>pong 消息内部封装了自身状态数据。<br>节点也可以向集群内 广播自身的 pong 消息来通知整个集群对自身状态进行更新。</p></li><li><p>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail 消息<br>其他节点接收到 fail 消息之后把对应节点更新为下线状态。</p></li></ul><h3 id="3-3节点选择"><a href="#3-3节点选择" class="headerlink" title="3.3节点选择"></a>3.3节点选择</h3><p>虽然 Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。</p><p>由于内部需要频繁地进行节点信息交换，而 ping/pong消息会携带当前节点和部分其他节点的状态数据，会加重带宽和计算的负担。</p><p>因此节点每次选择需 要通信的节点列表变得非常重要;</p><ul><li><p>通信节点选择过多，虽然可以做到信息及时 交换但成本过高。</p></li><li><p>节点选择过少会降低集群内所有节点彼此信息交换频率， 从而影响故障判定、新节点发现等需求的速度。</p></li></ul><ol><li><p><strong>选择发送消息的节点数量</strong></p><p>集群内每个节点维护定时任务默认每秒执行 10 次，每秒会随机选取 5个节点找出最久没有通信的节点发送 ping 消息，用于保证 Gossip信息交换的随机性。<br>每 100 毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于 cluster_node_timeout/2 ，则立刻发送ping消息，防止该节点信息太长时间未更新。</p><p>因此 cluster_node_timeout参数对消息发送的节点数量影响非常大。</p><p>当我们的带宽资源紧张时，可以适当调大这个参数，如从默认 15 秒改为 30秒来降低带宽占用率。</p><p>过度调大 cluster_node_timeout 会影响消息交换的频率从而影响故障转移、槽信息更新、新节点发现的速度。</p><p>因此需要根据业务容忍度和资源消耗进行平衡。同时整个集群消息总交换量也跟节点数成正比。</p></li><li><p><strong>消息数据量</strong></p><p>每个 ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是 myslots[CLUSTER_SLOTS/8] ，占用 2KB，这块空间占用相对固定。<br>消息体会携带一定数量的其他节点信息用于信息交换。</p></li></ol><h2 id="四-集群伸缩"><a href="#四-集群伸缩" class="headerlink" title="四 集群伸缩"></a>四 集群伸缩</h2><p>Redis集群可以实现对节点的灵活上下线控制。其中原理可抽象为槽和对应数据在不同节点之间灵活移动。</p><h3 id="4-1扩容集群"><a href="#4-1扩容集群" class="headerlink" title="4.1扩容集群"></a>4.1扩容集群</h3><p>扩容可以分为如下步骤：</p><p><strong>1.准备新节点</strong></p><p><strong>2.加入集群</strong><br>准备好新节点后，依然采用 cluster meet 命令，将新的节点加入到集群<br>新节点加入到集群后，还没有负责的槽，所以还不能接受任何读写操作；对新节点的后续操作一般有两种选择：<br>（1）作为其他主节点的从节点，负责故障转移<br>（2）为他迁移槽和数据，实现扩容</p><blockquote><p>注意：<br>手动执行 cluster meet 命令加入已经存在于其他集群的节点，会造成被加入节点的集群合并到现有集群的情况从而造成数据丢失和错乱，</p><p>后果非常严重，线上谨慎操作。</p><p><strong>正式环境建议使用redis-trib.rb add-node命令加入新节点，该命令内部会执行新节点状态检查</strong><br>如果新节点已经加入其他集群或者包含数据，则放弃集群加入操作</p></blockquote><p><strong>3.迁移槽和数据</strong><br>最后 迁移槽和数据 是扩容最核心的环节，槽在迁移过程中集群仍然可以正常提供读写服务；<br>槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。<br>迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀。</p><p>迁移具体操作步骤如下：</p><ol><li>对目标节点发送 cluster setslot {slot} importing {sourceNodeId}命令，让目标节点准备导入槽的数据。</li><li>对源节点发送 cluster setslot {slot} migrating {targetNodeId}命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行 cluster getkeysinslot {slot} {count} 命令，获取 count个属于槽 {slot} 的键。</li><li>在源节点上执行migrate{targetIp}{targetPort}””0{timeout}keys{keys…}命令，把获取的键通过流水线（ pipeline ）机制批量迁移到目标节点。</li><li>重复执行步骤 3 ）和步骤 4）直到槽下所有的键值数据迁移到目标节点。</li><li>向集群内所有主节点发送 cluster setslot {slot} node {targetNodeId}命令，通知槽分配给目标节点。</li></ol><blockquote><p> todo：如果是迁移过程中的修改如何体现在新节点？</p><ol><li>储存迁移期间的指令？</li><li>转移整个槽？</li></ol></blockquote><h3 id="4-2收缩集群"><a href="#4-2收缩集群" class="headerlink" title="4.2收缩集群"></a>4.2收缩集群</h3><p>收缩集群意味着缩减规模，需要从现有集群中安全下线部分节点；</p><p>操作流程如下：</p><ol><li>确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。</li></ol><p>   原理与上面 节点扩容的迁移槽过程一致。</p><ol start="2"><li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。</li></ol><p>   Redis 提供了cluster forget {downNodeId} 命令实现该功能。</p><p>   当节点接收到 cluster forget{down NodeId} 命令后，会把 nodeId指定的节点加入到禁用列表中，在禁用列表内的节点不再发送 Gossip消息。<br>   禁用列表有效期是 60 秒，超过 60秒节点会再次参与消息交换。</p><p>   也就是说当第一次forget 命令发出后，我们有 60 秒的时间让集群内的所有节点忘记下线节点。</p><blockquote><p>线上操作不建议直接使用 cluster forget命令下线节点，需要跟大量节点命令交互，<br>实际操作起来过于繁琐并且容易遗漏 forget 节点。<br>建议使用redis-trib.rb del-node{host ： port} {downNodeId} 命令</p></blockquote><h2 id="五-请求路由"><a href="#五-请求路由" class="headerlink" title="五 请求路由"></a>五 请求路由</h2><h3 id="5-1请求重定向"><a href="#5-1请求重定向" class="headerlink" title="5.1请求重定向"></a>5.1请求重定向</h3><p>在集群模式下， Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；</p><p>否则回复MOVED重定向错误，通知客户端请求正确的节点。 这个过程称为MOVED重定向；</p><p>用 redis-cli 命令时，可以加入-c参数支持自动重定向，简化手动发起重定向操作；</p><p>redis-cli 自动帮我们连接到正确的节点执行命令，这个过程是在redis-cli内部维护；<br>实质上是 client 端接到 MOVED 信息之后再次发起请求，并不在Redis节点中完成请求转发；</p><blockquote><p>Redis计算键所对应的槽时<br>如果键内容包含{和}两种大括号字符，则计算槽的有效部分是括号内的内容；否则采用键的全内容计算槽。</p></blockquote><h3 id="5-2-smart客户端"><a href="#5-2-smart客户端" class="headerlink" title="5.2 smart客户端"></a>5.2 smart客户端</h3><p>Smart 客户端通过在内部维护 slot→node的映射关系，本地就可实现键到节点的查找，从而保证 IO 效率的最大化，</p><p>而 MOVED 重定向负责协助 Smart客户端更新 slot→node映射。</p><p>对 Smart客户端成本和可能存在的问题：</p><ul><li>客户端内部维护 slots缓存表，并且针对每个节点维护连接池，当集群规模非常大时，客户端会维护非常多的连接并消耗更多的内存。</li></ul><h3 id="5-3ASK重定向"><a href="#5-3ASK重定向" class="headerlink" title="5.3ASK重定向"></a>5.3ASK重定向</h3><p>Redis 集群支持在线迁移槽（ slot ）和数据来完成水平伸缩，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。</p><p>例如当一个 slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点；</p><p>当出现上述情况时，客户端键命令执行流程将发生变化：</p><ol><li>客户端根据本地 slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端。</li><li>如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK 重定向异常。<br>格式如下：（ error ） ASK{slot}{targetIP} ： {targetPort} 。</li><li>客户端从 ASK 重定向异常提取出目标节点信息，发送 asking命令到目标节点打开客户端连接标识，再执行键命令。</li></ol><blockquote><p>ASK 与 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别。</p><p>ASK 重定向说明集群正在进行 slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slots 缓存；</p><p>但是MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存；</p></blockquote><h1 id="redis集群代码实现"><a href="#redis集群代码实现" class="headerlink" title="redis集群代码实现"></a>redis集群代码实现</h1><h2 id="一-节点部分实现"><a href="#一-节点部分实现" class="headerlink" title="一 节点部分实现"></a>一 节点部分实现</h2><h3 id="1-1节点数据结构"><a href="#1-1节点数据结构" class="headerlink" title="1.1节点数据结构"></a>1.1节点数据结构</h3><p>集群中每个节点都会使用clusterNode结构记录自己的状态，并为集群中的其他节点都创建一个clusterNode结构记录其他节点状态：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>    <span class="token comment">//节点创建时间</span>    mstime_t ctime<span class="token punctuation">;</span> <span class="token comment">/* Node object creation time. */</span>    <span class="token comment">//节点的名字</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Node name, hex string, sha1-size */</span>    <span class="token comment">//节点标识,节点的角色和状态等信息</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>      <span class="token comment">/* CLUSTER_NODE_... */</span>    <span class="token comment">//节点当前配置的纪元</span>    <span class="token keyword">uint64_t</span> configEpoch<span class="token punctuation">;</span> <span class="token comment">/* Last configEpoch observed for this node */</span>    <span class="token comment">//二进制数组,这个节点所持有的slots</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* slots handled by this node */</span>    <span class="token comment">//用string标识的slots的具体信息</span>    sds slots_info<span class="token punctuation">;</span> <span class="token comment">/* Slots info represented by string. */</span>    <span class="token comment">//记录节点的槽数量</span>    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>   <span class="token comment">/* Number of slots handled by this node */</span>    <span class="token comment">//拥有的slave的数量,前提是这个节点是master</span>    <span class="token keyword">int</span> numslaves<span class="token punctuation">;</span>  <span class="token comment">/* Number of slave nodes, if this is a master */</span>    <span class="token comment">//具体拥有哪些slave数组</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span><span class="token operator">*</span>slaves<span class="token punctuation">;</span> <span class="token comment">/* pointers to slave nodes */</span>    <span class="token comment">//当前节点是slave,指向他的master(也可能是空,当前没有master节点)</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>slaveof<span class="token punctuation">;</span> <span class="token comment">/* pointer to the master node. Note that it                                    may be NULL even if the node is a slave                                    if we don't have the master node in our                                    tables. */</span>    <span class="token comment">//节点最近一次发送ping的时间</span>    mstime_t ping_sent<span class="token punctuation">;</span>      <span class="token comment">/* Unix time we sent latest ping */</span>    <span class="token comment">//节点最近一次接收到ping的时间</span>    mstime_t pong_received<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received the pong */</span>    <span class="token comment">//接收到数据的时间</span>    mstime_t data_received<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received any data */</span>    mstime_t fail_time<span class="token punctuation">;</span>      <span class="token comment">/* Unix time when FAIL flag was set */</span>    mstime_t voted_time<span class="token punctuation">;</span>     <span class="token comment">/* Last time we voted for a slave of this master */</span>    mstime_t repl_offset_time<span class="token punctuation">;</span>  <span class="token comment">/* Unix time we received offset for this node */</span>    mstime_t orphaned_time<span class="token punctuation">;</span>     <span class="token comment">/* Starting time of orphaned master condition */</span>    <span class="token comment">//最近的偏移量,用处很多</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_offset<span class="token punctuation">;</span>      <span class="token comment">/* Last known repl offset for this node. */</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Latest known IP address of this node */</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span>                   <span class="token comment">/* Latest known clients port (TLS or plain). */</span>    <span class="token keyword">int</span> pport<span class="token punctuation">;</span>                  <span class="token comment">/* Latest known clients plaintext port. Only used                                   if the main clients port is for TLS. */</span>    <span class="token keyword">int</span> cport<span class="token punctuation">;</span>                  <span class="token comment">/* Latest known cluster port of this node. */</span>    <span class="token comment">//保存与当前节点有链接的节点</span>    clusterLink <span class="token operator">*</span>link<span class="token punctuation">;</span>          <span class="token comment">/* TCP/IP link with this node */</span>    list <span class="token operator">*</span>fail_reports<span class="token punctuation">;</span>         <span class="token comment">/* List of nodes signaling this as failing */</span><span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre><p>clusterNode中link属性保存了连接节点所需要的有关信息（与redisClient结构的连接到客户端有所不同，用于连接其他的节点）：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterLink</span> <span class="token punctuation">{</span>    <span class="token comment">//连接创建时间</span>    mstime_t ctime<span class="token punctuation">;</span>             <span class="token comment">/* Link creation time */</span>    <span class="token comment">//远程连接结构体</span>    connection <span class="token operator">*</span>conn<span class="token punctuation">;</span>           <span class="token comment">/* Connection to remote node */</span>    <span class="token comment">//输出缓冲区,保存需要发送给其他节点的信息</span>    sds sndbuf<span class="token punctuation">;</span>                 <span class="token comment">/* Packet send buffer */</span>    <span class="token comment">//输入缓冲区,报讯其他节点发送过来的消息</span>    <span class="token keyword">char</span> <span class="token operator">*</span>rcvbuf<span class="token punctuation">;</span>               <span class="token comment">/* Packet reception buffer */</span>    size_t rcvbuf_len<span class="token punctuation">;</span>          <span class="token comment">/* Used size of rcvbuf */</span>    size_t rcvbuf_alloc<span class="token punctuation">;</span>        <span class="token comment">/* Allocated size of rcvbuf */</span>    <span class="token comment">//该连接所关联的节点</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>   <span class="token comment">/* Node related to this link if any, or NULL */</span><span class="token punctuation">}</span> clusterLink<span class="token punctuation">;</span></code></pre><p>每个节点都会保存一个clusterState结构（server.h/redisServer –&gt; cluster.h/clusterState）;用来记录当前集群所处的状态；</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * 集群状态 * 入口:  server.h/struct redisServer --&gt; clusterState; * 初始化入口：server.c/initServer() --&gt; cluster.c/clusterInit() */</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>    <span class="token comment">//指向当前服务器节点</span>    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>  <span class="token comment">/* This node */</span>    <span class="token comment">//节点纪元,故障转移使用</span>    <span class="token keyword">uint64_t</span> currentEpoch<span class="token punctuation">;</span>    <span class="token comment">//整个集群的状态,上线/下线</span>    <span class="token keyword">int</span> state<span class="token punctuation">;</span>            <span class="token comment">/* CLUSTER_OK, CLUSTER_FAIL, ... */</span>    <span class="token comment">//集群中至少处理着一个槽的节点的数量</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>             <span class="token comment">/* Num of master nodes with at least one slot */</span>    <span class="token comment">//name-&gt;clusterNode的键值对</span>    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>          <span class="token comment">/* Hash table of name -&gt; clusterNode structures */</span>    dict <span class="token operator">*</span>nodes_black_list<span class="token punctuation">;</span> <span class="token comment">/* Nodes we don't re-add for a few seconds. */</span>    clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//记录槽的指派信息,数组的每个值对应于负责该槽的节点</span>    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    clusterSlotsToKeysData slots_to_keys<span class="token punctuation">;</span>    <span class="token comment">/* The following fields are used to take the slave state on elections. */</span>    <span class="token comment">//选举时获取slave的状态</span>    mstime_t failover_auth_time<span class="token punctuation">;</span> <span class="token comment">/* Time of previous or next election. */</span>    <span class="token comment">//故障转移收到的票数</span>    <span class="token keyword">int</span> failover_auth_count<span class="token punctuation">;</span>    <span class="token comment">/* Number of votes received so far. */</span>    <span class="token comment">//是否已经向其他节点请求投票给自己</span>    <span class="token keyword">int</span> failover_auth_sent<span class="token punctuation">;</span>     <span class="token comment">/* True if we already asked for votes. */</span>    <span class="token keyword">int</span> failover_auth_rank<span class="token punctuation">;</span>     <span class="token comment">/* This slave rank for current auth request. */</span>    <span class="token keyword">uint64_t</span> failover_auth_epoch<span class="token punctuation">;</span> <span class="token comment">/* Epoch of the current election. */</span>    <span class="token comment">//slave节点不能故障转移的原因</span>    <span class="token keyword">int</span> cant_failover_reason<span class="token punctuation">;</span>   <span class="token comment">/* Why a slave is currently not able to                                   failover. See the CANT_FAILOVER_* macros. */</span>            <span class="token comment">//需要手动转移故障,记录当前状态</span>    <span class="token comment">/* Manual failover state in common. */</span>    <span class="token comment">//手动故障切换时间限制（ms unixtime）。</span>    <span class="token comment">//如果没有正在进行的manual failover,则为零</span>    mstime_t mf_end<span class="token punctuation">;</span>            <span class="token comment">/* Manual failover time limit (ms unixtime).                                   It is zero if there is no MF in progress. */</span>    <span class="token comment">/* Manual failover state of master. */</span>    <span class="token comment">//mester的手动故障转移状态</span>    clusterNode <span class="token operator">*</span>mf_slave<span class="token punctuation">;</span>      <span class="token comment">/* Slave performing the manual failover. */</span>    <span class="token comment">/* Manual failover state of slave. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> mf_master_offset<span class="token punctuation">;</span> <span class="token comment">/* Master offset the slave needs to start MF                                   or -1 if still not received. */</span>    <span class="token keyword">int</span> mf_can_start<span class="token punctuation">;</span>           <span class="token comment">/* If non-zero signal that the manual failover                                   can start requesting masters vote. */</span>    <span class="token comment">/* The following fields are used by masters to take state on elections. */</span>    <span class="token keyword">uint64_t</span> lastVoteEpoch<span class="token punctuation">;</span>     <span class="token comment">/* Epoch of the last vote granted. */</span>    <span class="token keyword">int</span> todo_before_sleep<span class="token punctuation">;</span> <span class="token comment">/* Things to do in clusterBeforeSleep(). */</span>    <span class="token comment">/* Messages received and sent by type. */</span>    <span class="token comment">//按照消息类型进行接受和发送</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_bus_messages_sent<span class="token punctuation">[</span>CLUSTERMSG_TYPE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_bus_messages_received<span class="token punctuation">[</span>CLUSTERMSG_TYPE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> stats_pfail_nodes<span class="token punctuation">;</span>    <span class="token comment">/* Number of nodes in PFAIL status,                                       excluding nodes without address. */</span><span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre><p>一个实际的例子：</p><p><img src="/2022/03/05/redis-cluster/image-20211127204524760.png" alt="image-20211127204524760"></p><h3 id="1-2-cluster-meet命令的实现"><a href="#1-2-cluster-meet命令的实现" class="headerlink" title="1.2 cluster meet命令的实现"></a>1.2 cluster meet命令的实现</h3><p>[指令实现](#节点握手cluster meet)</p><p>向节点A发送cluster meet将节点B加入到集群中</p><pre class="language-bash" data-language="bash"><code class="language-bash">CLUSTER MEET <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span></code></pre><p>节点握手过程如下图：(类似于TCP的三次握手)<br><img src="/2022/03/05/redis-cluster/20210205165842362.png" alt="img"></p><p>cluster meet 命令的入口位于 cluster.c/clusterCommand()</p><h2 id="二-槽指派"><a href="#二-槽指派" class="headerlink" title="二 槽指派"></a>二 槽指派</h2><p>[指令实现](#分配槽cluster addslots)</p><p>每个槽都要有节点处理，要是有槽没有对应的节点，集群就处于下线状态</p><h3 id="2-1节点记录槽信息"><a href="#2-1节点记录槽信息" class="headerlink" title="2.1节点记录槽信息"></a>2.1节点记录槽信息</h3><p><strong>clusterNode</strong>结构体中的slots属性是个二进制数组，数组长度16384/8=2048个字节，记录了节点具体负责了哪个节点；例如，slots[111] = 1,表示该节点负责了编号111的槽；为0就表示不负责</p><p><img src="/2022/03/05/redis-cluster/image-20211128131539486.png" alt="image-20211128131539486"></p><p>numslots属性记录了节点负责槽的数量；</p><h3 id="2-2传播节点的槽指派信息"><a href="#2-2传播节点的槽指派信息" class="headerlink" title="2.2传播节点的槽指派信息"></a>2.2传播节点的槽指派信息</h3><p>节点除了会记录自己负责的槽信息，还会将自己负责的槽信息发送给其他节点</p><p>通过发送slots数组信息实现，接收到其他节点发来的消息之后就保存在对应于那个节点的clusterNode结构里面</p><h3 id="2-3记录集群所有槽的指派信息"><a href="#2-3记录集群所有槽的指派信息" class="headerlink" title="2.3记录集群所有槽的指派信息"></a>2.3记录集群所有槽的指派信息</h3><p>每个节点都有的clusterState结构中的slots是clusterNode数组，值是一个指向clusterNode的指针，记录了每个槽是由哪个节点负责的；</p><p>如果槽没有节点负责，则slot对应的数组值是NULL;</p><p>如果需要检查某个槽是否有节点负责，可以通过查询clusterState的slots高效解决；</p><p><img src="/2022/03/05/redis-cluster/image-20211128134512270.png" alt="image-20211128134512270"></p><blockquote><p>节点和服务器都有slots数组，节点的本地数组记录了自己管理的槽的信息，而</p></blockquote><h3 id="2-4CLUSTER-ADDSLOTS命令的实现"><a href="#2-4CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="2.4CLUSTER ADDSLOTS命令的实现"></a>2.4CLUSTER ADDSLOTS命令的实现</h3><p>cluster addslots 命令接受一个或者多个槽作为参数，并将输入的槽指派给接受该命令的节点；</p><p>cluster addslots 主要操作可以分为两步：</p><ol><li>更新myself节点的 slots属性bit位置标记为1。标识该槽由myself节点负责</li><li>更新clusterStatus属性的slots 数组对应的槽指向 myself节点；标识对应槽是由哪个节点负责的</li></ol><p><strong>代码入口 cluster.c/clusterCommand() ==&gt;  cluster.c/clusterAddSlot()</strong></p><p>开始创建的一个没有指派任何槽的节点</p><p><img src="/2022/03/05/redis-cluster/image-20211128184145276.png" alt="image-20211128184145276"></p><p>执行指令<code>CLUSTER&nbsp;ADDSLOTS&nbsp;1&nbsp;2</code>之后变成：</p><p><img src="/2022/03/05/redis-cluster/image-20211128184438831.png" alt="image-20211128184438831"></p><p>还会发布消息告诉其他节点，自己正在负责这些槽</p><p> <strong>cluster.c/clusterAddSlot()</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* Add the specified slot to the list of slots that node 'n' will * serve. Return C_OK if the operation ended with success. * If the slot is already assigned to another instance this is considered * an error and C_ERR is returned. */</span><span class="token comment">//将指定的插槽添加到节点n负责的插槽列表中</span><span class="token keyword">int</span> <span class="token function">clusterAddSlot</span><span class="token punctuation">(</span>clusterNode <span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//插槽已经被分配了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">//更新n的slots属性随用的slot的bit位为1,表示负责这个节点</span>    <span class="token function">clusterNodeSetSlotBit</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>slot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//更新clusterStatus的slots数组,使对应的槽指向myself节点,表示这个槽是由自己负责的</span>    server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三-集群中执行命令"><a href="#三-集群中执行命令" class="headerlink" title="三 集群中执行命令"></a>三 集群中执行命令</h2><p>在集群中执行命令，整理流程如下<br><img src="/2022/03/05/redis-cluster/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2Mzk5OTkx,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>例子， 如果我们在之前提到的， 由 7000、 7001、 7002 三个节点组成的集群中， 用客户端连上节点 7000, 并发送以下命令， 那么命令会直接被节点 7000 执行:</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set date "2021-12-31"</code></pre><p>因为键date所在的槽2022刚好是7000负责的，如果是执行</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set msg "happy new year"</code></pre><p>msg所在的槽6257就不是7000负责的了，就需要</p><ul><li>当客户端第一次向节点 7000 发送命令的时候， 节点 7000 会向客户端返回MOVED 错误， 指引客户端转向至节点 7001。</li><li>当客户端转向到节点 7001 之后， 客户端重新向节点 7001 发送命令， 这个命令会被节点 7001 成功执行。</li></ul><p>流程是这样的：</p><pre class="language-none"><code class="language-none">127.0.0.1:7000&gt;set msg "happy new year"-&gt;Redirected to slot [ 6257] located at 127.0.0.1:7001OK127.0.0.1:7001&gt;GET msghappy new year</code></pre><p>  用7001可以直接得到msg对应的值，不需要重定向</p><p>命令执行的入口位于：<strong>server.c/processCommand()</strong> ==&gt; <strong>cluster.c/getNodeByQuery()</strong></p><p>计算键属于哪个槽、判断槽是否当前节点负责、MOVED错误 几个关系操作都是由 getNodeByQuery() 完成的；</p><p>执行流程如下</p><p><img src="/2022/03/05/redis-cluster/1478675-20190530112923984-1840717246.png" alt="img"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * 返回指向能够为命令提供服务的集群节点的指针。 * 要使函数成功，命令应仅针对以下任一目标： * 1） 命令只有一个key时（甚至像LPOPRPUSH mylist mylist那样多次）。 * 2） 在同一个哈希槽中有多个key，而该槽是稳定的（没有正在进行的重新哈希）。 */</span>clusterNode <span class="token operator">*</span><span class="token function">getNodeByQuery</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>hashslot<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>error_code<span class="token punctuation">)</span> <span class="token punctuation">{</span>    clusterNode <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    robj <span class="token operator">*</span>firstkey <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> multiple_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    multiState <span class="token operator">*</span>ms<span class="token punctuation">,</span> _ms<span class="token punctuation">;</span>    multiCmd mc<span class="token punctuation">;</span>    <span class="token comment">// migrating_slot标记slot正在迁移操作， 当前节点是迁移的源节点</span>    <span class="token comment">// importing_slot标记slot正在迁移操作， 当前节点是迁移的目标节点</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> migrating_slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> importing_slot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> missing_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//如果模块禁用了集群重定向,就是允许设置任何key(没有分配槽的说法),直接可以用当前节点处理</span>    <span class="token comment">/* Allow any key to be set if a module disabled cluster redirections. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster_module_flags <span class="token operator">&amp;</span> CLUSTER_MODULE_FLAG_NO_REDIRECTION<span class="token punctuation">)</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">/* Set error code optimistically for the base case. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_NONE<span class="token punctuation">;</span>    <span class="token comment">/* Modules can turn off Redis Cluster redirection: this is useful     * when writing a module that implements a completely different     * distributed system. */</span>    <span class="token comment">//模块可以关闭集群重定向,利于编写实现完全不同的分布式系统的模块</span>    <span class="token comment">/* We handle all the cases as if they were EXEC commands, so we have     * a common code path for everything */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* If CLIENT_MULTI flag is not set EXEC is just going to return an         * error. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MULTI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> myself<span class="token punctuation">;</span>        ms <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">/* In order to have a single codepath create a fake Multi State         * structure if the client is not in MULTI/EXEC state, this way         * we have a single codepath below. */</span>        ms <span class="token operator">=</span> <span class="token operator">&amp;</span>_ms<span class="token punctuation">;</span>        _ms<span class="token punctuation">.</span>commands <span class="token operator">=</span> <span class="token operator">&amp;</span>mc<span class="token punctuation">;</span>        _ms<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>argv <span class="token operator">=</span> argv<span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>argc <span class="token operator">=</span> argc<span class="token punctuation">;</span>        mc<span class="token punctuation">.</span>cmd <span class="token operator">=</span> cmd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//检查所有的key是否在同一个哈希槽中,并且获取槽和负责槽的节点</span>    <span class="token comment">/* Check that all the keys are in the same hash slot, and obtain this     * slot and the node associated. */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ms<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>mcmd<span class="token punctuation">;</span>        robj <span class="token operator">*</span><span class="token operator">*</span>margv<span class="token punctuation">;</span>        <span class="token keyword">int</span> margc<span class="token punctuation">,</span> <span class="token operator">*</span>keyindex<span class="token punctuation">,</span> numkeys<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        mcmd <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cmd<span class="token punctuation">;</span>        margc <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>argc<span class="token punctuation">;</span>        margv <span class="token operator">=</span> ms<span class="token operator">-&gt;</span>commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>argv<span class="token punctuation">;</span>        getKeysResult result <span class="token operator">=</span> GETKEYS_RESULT_INIT<span class="token punctuation">;</span>        numkeys <span class="token operator">=</span> <span class="token function">getKeysFromCommand</span><span class="token punctuation">(</span>mcmd<span class="token punctuation">,</span>margv<span class="token punctuation">,</span>margc<span class="token punctuation">,</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        keyindex <span class="token operator">=</span> result<span class="token punctuation">.</span>keys<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numkeys<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//计算key所属的slot,用thisslot记录下来</span>            robj <span class="token operator">*</span>thiskey <span class="token operator">=</span> margv<span class="token punctuation">[</span>keyindex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> thisslot <span class="token operator">=</span> <span class="token function">keyHashSlot</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>thiskey<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span>                                       <span class="token function">sdslen</span><span class="token punctuation">(</span>thiskey<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstkey <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//key就是这个slot中的第一个节点</span>                <span class="token comment">/* This is the first key we see. Check what is the slot                 * and node. */</span>                firstkey <span class="token operator">=</span> thiskey<span class="token punctuation">;</span>                slot <span class="token operator">=</span> thisslot<span class="token punctuation">;</span>                <span class="token comment">//n获取负责这个slot的节点</span>                n <span class="token operator">=</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">/* Error: If a slot is not served, we are in "cluster down"                 * state. However the state is yet to be updated, so this was                 * not trapped earlier in processCommand(). Report the same                 * error to the client. */</span>                <span class="token comment">/*                 *  如果这个节点还没节点负责，还在cluster down状态；                 *  但是，该状态尚未更新，因此在processCommand（）中没有捕获到该状态。                 * 向客户端报告相同的错误。                 */</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span>                        <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_UNBOUND<span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">/* If we are migrating or importing this slot, we need to check                 * if we have all the keys in the request (the only way we                 * can safely serve the request, otherwise we return a TRYAGAIN                 * error). To do so we set the importing/migrating state and                 * increment a counter for every missing key. */</span>                <span class="token comment">/*                 * 如果要迁移或导入此槽，则需要检查请求中有所有的key                 //（只有这样才能安全地为请求提供服务，否则返回TRYAGAIN错误）                 * 为此，需要设置导入/迁移状态，并为每个缺少的键增加一个计数器。                 */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> myself <span class="token operator">&amp;&amp;</span>                    server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>migrating_slots_to<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment">//标记正在进行迁移,作为源节点</span>                    migrating_slot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>importing_slots_from<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//标记正在迁移,作为目标节点</span>                    importing_slot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">/* If it is not the first key, make sure it is exactly                 * the same key as the first we saw. */</span>                <span class="token comment">//确保后续的key和前面看到的第一个key在同一个槽里面</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">equalStringObjects</span><span class="token punctuation">(</span>firstkey<span class="token punctuation">,</span>thiskey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>slot <span class="token operator">!=</span> thisslot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">//虽然slot最开始初始化为0,但是之前那个if一定是已经执行过一次以上了,</span>                        <span class="token comment">//就保证了一直处理的都是一个slot里面的key</span>                        <span class="token comment">/* Error: multiple keys from different slots. */</span>                        <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span>                            <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_CROSS_SLOT<span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">//标记,记录这个指令包含了不同的key(虽然刚好是同一个slot)</span>                        <span class="token comment">//todo:这个概率是不是很低啊?</span>                        <span class="token comment">/* Flag this request as one with multiple different                         * keys. */</span>                        multiple_keys <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">/* Migrating / Importing slot? Count keys we don't have. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>migrating_slot <span class="token operator">||</span> importing_slot<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">lookupKeyRead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>thiskey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                missing_keys<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//释放keyindex</span>        <span class="token function">getKeysFreeResult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//指令之中本来就没有key</span>    <span class="token comment">/* No key at all in command? then we can serve the request     * without redirections or errors in all the cases. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">//集群并不是在线状态,在allow_reads_when_down打开的时候允许读</span>    <span class="token comment">/* Cluster is globally down but we got keys? We only serve the request     * if it is a read command and when allow_reads_when_down is enabled. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>state <span class="token operator">!=</span> CLUSTER_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>cluster_allow_reads_when_down<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">/* The cluster is configured to block commands when the             * cluster is down. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_STATE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">/* The cluster is configured to allow read only commands */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_DOWN_RO_STATE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//不做处理,继续执行后面的代码,在本地进行读</span>            <span class="token comment">/* Fall through and allow the command to be executed:             * this happens when server.cluster_allow_reads_when_down is             * true and the command is not a write command */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Return the hashslot by reference. */</span>    <span class="token comment">//返回slot(引用返回,返回多个值的办法)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hashslot<span class="token punctuation">)</span> <span class="token operator">*</span>hashslot <span class="token operator">=</span> slot<span class="token punctuation">;</span>    <span class="token comment">/* MIGRATE always works in the context of the local node if the slot     * is open (migrating or importing state). We need to be able to freely     * move keys among instances in this case. */</span>    <span class="token comment">/*     * 如果槽处于 "迁移或导入状态"，则迁移始终在本地节点的上下文中工作。     * 在这种情况下，我们需要能够在实例之间自由移动键。     */</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>migrating_slot <span class="token operator">||</span> importing_slot<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> migrateCommand<span class="token punctuation">)</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token comment">/* If we don't have all the keys and we are migrating the slot, send     * an ASK redirection. */</span>    <span class="token comment">//节点处于迁移状态，当前节点是迁移的源节点，并且key不在当前节点，返回ASK错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>migrating_slot <span class="token operator">&amp;&amp;</span> missing_keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_ASK<span class="token punctuation">;</span>        <span class="token keyword">return</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>migrating_slots_to<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     * 如果我们正在接收槽，并且client正确地将请求标记为“ASKING”，我们就可以为请求提供服务     * 但是，如果请求涉及多个key，而我们没有全部key，那么唯一的选择就是发送一个trygain错误     * 等待所有的key迁移完毕之后再进行查询     */</span>    <span class="token comment">/* If we are receiving the slot, and the client correctly flagged the     * request as "ASKING", we can serve the request. However if the request     * involves multiple keys and we don't have them all, the only option is     * to send a TRYAGAIN error. */</span>    <span class="token comment">//当前节点是迁移节点的目标节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>importing_slot <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_ASKING <span class="token operator">||</span> cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_ASKING<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple_keys <span class="token operator">&amp;&amp;</span> missing_keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_UNSTABLE<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> myself<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Handle the read-only client case reading from a slave: if this     * node is a slave and the request is about a hash slot our master     * is serving, we can reply without redirection. */</span>    <span class="token keyword">int</span> is_write_command <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span> <span class="token operator">||</span>                           <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">==</span> execCommand <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>mstate<span class="token punctuation">.</span>cmd_flags <span class="token operator">&amp;</span> CMD_WRITE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_READONLY <span class="token operator">&amp;&amp;</span>        <span class="token operator">!</span>is_write_command <span class="token operator">&amp;&amp;</span>        <span class="token function">nodeIsSlave</span><span class="token punctuation">(</span>myself<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        myself<span class="token operator">-&gt;</span>slaveof <span class="token operator">==</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> myself<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回moved错误,需要重定向</span>    <span class="token comment">/* Base case: just return the right node. However if this node is not     * myself, set error_code to MOVED since we need to issue a redirection. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> myself <span class="token operator">&amp;&amp;</span> error_code<span class="token punctuation">)</span> <span class="token operator">*</span>error_code <span class="token operator">=</span> CLUSTER_REDIR_MOVED<span class="token punctuation">;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p> 分别实现如下</p><h3 id="计算节点属于哪个槽"><a href="#计算节点属于哪个槽" class="headerlink" title="计算节点属于哪个槽"></a>计算节点属于哪个槽</h3><p>直接根据key的哈希算法计算当前key应该属于的槽i</p><h3 id="判断槽是否由当前节点处理"><a href="#判断槽是否由当前节点处理" class="headerlink" title="判断槽是否由当前节点处理"></a>判断槽是否由当前节点处理</h3><p>在clusterState.slots[]数组中查找第i项，并与clusterState.myself作比较：</p><ul><li>如果刚好是这个节点负责，就直接处理该指令</li><li>如果不是，根据记录中指定的节点ip和端口号返回moved错误，使客户端指向正确的节点</li></ul><h3 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h3><p>用于引导正确的节点，格式为<code>MOVED&nbsp;&lt;slot&gt;&nbsp;&lt;ip&gt;:&lt;port&gt;</code>，由客户端自动处置，不会在命令行显示出来。</p><p><img src="/2022/03/05/redis-cluster/image-20211128221010442.png" alt="image-20211128221010442"></p><h3 id="节点数据库实现"><a href="#节点数据库实现" class="headerlink" title="节点数据库实现"></a>节点数据库实现</h3><p>只能使用一个数据库（0号数据库），其他的实现和单机数据库没有什么区别</p><h2 id="四-重新分片"><a href="#四-重新分片" class="headerlink" title="四 重新分片"></a>四 重新分片</h2><p>重新分片操作可以将任意数量已经指派给某个节点（ 源节点 ） 的槽改为指派给另一个节点（ 目标节点 ）， 并且相关槽所属的键值对也会从源节点被移动到目标节点。<br>重新分片操作可以在线（ online ) 进行， 在重新分片的过程中， 集群不需要下线， 并且源节点和目标节点都可以继续处理命令请求。</p><h2 id="五-ASK错误"><a href="#五-ASK错误" class="headerlink" title="五 ASK错误"></a>五 ASK错误</h2><p>重新分片的过程中可能槽中一部分键在源节点中，而有一部分键已经移动到目标节点了，这时候客户端对于源节点发送针对相关键的请求：</p><ul><li>源节点会先在自己的数据库里面査找指定的键， 如果找到的话， 就直接执行客户端发送的命令。</li><li>相反地， 如果源节点没能在自己的数据库里面找到指定的键， 那么这个键有可能已经被迁移到了目标节点， 源节点将向客户端返回一个 ASK 错误， 指引客户端转向正在导人槽的目标节点， 并再次发送之前想要执行的命令。</li><li>todo：会不会有一个中间状态，两边都没有保存这个key</li></ul><p><img src="/2022/03/05/redis-cluster/image-20211129170705088.png" alt="image-20211129170705088"></p><p>客户端也不会显示错误，直接根据返回的ASK错误转向合适的节点请求数据</p><h3 id="Cluster-SetSlot-Importing命令的实现"><a href="#Cluster-SetSlot-Importing命令的实现" class="headerlink" title="Cluster SetSlot Importing命令的实现"></a>Cluster SetSlot Importing命令的实现</h3><p>cluster setslot importing是进行重新分片的第一步，redis-trib向目标节点发送该命令，准备好接收源节点的指定槽。</p><p>关于被导入的数组，是会被记录在目标节点的importing_slots_form数组中的，这个数组是一个clusterNode数组，是用来记录当前节点正在从哪些节点导入槽</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span><span class="token punctuation">(</span><span class="token comment">//..</span>    clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//..</span><span class="token punctuation">)</span>clusterState<span class="token punctuation">;</span></code></pre><p>可以看到这是一个clusterNode数组，但容量却是16384，对应的是槽的数量，使用索引i记录槽</p><p>假如importing_slots_from[i]指向的不是空，而是一个具体的clusterNode结构，那么就代表当前节点正在从这个clusterNode对应的节点导入槽i。</p><p>在对集群进行重新分片的时候，第一个命令是</p><pre class="language-redis" data-language="redis"><code class="language-redis">cluster setslot &lt;i&gt; importing &lt;source_id&gt;</code></pre><p>i代表的是16384个槽中的哪个槽，source_id是代表节点在集群里面的runid</p><p>这条命令的作用其实就是，当目标节点接收到这条命令，<strong>会修改importing_slots_from数组，在索引为i的位置上，放入source_id对应的clusterNode结构</strong>。<br><img src="/2022/03/05/redis-cluster/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><h3 id="cluster-setslot-migrating命令的实现"><a href="#cluster-setslot-migrating命令的实现" class="headerlink" title="cluster setslot migrating命令的实现"></a>cluster setslot migrating命令的实现</h3><p>cluster setslot migrating命令是对于第二个步骤，就是redis-trib向源节点发送该命令，让源节点准备发送槽的count个键值对。</p><p>在clusterState结构里面是使用一个migrating_slots_to数组来记录了当前节点正在迁移至其他节点的槽，也是一个clusterNode数组</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span><span class="token punctuation">(</span><span class="token comment">//...</span>    clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span>CLUSTER_SLOTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">)</span>clusterState<span class="token punctuation">;</span></code></pre><p>这个与importing_slots_from一样，也是使用索引代表槽，然后对应数组的位置有没有节点，去代表该槽是否正在被发送中，发送给里面对应的clusterNode</p><p>在对集群进行重新分片的时候，会向源节点发送命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">cluster setslots <span class="token operator">&lt;</span>i<span class="token operator">&gt;</span> migrating <span class="token operator">&lt;</span>target_id<span class="token operator">&gt;</span></code></pre><p>i就代表槽的位置，target_id对应目标节点在集群中的runid。</p><p><strong>当源节点收到该命令的时候，就会在migrating_slots_to[i]里保存target_id对应的custerNode节点</strong><br><img src="/2022/03/05/redis-cluster/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216901.png" alt="在这里插入图片描述"><br>跟importing_slots_from很类似</p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>前面提到过，如果节点收到一个关于键Key的命令请求，会先去计算这个键属于的是哪个槽，然后看这个槽是不是被委派给当前节点，如果是，就自己进行执行，如果不是就发送MOVED指令，指引客户端去找正确的节点。</p><p>假设，现在槽是委派给当前节点的，<strong>那么当前节点就回去数据库（集群节点的数据库只会使用0号数据库）里找，找的时候会先检查自己的clusterState.migrating_slots_to[i]（i是指定的槽）是否为空，如果为空就代表该槽没有进行转移，去数据库里面找，如果不为空，那么发送一个ASK错误，指引客户端到导入槽i的节点去查找键key</strong>。</p><p><strong>接收到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送自己想要执行的命令</strong>。<br><img src="/2022/03/05/redis-cluster/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216902.png" alt="在这里插入图片描述"></p><h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的<strong>REDIS_ASKING标识</strong></p><pre class="language-code" data-language="code"><code class="language-code">def ASKING():#打开REDIS_ASKING标识client.flags |= REDIS_ASKING#向客户端返回OK回复reply("ok")12345</code></pre><p>在一般情况下，客户端向节点发送一个关于槽i的命令，而槽又不是被委派给这个节点的，那么是会返回一个MOVED错误给客户端的，<strong>但如果此时该节点的ckusterState.importing_slots_from[i]显示节点正在导入槽i，而且发来的命令带有REDIS_ASKING标识</strong>，那么节点将破例执行这个关于槽i的命令一次。<br><img src="/2022/03/05/redis-cluster/image-20211129180546751.png" alt="image-20211129180546751"><br><strong>这里要注意的是，客户端的REDIS_ASKING标识是一个一次性的标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除，以后的命令都不会带有该标识了</strong></p><h3 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h3><p>ASK错误和MOVED错误都会导致客户端转向，他们的区别如下所示</p><ul><li>MOVED错误<strong>代表槽的负责权已经从一个节点转移到了另一个节点</strong>；在客户端收到关于槽i的MOVED错误之后，<strong>客户端下次的每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点（因为已经建立了套接字连接，而且记录了该键是在之前MOVED错误所指向的节点处）</strong></li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施，在客户端收到关于槽i的ASK错误之后，<strong>客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点</strong>，但这种转向客户端并不会记录下来，所以不会对客户端今后发送关于槽i的命令产生任何的影响，客户端发送请求仍然会请求到目前负责处理槽i的节点，除非ASK、MOVED错误出现。</li></ul><p>MOVED错误的过程<br><img src="/2022/03/05/redis-cluster/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216914.png" alt="在这里插入图片描述"><br>ASKING错误的过程<br><img src="/2022/03/05/redis-cluster/../learningMaterials/redis_learning/leehm/notes/redis%E9%9B%86%E7%BE%A4.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEVVRfVHJpbQ==,size_16,color_FFFFFF,t_70#pic_center-16381779216915.png" alt="在这里插入图片描述"></p><h2 id="四-复制与故障转移"><a href="#四-复制与故障转移" class="headerlink" title="四 复制与故障转移"></a>四 复制与故障转移</h2><p>Redis中节点分为主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点；</p><p>当主节点下线时，从节点将成为主节点，替代主节点处理命令请求；下线主节点重新上线时，将成为从节点；</p><p>当从节点开始复制主节点，也会通过消息告诉集群中的其他节点</p><h3 id="4-1设置从节点-CLUSTER-REPLICATE"><a href="#4-1设置从节点-CLUSTER-REPLICATE" class="headerlink" title="4.1设置从节点 CLUSTER REPLICATE "></a>4.1设置从节点 CLUSTER REPLICATE <node_id></node_id></h3><p>CLUSTER REPLICATE <node_id> 让接受到命令的节点设置为从节点， 复制node_id节点；</node_id></p><p>CLUSTER REPLICATE命令的实现入口位于：<strong>cluster.c/clusterCommand</strong> ==&gt; replicate</p><p>clusterCommand函数接受到replicate命令后主要做了一下几件事：</p><ul><li>在自己的clusterState的nodes属性中查找参数的node节点；</li><li>判断当前节点是否可以设置复制。<br>是否是自己复制自己？<br>参数中的node节点是否是从节点？<br>当前节点是否分配了槽？<br>……</li></ul><p>复合要求设置条件后，调用clusterSetMaster函数，clusterSetMaster主要用于修正clusterState中的属性值（可以参考下面贴出的注释）；</p><p> 之后还需要设置当前节点为从节点，代码实现在<strong>clster.c/clusterSetMaster</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将指定的节点n设置成当前节点的master，如果当前节点是master也会转换成slave</span><span class="token keyword">void</span> <span class="token function">clusterSetMaster</span><span class="token punctuation">(</span>clusterNode <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//复制的对象不能是自己</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当前节点没有分配槽</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>numslots <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">nodeIsMaster</span><span class="token punctuation">(</span>myself<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//当前节点是master</span>        <span class="token comment">//将当前节点的CLUSTER_NODE_MASTER和CLUSTER_NODE_MIGRATE_TO取反(因为时slave不可以再MIGRATE_TO)</span>        myself<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>CLUSTER_NODE_MASTER<span class="token operator">|</span>CLUSTER_NODE_MIGRATE_TO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将点钱节点设置为slave</span>        myself<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLUSTER_NODE_SLAVE<span class="token punctuation">;</span>        <span class="token function">clusterCloseAllSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//当前节点不是master</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>slaveof<span class="token punctuation">)</span>            <span class="token comment">//将当前节点从原来的master的slave列表中移除</span>            <span class="token function">clusterNodeRemoveSlave</span><span class="token punctuation">(</span>myself<span class="token operator">-&gt;</span>slaveof<span class="token punctuation">,</span>myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//设置当前节点复制指定的节点n</span>    myself<span class="token operator">-&gt;</span>slaveof <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token comment">//给节点n添加当前节点作为slave</span>    <span class="token function">clusterNodeAddSlave</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>myself<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//复制n的信息</span>    <span class="token function">replicationSetMaster</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>ip<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resetManualFailover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/03/05/redis-cluster/image-20211129185032653.png" alt="image-20211129185032653"></p><p><img src="/2022/03/05/redis-cluster/image-20211129190657841.png" alt="image-20211129190657841"></p><h3 id="4-2故障检测"><a href="#4-2故障检测" class="headerlink" title="4.2故障检测"></a>4.2故障检测</h3><p>集群中每个节点会定期向其他节点发送PING消息，如果规定时间内没有返回PONG消息，则会将该节点标记为P_FAIL(疑似下线 probable fail)；</p><p><img src="/2022/03/05/redis-cluster/image-20211129190723670.png" alt="image-20211129190723670"></p><p>各个节点会相互交换消息，确认各个节点的状态</p><p>当节点A通过消息得知节点B认为节点C疑似下线之后，就会在自己的clusterState.nodes 字典中找到主节点 C 所对应的 clusterNode 结构，将节点B 的下线报告（ failure report ) 添加到节点c的clusterNode 结构的 fail_reports  链表中。</p><p>节点的下线报告结构如下：（记录的就是发出报告的节点指针和上次报告的时间）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterNodeFailReport</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>  <span class="token comment">/* Node reporting the failure condition. */</span>    <span class="token class-name">mstime_t</span> time<span class="token punctuation">;</span>             <span class="token comment">/* Time of the last report from this node. */</span><span class="token punctuation">}</span> clusterNodeFailReport<span class="token punctuation">;</span></code></pre><p><img src="/2022/03/05/redis-cluster/image-20211129194942175.png" alt="image-20211129194942175"></p><p>注意这个是保存在7001那里的，前面还有他的ClusterState结构，指向7001保存的7000node相关信息。</p><p>如果某节点发现集群中超过半数已经以上的主节点 将x节点标记为P_FAIL,那么x节点将被标记为FAIL（客观下线），这个节点还会向集群广播x节点的FAIL下线消息，收到消息的节点都会直接把x节点标记为下线</p><h3 id="4-3故障转移"><a href="#4-3故障转移" class="headerlink" title="4.3故障转移"></a>4.3故障转移</h3><p>当一个从节点得知自己复制的master进入FAIL下线状态时，从节点将开始对主节点进行故障转移：</p><ul><li>从slave中选取一个主节点；（通过其他所有负责槽的主节点投票产生，也使用了配置纪元的设置，与选举新的sentinel的方式比较相似，基于Raft算法实现）</li><li>被选中的slave执行 salveof no one命令，成为新的master</li><li>新的master会撤销已下线master的槽指派，将槽指派给自己；</li><li>新的master向集群广播一条PONG消息，告知新的master已经上线；</li><li>新的节点接受命令，故障转移完成；</li></ul><h2 id="五-集群间消息"><a href="#五-集群间消息" class="headerlink" title="五 集群间消息"></a>五 集群间消息</h2><p>集群各节点通过互相发送消息来进行通信， 集群间的消息可以大致分为以下几种：</p><ul><li><p>MEET消息：当节点接受客户端发送的CLUSTER MEET命令时，节点会向其他节点会发送meet消息，请求加入到集群；</p></li><li><p>PING消息：集群中每个节点默认每间隔一秒，会从节点列表中<strong>随机</strong>选举出5个节点，在从这5个节点中选一个最长时间没有通信的，发送PING消息；</p></li><li><p>PONG消息：当节点接受到PING 、MEET消息时，会向发送者回复PONG消息； 节点也可以主动向集群广播PONG消息，通知其他节点更新该节点信息；</p></li><li><p>FAIL消息：当一个主节点判断另个主节点已经下线时，节点会向集群广播一条FAIL消息；</p></li><li><p>PUBLISH消息：当节点接受到一个PUBLISH命令时，节点会立即执行该命令，并向集群广播PUBLISH消息；</p></li></ul><h3 id="5-1消息头"><a href="#5-1消息头" class="headerlink" title="5.1消息头"></a>5.1消息头</h3><p>节点消息都会包裹在一个消息头，消息头的定义位于cluster.h/clusterMsg</p><p>消息头中clusterMsgData 联合体 （刚好对应几种消息类型）记录消息的正文；</p><h3 id="5-2-MEET-PING-PONG消息的实现"><a href="#5-2-MEET-PING-PONG消息的实现" class="headerlink" title="5.2 MEET PING PONG消息的实现"></a>5.2 MEET PING PONG消息的实现</h3><p>Redis集群中个节点是通过GOSSIP协议来交换各个节点状态信息，gossip协议由MEET、PING、PONG三种消息组成的：</p><p>因为MEET 、PING、PONG是相同的消息体，所以节点是通过消息头中的type属性来区分PING、PONG、MEET消息的；</p><p>发送pong 、ping、meet消息的入口位于cluster.c/clusterCron ==&gt;cluster.c/clusterSendPing； （ping、pong、meet消费发送都是通过clusterSendPing函数实现的）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//向指定的链接link(对应于节点)发送PIGNG或者PONG数据包,确保要加入足够的gossip信息</span><span class="token keyword">void</span> <span class="token function">clusterSendPing</span><span class="token punctuation">(</span>clusterLink <span class="token operator">*</span>link<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    clusterMsg <span class="token operator">*</span>hdr<span class="token punctuation">;</span>    <span class="token comment">//已经加入的gossip目标</span>    <span class="token keyword">int</span> gossipcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Number of gossip sections added so far. */</span>    <span class="token comment">//需要加入的gossip目标数</span>    <span class="token keyword">int</span> wanted<span class="token punctuation">;</span> <span class="token comment">/* Number of gossip sections we want to append if possible. */</span>    <span class="token keyword">int</span> totlen<span class="token punctuation">;</span> <span class="token comment">/* Total packet length. */</span>    <span class="token comment">/* freshnodes is the max number of nodes we can hope to append at all:     * nodes available minus two (ourself and the node we are sending the     * message to). However practically there may be less valid nodes since     * nodes in handshake state, disconnected, are not considered. */</span>    <span class="token comment">//除去自身和发送目标节点之外的节点数</span>    <span class="token keyword">int</span> freshnodes <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">/* How many gossip sections we want to add? 1/10 of the number of nodes     * and anyway at least 3. Why 1/10?     *     * If we have N masters, with N/10 entries, and we consider that in     * node_timeout we exchange with each other node at least 4 packets     * (we ping in the worst case in node_timeout/2 time, and we also     * receive two pings from the host), we have a total of 8 packets     * in the node_timeout*2 failure reports validity time. So we have     * that, for a single PFAIL node, we can expect to receive the following     * number of failure reports (in the specified window of time):     *     * PROB * GOSSIP_ENTRIES_PER_PACKET * TOTAL_PACKETS:     *     * PROB = probability of being featured in a single gossip entry,     *        which is 1 / NUM_OF_NODES.     * ENTRIES = 10.     * TOTAL_PACKETS = 2 * 4 * NUM_OF_MASTERS.     *     * If we assume we have just masters (so num of nodes and num of masters     * is the same), with 1/10 we always get over the majority, and specifically     * 80% of the number of nodes, to account for many masters failing at the     * same time.     *     * Since we have non-voting slaves that lower the probability of an entry     * to feature our node, we set the number of entries per packet as     * 10% of the total nodes we have. */</span>    <span class="token comment">//希望添加的gossip目标数是节点数除以十,且至少是3</span>    wanted <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wanted <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> wanted <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wanted <span class="token operator">&gt;</span> freshnodes<span class="token punctuation">)</span> wanted <span class="token operator">=</span> freshnodes<span class="token punctuation">;</span>    <span class="token comment">/* Include all the nodes in PFAIL state, so that failure reports are     * faster to propagate to go from PFAIL to FAIL state. */</span>    <span class="token comment">//对于疑似下线的节点要及时发送ping测试连通性</span>    <span class="token keyword">int</span> pfail_wanted <span class="token operator">=</span> server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>stats_pfail_nodes<span class="token punctuation">;</span>    <span class="token comment">/* Compute the maximum totlen to allocate our buffer. We'll fix the totlen     * later according to the number of gossip sections we really were able     * to put inside the packet. */</span>    totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> clusterMsgData<span class="token punctuation">)</span><span class="token punctuation">;</span>    totlen <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsgDataGossip<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>wanted<span class="token operator">+</span>pfail_wanted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Note: clusterBuildMessageHdr() expects the buffer to be always at least     * sizeof(clusterMsg) or more. */</span>    <span class="token comment">//消息长度太短的情况需要补全</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totlen <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token punctuation">)</span> totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr <span class="token operator">=</span> <span class="token punctuation">(</span>clusterMsg<span class="token operator">*</span><span class="token punctuation">)</span> buf<span class="token punctuation">;</span>    <span class="token comment">/* Populate the header. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>link<span class="token operator">-&gt;</span>node <span class="token operator">&amp;&amp;</span> type <span class="token operator">==</span> CLUSTERMSG_TYPE_PING<span class="token punctuation">)</span>        link<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>ping_sent <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">clusterBuildMessageHdr</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Populate the gossip fields */</span>    <span class="token keyword">int</span> maxiterations <span class="token operator">=</span> wanted<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>freshnodes <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gossipcount <span class="token operator">&lt;</span> wanted <span class="token operator">&amp;&amp;</span> maxiterations<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//todo:这里使用的随机算法其实会比较耗时,为什么不直接遍历整个词典呢?</span>        dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        clusterNode <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Don't include this node: the whole packet header is about us         * already, so we just gossip about other nodes. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">==</span> myself<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* PFAIL nodes will be added later. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_PFAIL<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* In the gossip section don't include:         * 1) Nodes in HANDSHAKE state.         * 3) Nodes with the NOADDR flag set.         * 4) Disconnected nodes if they don't have configured slots.         */</span>        <span class="token comment">//对于在HANDSHAKE的节点,NOADDR的节点,断开连接的节点就不用gossip了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLUSTER_NODE_HANDSHAKE<span class="token operator">|</span>CLUSTER_NODE_NOADDR<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>link <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> this<span class="token operator">-&gt;</span>numslots <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            freshnodes<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">/* Technically not correct, but saves CPU. */</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Do not add a node we already have. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clusterNodeIsInGossipSection</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>this<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">/* Add it */</span>        <span class="token function">clusterSetGossipEntry</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        freshnodes<span class="token operator">--</span><span class="token punctuation">;</span>        gossipcount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* If there are PFAIL nodes, add them at the end. */</span>    <span class="token comment">//最后添加哪些疑似下线的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pfail_wanted<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dictIterator <span class="token operator">*</span>di<span class="token punctuation">;</span>        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>        di <span class="token operator">=</span> <span class="token function">dictGetSafeIterator</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cluster<span class="token operator">-&gt;</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pfail_wanted <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            clusterNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_HANDSHAKE<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_NOADDR<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLUSTER_NODE_PFAIL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">clusterSetGossipEntry</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span>gossipcount<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            freshnodes<span class="token operator">--</span><span class="token punctuation">;</span>            gossipcount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">/* We take the count of the slots we allocated, since the             * PFAIL stats may not match perfectly with the current number             * of PFAIL nodes. */</span>            pfail_wanted<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Ready to send... fix the totlen field and queue the message in the     * output buffer. */</span>    <span class="token comment">//准备发送阶段,在buf中排队</span>    totlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsg<span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> clusterMsgData<span class="token punctuation">)</span><span class="token punctuation">;</span>    totlen <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>clusterMsgDataGossip<span class="token punctuation">)</span><span class="token operator">*</span>gossipcount<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr<span class="token operator">-&gt;</span>count <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>gossipcount<span class="token punctuation">)</span><span class="token punctuation">;</span>    hdr<span class="token operator">-&gt;</span>totlen <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">clusterSendMessage</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>totlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zfree</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当 接 收 者 收 到 MEET、 PING、 PONG 消 息 时， 接 收 者 会 访 问 消 息 正 文 中 的 两 个clusterMsgDataGossip 结构， 并根据自己是否认识 clusterMsgDataGossip 结构中记录的被选中节点来选择进行哪种操作：</p><ul><li>如果被选中节点不存在于接收者的已知节点列表， 那么说明接收者是第一次接触到被选中节点， 接收者将根据结构中记录的 IP 地址和端口号等信息， 与被选中节点进行握手。</li><li>如果被选中节点已经存在于接收者的已知节点列表， 那么说明接收者之前已经与被选中节点进行过接触， 接收者将根据 clusterMsgDataGossip 结构记录的信息，对被选中节点所对应的 clusterNode 结构进行更新。  </li></ul><h3 id="5-3FAIL消息的实现"><a href="#5-3FAIL消息的实现" class="headerlink" title="5.3FAIL消息的实现"></a>5.3FAIL消息的实现</h3><p>在集群节点数量较多时，使用Gossip协议来传播下线消息 会是下线消息传播延时；</p><p>而发送FAIL消息可以让集群中所有节点知道节点下线，从而尽快判断集群是否下线，对下线主节点执行故障转移操作；</p><p>FAIL消息体的定义位于cluster.h/clusterMsgDataFail</p><p> 发送FAIL消息的入口位于cluster.c/clusterSendFail</p><h3 id="5-4PUBLISH消息的实现"><a href="#5-4PUBLISH消息的实现" class="headerlink" title="5.4PUBLISH消息的实现"></a>5.4PUBLISH消息的实现</h3><p><code>PUBLISH&nbsp;&lt;channel&gt;&nbsp;&lt;msg&gt;</code></p><p>当某节点接受到PUBLISH 消息，不仅会向自己的channel发送msg消息，还会向集群广播一条PUBLISH消息，是集群中所有节点都对于自己的channel发送一条msg消息；</p><p>publish消息的消息体定义位于cluster.h/clusterMsgDataPublish</p><pre class="language-c#" data-language="c#"><code class="language-c#">typedef struct {    uint32_t channel_len;    uint32_t message_len;    //八字节是为了对齐,实际长度是保存的内容决定的    unsigned char bulk_data[8]; /* 8 bytes just as placeholder. */} clusterMsgDataPublish;</code></pre><p>bulk_data的0到channel_len-1字节保存的是channel，channel_len到channel_len+message_len-1字节保存的是message的内容。</p><p>对于消息<code>PUBLISH "news.it" "hello"</code>，保存的结构如图：</p><p><img src="/2022/03/05/redis-cluster/image-20211129214514368.png" alt="image-20211129214514368"></p><p>处理publish命令的入口位于<code>pubsub.c/publishCommand ==&gt;cluster.c/clusterPropagatePublish==&gt;cluster.c/clusterSendPublish</code></p><p>为了保证所有的节点通过发送和接受消息进行通信，所以客户端不会直接给所有的节点都发送PUBLISH（好像其实客户端也没有所有节点的信息，必须要先访问某个节点得知所有节点的信息之后才能向所有的节点都发送PUBLISH）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis hotkey solutions</title>
      <link href="/2022/03/04/redis-hotkey-solutions/"/>
      <url>/2022/03/04/redis-hotkey-solutions/</url>
      
        <content type="html"><![CDATA[<h2 id="一、热点数据的存放"><a href="#一、热点数据的存放" class="headerlink" title="一、热点数据的存放"></a>一、热点数据的存放</h2><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>数据库中有2000w数据，而redis中只有100w数据，如何保证redis中存放的都是热点数据？</p><p><strong>方案：</strong><br>限定redis占用的内存，redis会根据自身数据淘汰策略，留下热数据到内存。所以可以计算100w数据大约占用的内存，</p><p>然后设置一下redis内存限制即可，并将淘汰策略设置为allkeys-lru或者volatile-lru.</p><ul><li><strong>设置redis最大占用内存：</strong></li></ul><p>　　　　打开redis配置文件，设置maxmemory参数，maxmemory是bytes字节类型哦！</p><p>　　　　maxmemory 268435456</p><ul><li><strong>设置过期策略：</strong></li></ul><p>　　　　maxmemory-policy volatile-lru</p><ol><li>当redis使用的内存超过设置的最大内存时，会触发redis的key淘汰机制，在redis3.0中的6中淘汰策略如下：</li><li>noeviction :不删除策略。当达到最大内存限制时，如果需要使用更多内存，则直接返回错误信息（redis默认淘汰策略）</li><li>allkeys-lru:在所有key中优先删除最近最少使用（less recently used，LRU）的key。</li><li>allkeys-random:在所有key中随机删除一部分key</li><li>volatile-lru: 在设置了超时时间（expire）的key中优先删除最近最少使用的key</li><li>volatile-random：在设置了超时时间的key中随机删除一部分key</li><li>volatile-ttl: 在设置了超时时间的key中优先删除剩余时间（time to live,TTL）的key</li></ol><p><strong>实际场景：</strong></p><p><strong>redis用作缓存</strong><br>提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)<br>即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).<br>一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.<br><strong>过去24h活跃用户</strong><br>比如用户数据。数据库有2000w条。使用 redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。<br>取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。</p><h2 id="二、怎么发现热key"><a href="#二、怎么发现热key" class="headerlink" title="二、怎么发现热key"></a>二、怎么发现热key</h2><p>方法一:凭借业务经验，进行预估哪些是热key<br>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p><p>方法二:在客户端进行收集<br>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><p>方法三:在Proxy层做收集<br>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。 </p><p>方法四:用redis自带命令<br>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。<br>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p><p>方法五:自己抓包评估<br>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h2 id="三、高频访问热key的解决方案"><a href="#三、高频访问热key的解决方案" class="headerlink" title="三、高频访问热key的解决方案"></a>三、高频访问热key的解决方案</h2><p><strong>如何解决</strong><br>目前业内的方案有两种</p><p><strong>(1)利用二级缓存</strong><br>比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。<br>针对这种热key请求，会直接从jvm中取，而不会走到redis层。<br>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。<br>现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。<br>***(2)备份热key***<br>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据</p><p> 我们知道在Redis集群中，是通过按照槽点的划分来决定数据最终落在哪个Redis节点上。在集群中，一共存在16384个槽点，如果我们的集群有3个节点组成的话，那么由这3个节点来均分这16384个槽点。如下图</p><p>　　<img src="/2022/03/04/redis-hotkey-solutions/1211299-20210528161536403-484687935.png" alt="img"></p><p>​    假如name@zhangsan的缓存是一个高频访问的数据，那么大量请求访问这个key时，就会出现压力都有redis1这个节点来承担，这样redis1节点就有可能会扛不住压力而罢工了。那么应该怎么解决这个问题呢？</p><p>​    不妨在缓存数据的时候，将这个数据在每个redis节点都缓存一份。而在缓存的时候，将key在程序层面进行加工，如变成name@zhangsan#redis1、name@zhangsan#redis2、name@zhangsan#redis3这样的三个key。此处我们假如这样的3个key会根据crc16算法，将这个三个key分别落在这三个节点之上。那么这样在访问的时候，我们就可以依然遵循这个规则获得一个key，这样一来，获取数据的时候，压力就被分散到不同的redis节点上了。如图</p><p><img src="/2022/03/04/redis-hotkey-solutions/1211299-20210528161547527-1836533042.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac命令行加密sha等</title>
      <link href="/2022/03/04/mac-ming-ling-xing-jia-mi-sha-deng/"/>
      <url>/2022/03/04/mac-ming-ling-xing-jia-mi-sha-deng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Note: <code>echo -n</code> 代表不发送换行符; 不带参数默认发送换行符。</p></blockquote><p><a href="https://so.csdn.net/so/search?q=base64&amp;spm=1001.2101.3001.7020">base64</a> encode</p><pre class="language-shell" data-language="shell"><code class="language-shell">echo -n 123|base64orecho -n "123"|base64or base64 -i 1.txtor echo -n 123|openssl enc -base641234567</code></pre><p>base64 decode</p><pre class="language-shell" data-language="shell"><code class="language-shell">echo -n MTIz|base64 -Dorecho -n "MTIz"|base64 -Dor base64 -D -i 1.txtorecho MTIz|openssl enc -base64 -d;echoorecho MTIz|openssl enc -base64 -d123456789</code></pre><p><a href="https://so.csdn.net/so/search?q=MD5&amp;spm=1001.2101.3001.7020">MD5</a></p><pre class="language-shell" data-language="shell"><code class="language-shell">openssl dgst -md5 123.binoropenssl md5 123.binormd5 123.binormd5 -s "text"or echo -n foo|md5or echo -n "foo"|md5orecho -n "foo"|openssl dgst -md512345678910111213</code></pre><p>HmacMD5</p><pre class="language-shell" data-language="shell"><code class="language-shell">openssl md5 -hmac "key" 123.binecho -n "value" | openssl dgst -md5 -hmac "key"12</code></pre><p><a href="https://so.csdn.net/so/search?q=SHA1&amp;spm=1001.2101.3001.7020">SHA1</a></p><pre class="language-shell" data-language="shell"><code class="language-shell">openssl dgst -sha1 123.binoropenssl sha1 123.binorecho -n "value" | openssl dgst -sha112345</code></pre><p>HMAC_SHA1</p><pre class="language-shell" data-language="shell"><code class="language-shell">echo -n "value" | openssl dgst -sha1 -hmac "key"echo -n "value" | openssl sha1 -hmac "key"12</code></pre><p>SHA256</p><pre class="language-shell" data-language="shell"><code class="language-shell">openssl sha256 123.binoropenssl dgst -sha256 123.binor echo -n "value" | openssl dgst -sha25612345</code></pre><p>HMAC_SHA256</p><pre class="language-shell" data-language="shell"><code class="language-shell">echo -n "value" | openssl dgst -sha256 -hmac "key"echo -n "value" | openssl sha256 -hmac "key"</code></pre><p>参考：<a href="https://blog.csdn.net/toopoo/article/details/99657602">https://blog.csdn.net/toopoo/article/details/99657602</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac命令行</title>
      <link href="/2022/03/02/mac-ming-ling-xing/"/>
      <url>/2022/03/02/mac-ming-ling-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>一条命令<code>man</code>解决所有问题。</p><p><code>man command-name</code>进入命令指南页面，<code>上箭头或下箭头</code>上下移动，使用<code>空格</code>来翻页，输入 <code>/</code> 和关键字来按照关键字搜索，按 <code>Q</code> 来退出使用指南页面。</p><p>输入 <code>man -k</code> 和关键字来对整个使用指南数据库进行搜索。</p><p>以下都是可以用<code>man</code>查看具体用法的：</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>mkdir</td><td>创建一个目录</td><td>mkdir dirname</td></tr><tr><td>rmdir</td><td>删除一个目录</td><td>rmdir dirname</td></tr><tr><td>mvdir</td><td>移动或重命名一个目录</td><td>mvdir dir1 dir2</td></tr><tr><td>cd</td><td>改变当前目录</td><td>cd dirname</td></tr><tr><td>pwd</td><td>显示当前目录的路径名</td><td>pwd</td></tr><tr><td>ls</td><td>显示当前目录的内容</td><td>ls -la</td></tr><tr><td>dircmp</td><td>比较两个目录的内容</td><td>dircmp dir1 dir2</td></tr></tbody></table><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>cat</td><td>显示或连接文件，可以用<code>&gt;&gt;</code>来增加文本文件内容</td><td>cat filename</td></tr><tr><td>pg</td><td>分页格式化显示文件内容</td><td>pg filename</td></tr><tr><td>more</td><td>分屏显示文件内容</td><td>more filename</td></tr><tr><td>od</td><td>显示非文本文件的内容</td><td>od -c filename</td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp file1 file2</td></tr><tr><td>rm</td><td>删除文件或目录</td><td>rm filename</td></tr><tr><td>mv</td><td>改变文件名或所在目录</td><td>mv file1 file2</td></tr><tr><td>ln</td><td>联接文件</td><td>ln -s file1 file2</td></tr><tr><td>find</td><td>使用匹配表达式查找文件</td><td>find . -name “*.c” -print</td></tr><tr><td>file</td><td>显示文件类型</td><td>file filename</td></tr><tr><td>open</td><td>使用默认的程序打开文件</td><td>open filename</td></tr><tr><td>Less</td><td>查看长文本文件，因为它可以查找文本。语法为 <code>less</code> 后接文件路径，和 <code>cat</code> 一样。用 <code>less</code> 命令打开的文件其实和你查看命令使用指南的时候使用的是一个查看器</td><td>less filename</td></tr><tr><td>which</td><td>定位某个命令的文件路径。它会告诉你你执行某个具体命令的时候，在使用哪个文件。语法为 <code>which</code> 后接某个命令。</td><td>Which man</td></tr></tbody></table><h4 id="使用通配符（Wildcard-Characters）"><a href="#使用通配符（Wildcard-Characters）" class="headerlink" title="使用通配符（Wildcard Characters）"></a><strong>使用通配符（Wildcard Characters）</strong></h4><ul><li>星号（＊，Asterisk）——代表任何长度的任何字符。例如 <code>*.tiff</code> 代表所有格式为tiff的文件。</li><li>问号（?，Question mark）——代表任何单个字符。例如 <code>b?ok</code> 匹配 book 但是不匹配 brook。</li><li>方括号（[]，Square brackets）——定义一定范围的字符，例如 <code>[Dd]ocument</code> 匹配 Document 以及 document；<code>doc[1-9]</code> 匹配doc1, doc2, …, doc9。</li></ul><h4 id="使用递归命令"><a href="#使用递归命令" class="headerlink" title="使用递归命令"></a><strong>使用递归命令</strong></h4><p>简单来说，递归命令可以允许命令不执行于一个特定文件，而是指定的路径下的所有文件。大多数命令包含一个 <code>-r</code> 或者 <code>-R</code> 选项，来设定你想递归地执行这个命令。例如下面的例子，添加 <code>-R</code> 后 <code>ls</code> 命令的执行方式：<code>ls -R Public</code>，这会列出 Public 中的所有文件，若有文件夹，则会继续列出文件夹中的内容。</p><h3 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>head</td><td>显示文件的最初几行</td><td>head -20 filename</td></tr><tr><td>tail</td><td>显示文件的最后几行</td><td>tail -15 filename</td></tr><tr><td>cut</td><td>显示文件每行中的某些域</td><td>cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td>从标准输入中删除若干列</td><td>colrm 8 20 file2</td></tr><tr><td>paste</td><td>横向连接文件</td><td>paste file1 file2</td></tr><tr><td>diff</td><td>比较并显示两个文件的差异</td><td>diff file1 file2</td></tr><tr><td>sed</td><td>非交互方式流编辑器</td><td>sed “s/red/green/g” filename</td></tr><tr><td>grep</td><td>在文件中按模式查找</td><td>grep “^[a-zA-Z]” filename</td></tr><tr><td>awk</td><td>在文件中查找并处理模式</td><td>awk ‘{print $1 $1}’ filename</td></tr><tr><td>sort</td><td>排序或归并文件</td><td>sort -d -f -u file1</td></tr><tr><td>uniq</td><td>去掉文件中的重复行</td><td>uniq file1 file2</td></tr><tr><td>comm</td><td>显示两有序文件的公共和非公共行</td><td>comm file1 file2</td></tr><tr><td>wc</td><td>统计文件的字符数、词数和行数</td><td>wc filename</td></tr><tr><td>nl</td><td>给文件加上行号</td><td>nl file1 &gt;file2</td></tr></tbody></table><h3 id="安全操作"><a href="#安全操作" class="headerlink" title="安全操作"></a>安全操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>passwd</td><td>修改用户密码</td><td>passwd</td></tr><tr><td>chmod</td><td>改变文件或目录的权限</td><td>chmod ug+x filename</td></tr><tr><td>umask</td><td>定义创建文件的权限掩码</td><td>umask 027</td></tr><tr><td>chown</td><td>改变文件或目录的属主</td><td>chown newowner filename</td></tr><tr><td>chgrp</td><td>改变文件或目录的所属组</td><td>chgrp staff filename</td></tr><tr><td>xlock</td><td>给终端上锁</td><td>xlock -remote</td></tr></tbody></table><h3 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>make</td><td>维护可执行程序的最新版本</td><td>make</td></tr><tr><td>touch</td><td>更新文件的访问和修改时间</td><td>touch -m 05202400 filename</td></tr><tr><td>dbx</td><td>命令行界面调试工具</td><td>dbx a.out</td></tr><tr><td>xde</td><td>图形用户界面调试工具</td><td>xde a.out</td></tr></tbody></table><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>ps</td><td>显示进程当前状态</td><td>ps u</td></tr><tr><td>kill</td><td>终止进程</td><td>kill -9 30142</td></tr><tr><td>nice</td><td>改变待执行命令的优先级</td><td>nice cc -c *.c</td></tr><tr><td>renice</td><td>改变已运行进程的优先级</td><td>renice +20 32768</td></tr></tbody></table><h3 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>date</td><td>显示系统的当前日期和时间</td><td>date</td></tr><tr><td>cal</td><td>显示日历</td><td>cal 8 1996</td></tr><tr><td>time</td><td>统计程序的执行时间</td><td>time a.out</td></tr></tbody></table><h3 id="网络与通信操作"><a href="#网络与通信操作" class="headerlink" title="网络与通信操作"></a>网络与通信操作</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>telnet</td><td>远程登录</td><td>telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td>远程登录</td><td>rlogin hostname -l username</td></tr><tr><td>rsh</td><td>在远程主机执行指定命令</td><td>rsh f01n03 date</td></tr><tr><td>ftp</td><td>在本地主机与远程主机之间传输文件</td><td>ftp ftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td>在本地主机与远程主机 之间复制文件</td><td>rcp file1 host1:file2</td></tr><tr><td>ping</td><td>给一个网络主机发送 回应请求</td><td>ping hpc.sp.net.edu.cn</td></tr><tr><td>mail</td><td>阅读和发送电子邮件</td><td>mail</td></tr><tr><td>write</td><td>给另一用户发送报文</td><td>write username pts/1</td></tr><tr><td>mesg</td><td>允许或拒绝接收报文</td><td>mesg n</td></tr></tbody></table><h3 id="Korn-Shell-命令"><a href="#Korn-Shell-命令" class="headerlink" title="Korn Shell 命令"></a>Korn Shell 命令</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>history</td><td>列出最近执行过的 几条命令及编号</td><td>history</td></tr><tr><td>r</td><td>重复执行最近执行过的 某条命令</td><td>r -2</td></tr><tr><td>alias</td><td>给某个命令定义别名</td><td>alias del=rm -i</td></tr><tr><td>unalias</td><td>取消对某个别名的定义</td><td>unalias del</td></tr></tbody></table><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统的有关信息</td><td>uname -a</td></tr><tr><td>clear</td><td>清除屏幕或窗口内容</td><td>clear</td></tr><tr><td>env</td><td>显示当前所有设置过的环境变量</td><td>env</td></tr><tr><td>who</td><td>列出当前登录的所有用户</td><td>who</td></tr><tr><td>whoami</td><td>显示当前正进行操作的用户名</td><td>whoami</td></tr><tr><td>tty</td><td>显示终端或伪终端的名称</td><td>tty</td></tr><tr><td>stty</td><td>显示或重置控制键定义</td><td>stty -a</td></tr><tr><td>du</td><td>查询磁盘使用情况</td><td>du -k subdir</td></tr><tr><td>df</td><td>显示文件系统的总空间和可用空间</td><td>df /tmp</td></tr><tr><td>w</td><td>显示当前系统活动的总信息</td><td>w</td></tr></tbody></table><h2 id="其他-Command-Line-技巧提示"><a href="#其他-Command-Line-技巧提示" class="headerlink" title="其他 Command-Line 技巧提示"></a>其他 Command-Line 技巧提示</h2><ul><li>输入命令 <code>open .</code> 可以打开当前的位置。</li><li>在 Terminal 的偏好里面可以设定它的外观和风格。</li><li>中止一个正在执行的命令，可以使用组合键 control + C。</li><li>在执行前编辑命令，只需要使用箭头和键盘上的其他字母。</li><li>没有输入任何命令时，你可以用▲和▼来浏览历史命令。同样可以编辑和再次执行。</li><li>你也可以使用history命令查看历史记录。</li><li>你可以使用组合键 control + L 清屏。</li></ul><p>参考链接：<a href="https://www.jianshu.com/p/a9bf79b1b134">https://www.jianshu.com/p/a9bf79b1b134</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会议记录</title>
      <link href="/2022/02/24/hui-yi-ji-lu/"/>
      <url>/2022/02/24/hui-yi-ji-lu/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="48c1213d59cdfa6164ec2416b8ea5416e12b036f5b0a1b3c8512442135533b7f">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186aa542fdabe9478b268cf29cb2e92ecc70a7c833c64ac2c01834becf0b0cc258135e8da4dd781f5c60c5e6f52cb7e8e36e7605bfc2adc43aba947dd391d3cca22c327a5704a15adba7db54f66ff0fc7c2d7933e0ad97158db49abdf2131306205f1cc16ef8c161c4aedd914bc0b8ab6d39224b39479c0ea6e9643ec4caa803481cf88e4c330338010d2501f037b1d434478d2b8e55962683ea51fd58e01854d4f618fffb446758db4193d9c0420ee8bade7afc43af71708e2f19668849261b92b7d97819dd41444375a42205735890dd24cfd4e6405c507d4f2978ed96c50f601f2e836dbb05ad96661cd990b6239c9be0072daa431d771081bc6c808e7b4957d6b14d98621e97eb1ed7238daae08a8f4c59a3dd02650dcfccf3bd2fe75052056f2c2341a99550dfe352662d9bc50eb2bf027c3145d444d4ab5c907c03e79c2cc14c0c32413dbd9a63a4f3217d8d2b8a6698564d7d50af44526e72a3b6b111a72d1310854e1a013db7ac30e2ace77e47709aec1869152b6fb411a105066f6f25cd20314bd7e10405e0295186431cea1465ec014c377f17fa463d91b31df07ad28e09e42d4698e3afdb9df8863471896d4566ec86d017390d8d3b5adb74460d224a908e4881cd1f0b3013c2f6f63e99b27e0da8bfcea1df3a6177b09b60fbb250763f593bfe442eb8627ffd88bafc54cbaafed0e483a9b3d8d09ca524131dee0a1221572217887bdfb4ac4277a05326716047577ab209c150191a820225fe28b4811ddfa4335bba9a18f1b337a5290ad0397b10cbba47f20820dd42779cf33caeccf0920a475d156f29fa1d237498b8b25e8e64f063336b6d77c8bef4d410fd63e0a5ec4b5dee999a7f69c7d4d881a94fabfe28520c93a3176f7ab86f4b485750a8a9daa5e309c00a4376103f1aba15e1768e8314ea6417956121b13b0960cf7d12c521f5e6e304078fa63fbd2586b04f702076ffbc047bd5d5a20c8c0233229d726ad0ab7a21fd6b003d94de2c040b6b734f9817046700de40dba95326a4bcd38a60765fba23168ddf9ed2852ddcec1947421dcf5a665617ce0dbcdf791fe372c6d1f7172aebfae0e6a1544e50a54280649dbd8a0c24674483d8ee035db70ce3a4302da019c1a86ddfd4020f0fd7d1d6fac127d731b5400b6e327437fc2137950cd139d102a6d98a291be4b6b911174eababdc6c398312b1ffa550c291802613d62cc7eccfaa90382318d5a19d6ab902043a4d39ffd97d2c32081c0ae20236624c7ffd50b9c3173548954a9207462534a09490b34d801648dad5e07cca681f3f6d743476a9906e6d44c65e8c3e9248712b2ac9bf85c397ca2615e8918b57269c3f103ec9ca8e71ae914344406304704b3dad993e3412ac7f20dfd3266386a817ef3b9de2edc1706e76a2fc1bc326a64a783c6fd854356a2438ce65a1b2b8e3bad5b30d7b8e30b4ee460e7bb6e9f0389a6e82ee5cd58f5d637a11b1d9621438fbcd67fbb2e18678cade8693b478c70ad4f3860a5d36059f4df8c9457621b2b3c28c8ea3167ecd10d6234d1dc74d6e61527801c6286095801af2196f3593560909f8ccb1ee781aada196f4b6d2bae6534fda25ad9bd7aa5c50a8b5bf11dcd6f2992010186f3b654be926805f78afe04b2df6b13bb9567714829eb098e1bebb691f4b6d2aa509db56e021e550eff629464fa6668f888018405137e13695b3a7ecb777a0345d89b1a90a352b600883c86243cd76e89c73c6081d5b3a3742ba96e7d0ba26cb8a2c1763bb4ee868f0c522258c6966c427b01fb67c327991530106780c35be6caac7f8a8e8c12cdf75c391f31fd0113cee664b34772c449e09c40d164a4cd7436de6c363b0ab01800f4c466946a692db9be561677e4b7e6705b59c3f601b2767ce8c02d7b080d0573f4a92ddc3434d278874f5875eda48bd11b25a82ac7a79848b75b5b515a48c1cda32e7f3940079cc10651203601ea04a5902d296eedaa5e0a3d49cc8470ed9ff2af23b5a2e6efd8eb90a5fccda11094dc84e12f95d5fd4374afad8bbad5fa8f71bae8eea8316c1d381798f7bb4d7d6f2148df054d84c12acadca9e979171cf818c4cc4b168f7ff075bcb4886e94e1905474ea1bd4d65b8d66de474b60893082c338ee16c446dcaab7d229885514ea2be3128c2cbe5bb0cd7537945f4f2ab4ab2a56248867c9629e96c85f6d15b33582b6f8324e64fa0eeb2c85696f4263597ba2fd59524e8870add03e735a74bdd0eb743b03eb5882441bb09cd9d34626cd267b99fe783dc1dcf0e23f1a46ea0c69cdb419afef0d0c2584f28c8676d3910a464f6936dfc2d0ab44782012639f826ab3b9236b0247490047690d5a1ce789487fc6e110a45c0dfa909360f88d3d0975f86dde673f49a2559684b3482d66e755440cc7204f31103a2f738cf619acc312f4d74a199afe46c407b5fcddcde07058f7cbc880be9769cd07370d72216ad995f121638c48828b7538a5df4f8a1dbfcdb8d0da69e89289b403ec97b04dc68edf7faf5840b7ba336e8666be969527140a662920eef88de40aa197bf33885ead5bc449908dd6cb124452bc47782602b5ac1a4faf4abdebb9ab54e9d8925c1337b9c149223260086fb875c92fcd50ce752d486c563aa6c21bd50b18e9fc783dae1f44a1cc611b73545013f7331ff71f457ab25c30a68d367f49defb65232a06123b2471df42c8eba5adbaf44e70b1bc05512f5baf8cb7c43115635604069d442564bc3b289b279f2706de3b63399ba8d647037100523f09ae88cce00878e8a13631deb1542429912104db75cab3da36c84fe910251c010f6070107b949e80091d9c5be0f90c0f5fe7247f556b32c3a2c9ad44a05608eb864d248f2f57b40f8f4aa53931ea761a8a42aac2522a33953407158301859eae1b57435aa94256c86ad4ffcba3933ad18c736320de3fc98eda399549c63560c78dbb4258c30394409ea5546e5f0cd52fbf70846447595a2e4546af02c77adca85b0d2b9f358da407f50698dea3a0cf9acf7c6950438595bd1adda971615e8cd57629c98f916c556bf5378a2f1409196eeb732fa0a82a3d25ba4d8e8fa68a539bef76a4a8b017b529129fb8f2f45a12ddc96d34d1e2625da02acf9f32b538978b04bc08936c77452b07dbb2e74b98b20c9ffc283e2ce65bea38208604341a34e03819729999a874dd43a2d8573243460533f253233dea03ceb261d6b0e0960ccfeae6c4ec99c4f240239ec805f973281f7e96d208fee14de4e9d79b7fb7d2ae66c91dc05ec3bd8a82925755d94a3f6c31ac6c600fd701b9daea88602b38a691d91a54d6fa11424008d66bd82df692d351b02b1d0a93c3990bb2ab127756ee6d5410e02512dc2da4d3c9ff6a2eca95436009f79a3be837a99e980cafd507ae2e9544c196f2dcc01e080b434d11e152b1ac2125f2fff3a738f28cff3c932b6e3de6697197551eaaf1fb992c2917f2115632eac34c7d2619447299ee8e44792d71ad38886049e898c5db581cda5b0b807e3ee895c2ef6b67f6afe450dd1a2231298c74454f3e648571dae580e438439eef2db44f480e9b06c3ed42a14f35c68c093402e991dcf46bc9c307ec3073124c9e860274170cb06f322bb2f0aa31376518bd6b5a8aad42135b094190339e5b4b45e9907ee86eb845789604d48c5406acd9a76d5ded4d153f2d0e92aa538c6eaf1ff4d9fd5ff05ed65dc2889051e3fddff2b23f48ddd62e31cf8201ea80833f392c92ec6dec2d1be92aefafa615b2a2339b865f04ede40fb3632c400d90bb8df7ec9806a32928ae5bde66a1418e2654b8acfc3194c67b067550cab8033b32a9c17fed36ea25182288d2d59e6ab233bf84da9543bef0e8d1a45c5ec0c88b1ba112bb9e0be45a5badc0468ba11cc61e8922a9fafe242bdd82cc621446583eff2816c2ddf0d47737415b25fe6d46b60a54eb0fb76d617e27eadc2baece835f4a6dd44f90000021f2b0e406ba4f50df1e7983c8c8ea3366eab5d30efcef16153c9859acb66f329ff4c4769634bfb81ce6e4359935f18becb7f3a3c8e0d85aec7d781127c0f6e94018373e38ac58cca05992ae2df1ffe2ee66e58104525467b042b4dcb461e4af4268537f19b198d6f7e0193fe2638199a4ad918cbde5cef511461f5a322bd925ac3e366ea515ec8311946d70a39171e7afc563268456c577e032593218d9ef0a17dc806eab138d7402da244cb71ea1eebf7cb2021ff374790079e16848af398584141fb9f48057464a2d6f332622754ffeb4e2b2e93dac7ccf90357dcf6a9b1b072d2d55220c965e5ebcc98a0a06c00157ac5c408eb5445af5f80db722bb45bcb757219cf587aa960509778df2d711a5005005a151a2d0a83dc0bbf9d6eb43cd47dc6f71a484573ddce6e8a1c48e3d36fdc9ac0047b74db780831665555abdf517449a1238aa19414c148979c199d85e59f308f3b1738d4f23d81ffba504bb3317acbe6b925b4389e6a423a56e5006fed11896110dc524ca6e03499c5fc94d32e3a35a5e1556df911a4d882e1c03f3a6c4a093743e5cd59b2e3f568c868cf7e75aef1c598b3a19ddd65f38146b40bc1843cdcec6e51659296a59ac3238124e52cada214b8044e4f6e7fae6ec9c7a477e68910f847eff8c209231049f01fd0341d9ec63a5d11f1ee39c95f5d0eab573a7fb39bec2842d9aa889ebfee50e9ab91eca709a49aa6f46ab9627d20b3718f0dc304fa8ca9c39bd26ff73c6f5deb5df001a126d8496db2cc1924a6748df3539009ef71aaea897589f0d7604f085de731f62efd33039ca95e4eeae3362067ccbd8670cc7ce505755c8118e22df7d3309cdea59e3ee156c332dadaa746054efd6ac248686d634ba87f7c5f79c32b0768a1ee98495e033d0f1fc7a71549ac10f76060e712cf6eacb6431791dbee7414708ec108cf058589b8589f175611c13253c484fa930ed0e479ade3681cd94368e59cb16026e5fec1f5d35ac34c0f492c9ba7eff7be6049187b09dd2fd8b3fae48482b583f504df60b549a737c470f3efb9660652c193a6792f5d6b2195da1990e5b9ff2188b78f52940e428370ea92219ce5322b2607658922d8a149ebc68a6e6f3882cd16b4e7b4a19ab7c080acf104638fda6d40325cc09ad74394dfa53ae52ff65e4f8ae66c8101fc729cc7342a165d88a3d8d89e0ddccd15b600d4354beab40d72bb82c6a2897b61e7b9647bcc25b1a054fa40cbe319386d39539113ad5bb2171fcedf8414b9e5033ac24f95aca4bf5c2cb69d859533edafdc8ca263d2878c2d500a33a590b297d7c33d149cce3c8b281c347d368ec22ae80f7fdbfff2346ce0aa17b8e965f3120ab76fd0cb870c11eb84fcd33d8012b073e80cf6b271a6b3d581d7465fe91afe4672faa56d961074312a6f01ba8af6d6c3a6da02f570dfc109ef0b56ed9e83db45f5b9cb0b114ee2dc5cf5de8506ba396a41e32e89248b766f195758c32ad2fc20d474e6efaceeb132f2181375db47658d26e4b8b5a0a5a137b9872cb8041c644f06d92e8c05b2a99aa6106817b4e383777a8a2c5f773323849</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会议记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOmake函数和slice，map解析</title>
      <link href="/2022/02/21/gomake-han-shu-he-slice-map-jie-xi/"/>
      <url>/2022/02/21/gomake-han-shu-he-slice-map-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h1><ul><li>首先看个例子</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span> <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> i <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">*</span>i<span class="token operator">=</span><span class="token number">10</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>这个例子会打印出什么？0还是10?。以上全错，运行的时候会painc，原因如下：</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token builtin">panic</span><span class="token punctuation">:</span> runtime <span class="token builtin">error</span><span class="token punctuation">:</span> invalid memory address or <span class="token boolean">nil</span> pointer dereference</code></pre><ul><li>从这个提示中可以看出，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间，否则我们的值放在哪里去呢？这就是上面错误提示的原因</li><li>对于值类型的声明不需要，是因为已经默认帮我们分配好了</li><li>分配内存，Go提供了两种方式，分别是new和make</li></ul><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>Go提供内建函数new</p><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token keyword">Type</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token keyword">Type</span></code></pre><ul><li>它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时请注意它同时把分配的内存置为零，也就是类型的零值。那么上面的函数可以改写成</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> i <span class="token operator">*</span><span class="token builtin">int</span> i<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>i<span class="token operator">=</span><span class="token number">10</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>这就是new，它返回的永远是类型的指针，指向分配类型的内存地址</li></ul><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><ul><li>make也是用于内存分配的，但和new不同，它只用于通道chan、映射map以及切片slice的内存创建</li><li>它的返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型本身就是引用类型</li><li>注意，因为这三种类型是引用类型，所以必须得初始化，但不是置为零值</li></ul><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span>t <span class="token keyword">Type</span><span class="token punctuation">,</span> size <span class="token operator">...</span><span class="token class-name">IntegerType</span><span class="token punctuation">)</span> <span class="token keyword">Type</span></code></pre><h2 id="make和new对比"><a href="#make和new对比" class="headerlink" title="make和new对比"></a>make和new对比</h2><ul><li>二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零</li><li>make返回的还是这三个引用类型本身；而new返回的是指向类型的指针</li><li>new不常用，通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如：</li></ul><pre class="language-go" data-language="go"><code class="language-go">i<span class="token operator">:=</span><span class="token number">0</span>u<span class="token operator">:=</span>user<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>make函数是无可替代的</li></ul><h1 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h1><ul><li>Slice和数组类似，也是表示一个有序元素，但这个序列的长度可变，具有动态长度特性</li><li>切片（slice）是对底层数组一个连续片段的引用，所以切片是一个引用类型</li><li>内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内</li><li>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</li><li>多个切片可以指向同一个底层数组，实现了内存共享</li><li>Slice 的数据结构定义如下:</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">{</span>    array unsafe<span class="token punctuation">.</span>Pointer    <span class="token builtin">len</span>   <span class="token builtin">int</span>    <span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">}</span></code></pre><ul><li>切片的结构体由3部分构成，Pointer 是指向一个底层数组的指针，len 代表当前切片的长度，cap 是当前切片的容量，cap 总是大于等于 len 的</li></ul><h2 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h2><ul><li>Go语言提供的内置函数make()可以用于灵活地创建数组切片</li><li>创建方式make([]type, len, cap)，其中，type表示数组元素类型，len表示长度，cap表示容量</li><li>还有一种切片字面量方式创建切片</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//创建一个初始元素长度为5的数组切片，元素初始值为0： </span>mySlice1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">//创建一个初始元素长度为5的数组切片，元素初始值为0，并预留10个元素的存储空间： </span>mySlice2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">//切片字面量创建长度为5容量为5的切片,需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</span>mySlice3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">}</span></code></pre><h1 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h1><ul><li>map是一种数据结构，用于存储一系列无序的键值对，类似java的HashMap</li><li>通过散列表实现，使用两个数据结构来存储数据，一个数组用于选择桶的散列键的高八位值，可以区分每个键值属于哪个桶；另一个字节数组，用于存储键值对</li><li>创建方式make(map[keyType] valueType, cap)，其中keyType表示键类型，valueType表示值类型，cap表示初始存储能力</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//创建了一个键类型为string、值类型为PersonInfo</span>myMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> PersonInfo<span class="token punctuation">)</span> <span class="token comment">//也可以选择是否在创建时指定该map的初始存储能力，创建了一个初始存储能力为100的map.</span>myMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> PersonInfo<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">//创建并初始化map的代码.</span>myMap <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> PersonInfo<span class="token punctuation">{</span>   <span class="token string">"1234"</span><span class="token punctuation">:</span> PersonInfo<span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token string">"Room 101,..."</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">}</span> </code></pre><h1 id="通道channel"><a href="#通道channel" class="headerlink" title="通道channel"></a>通道channel</h1><ul><li>channel的内容在《浅谈Go并发编程》中已经介绍过了 不累赘</li><li>创建方式make(chan type, cap)，其中type表示通道数据类型，cap表示缓存容量</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//创建有缓存通道</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">//创建无缓存通道</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></code></pre><p>转自<a href="https://www.jianshu.com/p/f01841004810">Go内建函数make及切片slice、映射map详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 2022 notes 2 chinese version</title>
      <link href="/2022/02/16/mit-6-824-2022-notes-2-chinese-version/"/>
      <url>/2022/02/16/mit-6-824-2022-notes-2-chinese-version/</url>
      
        <content type="html"><![CDATA[<h1 id="Lecture-2-RPC-and-threads"><a href="#Lecture-2-RPC-and-threads" class="headerlink" title="Lecture 2:RPC and threads"></a>Lecture 2:RPC and threads</h1><h2 id="为什么用-Go"><a href="#为什么用-Go" class="headerlink" title="为什么用 Go"></a>为什么用 Go</h2><ol><li><strong>语法先进</strong>。在语言层面支持线程（goroutine）和管道（channel）。对线程间的加锁、同步支持良好。</li><li><strong>类型安全（type safe）</strong>。内存访问安全（memory safe），很难写出像 C++ 一样内存越界访问等 bug。</li><li><strong>支持垃圾回收（GC）</strong>。不需要用户手动管理内存（特别是shared memory），这一点在多线程编程中尤为重要，因为在多线程中你很容易引用某块内存，然后忘记了在哪引用过。</li><li><strong>简洁直观</strong>。没 C++ 那么多复杂的语言特性，并且在报错上很友好。</li></ol><h2 id="线程（Threads）"><a href="#线程（Threads）" class="headerlink" title="线程（Threads）"></a>线程（Threads）</h2><p>线程为什么这么重要？因为他是我们控制并发的主要手段，而并发是构成分布式系统的基础。在 Go 中，你可以将 goroutine 认为是线程，以下这两者混用。 每个线程可以有自己的内存栈、寄存器，但是他们可以共享一个地址空间。</p><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><p><strong>IO concurrency（IO 并发）</strong>：一个历史说法，以前单核时，IO 是主要瓶颈，为了充分利用 CPU，一个线程在进行 IO 时，可以让出 CPU，让另一个线程进行计算、读取或发送网络消息等。在这里可以理解为：你可以通过多个线程并行的发送多个网络请求（比如 RPC、HTTP 等），然后分别等待其回复。</p><p><strong>Parallelism（并行）</strong>：充分利用多核 CPU。</p><p>关于并发（concurrency）和并行（parallelism）的区别和联系，可以看<a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/">这篇文章</a>。记住两个关键词即可：逻辑并发设计 vs 物理并行执行。</p><p><strong>Convenience（方便）</strong>：比如可以在后台启动一个线程，定时执行某件事、周期性的检测什么东西（比如心跳）。</p><p><strong>Q&amp;A：</strong></p><ol><li><em>不使用线程还能如何处理并发</em>？基于事件驱动的异步编程。但是多线程模型更容易理解一些，毕竟每个线程内执行顺序和你的代码顺序是大体一致的。</li><li><em>进程和线程的区别</em>？进程是操作系统提供的一种包含有<strong>独立地址空间</strong>的一种抽象，一个 Go 程序启动时作为一个进程，可以启动很多线程，<strong>共享地址空间</strong>（不过我记得 Goroutine 是用户态的执行流）。</li></ol><h3 id="使用难点（challenges）"><a href="#使用难点（challenges）" class="headerlink" title="使用难点（challenges）"></a>使用难点（challenges）</h3><p>共享内存易出错。一个经典的问题是，多个线程并行执行语句：<code>n = n + 1</code> 时，由于该操作不是原子操作，在不加锁时，很容易出现 n 为非期望值。</p><p>我们称这种情况为<strong>竞态</strong> （race）：即两个以上的线程同时试图改变某个共享变量。</p><p>解决的方法是加锁，但如何科学的加锁以<strong>兼顾性能</strong>并<strong>避免死锁</strong>又是一门学问。</p><p><strong>Q&amp;A：</strong></p><ol><li><em>Go 是否知道锁和资源（一些共享的变量）间的映射</em>？Go 并不知道，它仅仅就是等待锁、获取锁、释放锁。需要程序员在脑中、逻辑上来自己维护。</li><li><em>Go 会锁上一个 Object 的所有变量还是部分</em>？和上个问题一样，Go 不知道任何锁与变量之间的关系。Lock 本身的源语很简单，goroutine0 调用 mu.Lock 时，没有其他 goroutine 持有锁，则 goroutine0 获取锁；如果其他 goroutine 持有锁，则一直等待直到其释放锁；当然，在某些语言，如 Java 里，会将对象或者实例等与锁绑定，以指明锁的作用域。</li><li><em>Lock 应该是某个对象的私有变量</em>？如果可以的话，最好这样做。但如果有跨对象的加锁需求，就需要拿出来了，但要注意避免死锁。</li></ol><h3 id="线程协调（Coordination）"><a href="#线程协调（Coordination）" class="headerlink" title="线程协调（Coordination）"></a>线程协调（Coordination）</h3><ol><li><p>channels：go 中比较推荐的方式，分阻塞和带缓冲。</p><p>信道可用于在其他协程结束执行之前，阻塞 Go 主协程。</p><p>sending data from one thread to another and breeding that they did to be sent  </p></li><li><p>sync.Cond：信号机制。</p><p>condition variables: 当前线程占用了锁，告诉其他等 待的线程继续等待，因为自己的确正在使用</p></li><li><p>waitGroup：阻塞知道一组 goroutine 执行完毕，后面还会提到。</p></li></ol><h3 id="死锁（DeadLock）"><a href="#死锁（DeadLock）" class="headerlink" title="死锁（DeadLock）"></a>死锁（DeadLock）</h3><p>产生条件：多个锁，循环依赖，占有并等待。</p><p>if your program is just doing nothing but not crashed, the you have to check if there is a deadlock. </p><h2 id="GO协程"><a href="#GO协程" class="headerlink" title="GO协程"></a>GO协程</h2><h3 id="GO协程是什么"><a href="#GO协程是什么" class="headerlink" title="GO协程是什么"></a>GO协程是什么</h3><p>Go 协程是与其他函数或方法一起并发运行的函数或方法。Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行</p><h3 id="协程相比于线程的优势"><a href="#协程相比于线程的优势" class="headerlink" title="协程相比于线程的优势"></a>协程相比于线程的优势</h3><ul><li>相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。</li><li>Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。</li><li>Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。信道可以看作是 Go 协程之间通信的管道。</li></ul><h3 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h3><p>调用函数或者方法时，在前面加上关键字 <code>go</code>，可以让一个新的 Go 协程并发地运行。</p><ul><li><strong>启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。</strong></li><li><strong>如果希望运行其他 Go 协程，Go 主协程必须继续运行着。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。</strong></li></ul><p>例如：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world goroutine"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main function"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在第 11 行调用了 <code>go hello()</code> 之后，程序控制没有等待 <code>hello</code> 协程结束，立即返回到了代码下一行，打印 <code>main function</code>。接着由于没有其他可执行的代码，Go 主协程终止，于是 <code>hello</code> 协程就没有机会运行了。</p><p>改成</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world goroutine"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main function"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在 Go 主协程中使用休眠，以便等待其他协程执行完毕。第 13 行，我们调用了 time 包里的函数 <a href="https://golang.org/pkg/time/#Sleep"><code>Sleep</code></a>，该函数会休眠执行它的 Go 协程。在这里，我们使 Go 主协程休眠了 1 秒。因此在主协程终止之前，调用 <code>go hello()</code> 就有足够的时间来执行了。该程序首先打印 <code>Hello world goroutine</code>，等待 1 秒钟之后，接着打印 <code>main function</code>。</p><h3 id="启动多个-Go-协程"><a href="#启动多个-Go-协程" class="headerlink" title="启动多个 Go 协程"></a>启动多个 Go 协程</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">250</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">alphabets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token char">'a'</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token char">'e'</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">400</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">go</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">alphabets</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main terminated"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在上面程序中的第 21 行和第 22 行，启动了两个 Go 协程。现在，这两个协程并发地运行。<code>numbers</code> 协程首先休眠 250 微秒，接着打印 <code>1</code>，然后再次休眠，打印 <code>2</code>，依此类推，一直到打印 <code>5</code> 结束。<code>alphabete</code> 协程同样打印从 <code>a</code> 到 <code>e</code> 的字母，并且每次有 400 微秒的休眠时间。 Go 主协程启动了 <code>numbers</code> 和 <code>alphabete</code> 两个 Go 协程，休眠了 3000 微秒后终止程序。</p><p>输出为</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span> a <span class="token number">2</span> <span class="token number">3</span> b <span class="token number">4</span> c <span class="token number">5</span> d e main terminate</code></pre><p><img src="/2022/02/16/mit-6-824-2022-notes-2-chinese-version/Goroutines-explained.png" alt="image"></p><p>第一张蓝色的图表示 <code>numbers</code> 协程，第二张褐红色的图表示 <code>alphabets</code> 协程，第三张绿色的图表示 Go 主协程，而最后一张黑色的图把以上三种协程合并了，表明程序是如何运行的。在每个方框顶部，诸如 <code>0 ms</code> 和 <code>250 ms</code> 这样的字符串表示时间（以微秒为单位）。在每个方框的底部，<code>1</code>、<code>2</code>、<code>3</code> 等表示输出。蓝色方框表示：<code>250 ms</code> 打印出 <code>1</code>，<code>500 ms</code> 打印出 <code>2</code>，依此类推。最后黑色方框的底部的值会是 <code>1 a 2 3 b 4 c 5 d e main terminated</code>，这同样也是整个程序的输出。</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><h3 id="什么是信道？"><a href="#什么是信道？" class="headerlink" title="什么是信道？"></a>什么是信道？</h3><p>信道可以想像成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。</p><h3 id="信道的声明"><a href="#信道的声明" class="headerlink" title="信道的声明"></a>信道的声明</h3><p>所有信道都关联了一个类型。信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。</p><p><code>chan T</code> 表示 <code>T</code> 类型的信道。</p><p>信道的零值为 <code>nil</code>。信道的零值没有什么用，应该像对 map 和切片所做的那样，用 <code>make</code> 来定义信道。</p><p>下面编写代码，声明一个信道。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> a <span class="token keyword">chan</span> <span class="token builtin">int</span>    <span class="token keyword">if</span> a <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"channel a is nil, going to define it"</span><span class="token punctuation">)</span>        a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Type of a is %T"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于信道的零值为 <code>nil</code>，在第 6 行，信道 <code>a</code> 的值就是 <code>nil</code>。于是，程序执行了 if 语句内的语句，定义了信道 <code>a</code>。程序中 <code>a</code> 是一个 int 类型的信道。该程序会输出：</p><pre class="language-bash" data-language="bash"><code class="language-bash">channel a is nil, going to define it  Type of a is chan int</code></pre><p>简短声明通常也是一种定义信道的简洁有效的方法。</p><pre class="language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></code></pre><p>这一行代码同样定义了一个 int 类型的信道 <code>a</code>。</p><h3 id="通过信道进行发送和接收"><a href="#通过信道进行发送和接收" class="headerlink" title="通过信道进行发送和接收"></a>通过信道进行发送和接收</h3><p>如下所示，该语法通过信道发送和接收数据。</p><pre class="language-go" data-language="go"><code class="language-go">data <span class="token operator">:=</span> <span class="token operator">&lt;-</span> a <span class="token comment">// 读取信道 a  </span>a <span class="token operator">&lt;-</span> data <span class="token comment">// 写入信道 a</span></code></pre><p>信道旁的箭头方向指定了是发送数据还是接收数据。</p><p>在第一行，箭头对于 <code>a</code> 来说是向外指的，因此我们读取了信道 <code>a</code> 的值，并把该值存储到变量 <code>data</code>。</p><p>在第二行，箭头指向了 <code>a</code>，因此我们在把数据写入信道 <code>a</code>。</p><h4 id="发送与接收默认是阻塞的"><a href="#发送与接收默认是阻塞的" class="headerlink" title="发送与接收默认是阻塞的"></a>发送与接收默认是阻塞的</h4><p>发送与接收默认是阻塞的。这是什么意思？当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，直到有其它 Go 协程从信道读取到数据，才会解除阻塞。与此类似，当读取信道的数据时，如果没有其它的协程把数据写入到这个信道，那么读取过程就会一直阻塞着。</p><p>信道的这种特性能够帮助 Go 协程之间进行高效的通信，不需要用到其他编程语言常见的显式锁或条件变量。</p><h4 id="信道的代码示例"><a href="#信道的代码示例" class="headerlink" title="信道的代码示例"></a>信道的代码示例</h4><p>理论已经够了:)。接下来写点代码，看看协程之间通过信道是怎么通信的。</p><p>首先引用前面教程里的程序。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world goroutine"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main function"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这是上一篇的代码。我们使用到了休眠，使 Go 主协程等待 hello 协程结束。</p><p>我们接下来使用信道来重写上面代码。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world goroutine"</span><span class="token punctuation">)</span>    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>    <span class="token operator">&lt;-</span>done    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main function"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在上述程序里，我们在第 12 行创建了一个 bool 类型的信道 <code>done</code>，并把 <code>done</code> 作为参数传递给了 <code>hello</code> 协程。在第 14 行，我们通过信道 <code>done</code> 接收数据。这一行代码发生了阻塞，除非有协程向 <code>done</code> 写入数据，否则程序不会跳到下一行代码。于是，这就不需要用以前的 <code>time.Sleep</code> 来阻止 Go 主协程退出了。</p><p><code>&lt;-done</code> 这行代码通过信道使用<code>done</code> 接收数据，但并没有使用数据或者把数据存储到变量中。这完全是合法的。</p><p>现在我们的 Go 主协程发生了阻塞，等待信道 <code>done</code> 发送的数据。该信道作为参数传递给了协程 <code>hello</code>，<code>hello</code> 打印出 <code>Hello world goroutine</code>，接下来向 <code>done</code> 写入数据。当完成写入时，Go 主协程会通过信道 <code>done</code> 接收数据，于是它解除阻塞状态，打印出文本 <code>main function</code>。</p><p>该程序输出如下：</p><pre class="language-none"><code class="language-none">Hello world goroutine  main function</code></pre><p>我们稍微修改一下程序，在 <code>hello</code> 协程里加入休眠函数，以便更好地理解阻塞的概念。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello go routine is going to sleep"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello go routine awake and going to write to done"</span><span class="token punctuation">)</span>    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Main going to call hello go goroutine"</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>    <span class="token operator">&lt;-</span>done    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Main received data"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在上面程序里，我们向 <code>hello</code> 函数里添加了 4 秒的休眠（第 10 行）。</p><p>程序首先会打印 <code>Main going to call hello go goroutine</code>。接着会开启 <code>hello</code> 协程，打印 <code>hello go routine is going to sleep</code>。打印完之后，<code>hello</code> 协程会休眠 4 秒钟，而在这期间，主协程会在 <code>&lt;-done</code> 这一行发生阻塞，等待来自信道 <code>done</code> 的数据。4 秒钟之后，打印 <code>hello go routine awake and going to write to done</code>，接着再打印 <code>Main received data</code>。</p><h4 id="信道的另一个示例"><a href="#信道的另一个示例" class="headerlink" title="信道的另一个示例"></a>信道的另一个示例</h4><p>我们再编写一个程序来更好地理解信道。该程序会计算一个数中每一位的平方和与立方和，然后把平方和与立方和相加并打印出来。</p><p>例如，如果输出是 123，该程序会如下计算输出：</p><pre class="language-none"><code class="language-none">squares = (1 * 1) + (2 * 2) + (3 * 3) cubes = (1 * 1 * 1) + (2 * 2 * 2) + (3 * 3 * 3) output = squares + cubes = 50</code></pre><p>我们会这样去构建程序：在一个单独的 Go 协程计算平方和，而在另一个协程计算立方和，最后在 Go 主协程把平方和与立方和相加。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">calcSquares</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">,</span> squareop <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> number <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        digit <span class="token operator">:=</span> number <span class="token operator">%</span> <span class="token number">10</span>        sum <span class="token operator">+=</span> digit <span class="token operator">*</span> digit        number <span class="token operator">/=</span> <span class="token number">10</span>    <span class="token punctuation">}</span>    squareop <span class="token operator">&lt;-</span> sum<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calcCubes</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">,</span> cubeop <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>     <span class="token keyword">for</span> number <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        digit <span class="token operator">:=</span> number <span class="token operator">%</span> <span class="token number">10</span>        sum <span class="token operator">+=</span> digit <span class="token operator">*</span> digit <span class="token operator">*</span> digit        number <span class="token operator">/=</span> <span class="token number">10</span>    <span class="token punctuation">}</span>    cubeop <span class="token operator">&lt;-</span> sum<span class="token punctuation">}</span> <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      number <span class="token operator">:=</span> <span class="token number">589</span>    sqrch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    cubech <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">calcSquares</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> sqrch<span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">calcCubes</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> cubech<span class="token punctuation">)</span>    squares<span class="token punctuation">,</span> cubes <span class="token operator">:=</span> <span class="token operator">&lt;-</span>sqrch<span class="token punctuation">,</span> <span class="token operator">&lt;-</span>cubech    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Final output"</span><span class="token punctuation">,</span> squares <span class="token operator">+</span> cubes<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/4RKr7_YO_B">在线运行程序</a></p><p>在第 7 行，函数 <code>calcSquares</code> 计算一个数每位的平方和，并把结果发送给信道 <code>squareop</code>。与此类似，在第 17 行函数 <code>calcCubes</code> 计算一个数每位的立方和，并把结果发送给信道 <code>cubop</code>。</p><p>这两个函数分别在单独的协程里运行（第 31 行和第 32 行），每个函数都有传递信道的参数，以便写入数据。Go 主协程会在第 33 行等待两个信道传来的数据。一旦从两个信道接收完数据，数据就会存储在变量 <code>squares</code> 和 <code>cubes</code> 里，然后计算并打印出最后结果。该程序会输出：</p><pre class="language-none"><code class="language-none">Final output 1536</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>使用信道需要考虑的一个重点是死锁。当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 panic，形成死锁。</p><p>同理，当有 Go 协程等着从一个信道接收数据时，我们期望其他的 Go 协程会向该信道写入数据，要不然程序就会触发 panic。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    ch <span class="token operator">&lt;-</span> <span class="token number">5</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/q1O5sNx4aW">在线运行程序</a></p><p>在上述程序中，我们创建了一个信道 <code>ch</code>，接着在下一行 <code>ch &lt;- 5</code>，我们把 <code>5</code> 发送到这个信道。对于本程序，没有其他的协程从 <code>ch</code> 接收数据。于是程序触发 panic，出现如下运行时错误。</p><pre class="language-bash" data-language="bash"><code class="language-bash">fatal error: all goroutines are asleep - deadlock<span class="token operator">!</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span>chan send<span class="token punctuation">]</span>:  main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>      /tmp/sandbox249677995/main.go:6 +0x80</code></pre><h3 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h3><p>我们目前讨论的信道都是双向信道，即通过信道既能发送数据，又能接收数据。其实也可以创建单向信道，这种信道只能发送或者接收数据。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">sendData</span><span class="token punctuation">(</span>sendch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sendch <span class="token operator">&lt;-</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sendch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">sendData</span><span class="token punctuation">(</span>sendch<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>sendch<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/PRKHxM-iRK">在线运行程序</a></p><p>上面程序的第 10 行，我们创建了唯送（Send Only）信道 <code>sendch</code>。<code>chan&lt;- int</code> 定义了唯送信道，因为箭头指向了 <code>chan</code>。在第 12 行，我们试图通过唯送信道接收数据，于是编译器报错：</p><pre class="language-none"><code class="language-none">main.go:11: invalid operation: &lt;-sendch (receive from send-only type chan&lt;- int)</code></pre><p><strong>一切都很顺利，只不过一个不能读取数据的唯送信道究竟有什么意义呢？</strong></p><p><strong>这就需要用到信道转换（Channel Conversion）了。把一个双向信道转换成唯送信道或者唯收（Receive Only）信道都是行得通的，但是反过来就不行。</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">sendData</span><span class="token punctuation">(</span>sendch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sendch <span class="token operator">&lt;-</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      cha1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">sendData</span><span class="token punctuation">(</span>cha1<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>cha1<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/aqi_rJ1U8j">在线运行程序</a></p><p>在上述程序的第 10 行，我们创建了一个双向信道 <code>cha1</code>。在第 11 行 <code>cha1</code> 作为参数传递给了 <code>sendData</code> 协程。<strong>在第 5 行，函数 <code>sendData</code> 里的参数 <code>sendch chan&lt;- int</code> 把 <code>cha1</code> 转换为一个唯送信道</strong>。于是该信道在 <code>sendData</code> 协程里是一个唯送信道，而在 Go 主协程里是一个双向信道。该程序最终打印输出 <code>10</code>。</p><h3 id="关闭信道和使用-for-range-遍历信道"><a href="#关闭信道和使用-for-range-遍历信道" class="headerlink" title="关闭信道和使用 for range 遍历信道"></a>关闭信道和使用 for range 遍历信道</h3><p>数据发送方可以关闭信道，通知接收方这个信道不再有数据发送过来。</p><p>当从信道接收数据时，接收方可以多用一个变量来检查信道是否已经关闭。</p><pre class="language-none"><code class="language-none">v, ok := &lt;- ch</code></pre><p>上面的语句里，如果成功接收信道所发送的数据，那么 <code>ok</code> 等于 true。而如果 <code>ok</code> 等于 false，说明我们试图读取一个关闭的通道。从关闭的信道读取到的值会是该信道类型的零值。例如，当信道是一个 <code>int</code> 类型的信道时，那么从关闭的信道读取的值将会是 <code>0</code>。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">producer</span><span class="token punctuation">(</span>chnl <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        chnl <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>chnl<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">producer</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch        <span class="token keyword">if</span> ok <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received "</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/XWmUKDA2Ri">在线运行程序</a></p><p>在上述的程序中，<code>producer</code> 协程会从 0 到 9 写入信道 <code>chn1</code>，然后关闭该信道。主函数有一个无限的 for 循环（第 16 行），使用变量 <code>ok</code>（第 18 行）检查信道是否已经关闭。如果 <code>ok</code> 等于 false，说明信道已经关闭，于是退出 for 循环。如果 <code>ok</code> 等于 true，会打印出接收到的值和 <code>ok</code> 的值。</p><pre class="language-none"><code class="language-none">Received  0 true  Received  1 true  Received  2 true  Received  3 true  Received  4 true  Received  5 true  Received  6 true  Received  7 true  Received  8 true  Received  9 true</code></pre><p>for range 循环用于在一个信道关闭之前，从信道接收数据。</p><p>接下来我们使用 for range 循环重写上面的代码。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">producer</span><span class="token punctuation">(</span>chnl <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        chnl <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>chnl<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">producer</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>    <span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received "</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/JJ3Ida1r_6">在线运行程序</a></p><p>在第 16 行，for range 循环从信道 <code>ch</code> 接收数据，直到该信道关闭。一旦关闭了 <code>ch</code>，循环会自动结束。该程序会输出：</p><pre class="language-none"><code class="language-none">Received  0  Received  1  Received  2  Received  3  Received  4  Received  5  Received  6  Received  7  Received  8  Received  9</code></pre><p>我们可以使用 for range 循环，重写<a href="https://studygolang.com/articles/12402#">信道的另一个示例</a>这一节里面的代码，提高代码的可重用性。</p><p>如果你仔细观察这段代码，会发现获得一个数里的每位数的代码在 <code>calcSquares</code> 和 <code>calcCubes</code> 两个函数内重复了。我们将把这段代码抽离出来，放在一个单独的函数里，然后并发地调用它。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">digits</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">,</span> dchnl <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> number <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        digit <span class="token operator">:=</span> number <span class="token operator">%</span> <span class="token number">10</span>        dchnl <span class="token operator">&lt;-</span> digit        number <span class="token operator">/=</span> <span class="token number">10</span>    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>dchnl<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calcSquares</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">,</span> squareop <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>    dch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">digits</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> dch<span class="token punctuation">)</span>    <span class="token keyword">for</span> digit <span class="token operator">:=</span> <span class="token keyword">range</span> dch <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> digit <span class="token operator">*</span> digit    <span class="token punctuation">}</span>    squareop <span class="token operator">&lt;-</span> sum<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calcCubes</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">,</span> cubeop <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>    dch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">digits</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> dch<span class="token punctuation">)</span>    <span class="token keyword">for</span> digit <span class="token operator">:=</span> <span class="token keyword">range</span> dch <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> digit <span class="token operator">*</span> digit <span class="token operator">*</span> digit    <span class="token punctuation">}</span>    cubeop <span class="token operator">&lt;-</span> sum<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      number <span class="token operator">:=</span> <span class="token number">589</span>    sqrch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    cubech <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">calcSquares</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> sqrch<span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">calcCubes</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> cubech<span class="token punctuation">)</span>    squares<span class="token punctuation">,</span> cubes <span class="token operator">:=</span> <span class="token operator">&lt;-</span>sqrch<span class="token punctuation">,</span> <span class="token operator">&lt;-</span>cubech    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Final output"</span><span class="token punctuation">,</span> squares<span class="token operator">+</span>cubes<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/oL86W9Ui03">在线运行程序</a></p><p>上述程序里的 <code>digits</code> 函数，包含了获取一个数的每位数的逻辑，并且 <code>calcSquares</code> 和 <code>calcCubes</code> 两个函数并发地调用了 <code>digits</code>。当计算完数字里面的每一位数时，第 13 行就会关闭信道。<code>calcSquares</code> 和 <code>calcCubes</code> 两个协程使用 for range 循环分别监听了它们的信道，直到该信道关闭。程序的其他地方不变，该程序同样会输出：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Final output <span class="token number">1536</span></code></pre><h2 id="缓冲信道"><a href="#缓冲信道" class="headerlink" title="缓冲信道"></a>缓冲信道</h2><h3 id="什么是缓冲信道？"><a href="#什么是缓冲信道？" class="headerlink" title="什么是缓冲信道？"></a>什么是缓冲信道？</h3><p>无缓冲信道的发送和接收过程是阻塞的，我们还可以创建一个有缓冲（Buffer）的信道。只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。同样，只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。</p><p>通过向 <code>make</code> 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。</p><pre class="language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">type</span><span class="token punctuation">,</span> capacity<span class="token punctuation">)</span></code></pre><p>要让一个信道有缓冲，上面语法中的 <code>capacity</code> 应该大于 0。无缓冲信道的容量默认为 0，创建无缓冲信道时，可以省略容量参数。</p><p>我们开始编写代码，创建一个缓冲信道。</p><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"naveen"</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"paul"</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span> ch<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span> ch<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/It-em11etK">在线运行程序</a></p><p>在上面程序里的第 9 行，我们创建了一个缓冲信道，其容量为 2。由于该信道的容量为 2，因此可向它写入两个字符串，而且不会发生阻塞。在第 10 行和第 11 行，我们向信道写入两个字符串，该信道并没有发生阻塞。我们又在第 12 行和第 13 行分别读取了这两个字符串。该程序输出：</p><pre class="language-none"><code class="language-none">naveen  paul</code></pre><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>我们再看一个缓冲信道的示例，其中有一个并发的 Go 协程来向信道写入数据，而 Go 主协程负责读取数据。该示例帮助我们进一步理解，在向缓冲信道写入数据时，什么时候会发生阻塞。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">write</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        ch <span class="token operator">&lt;-</span> i        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"successfully wrote"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">"to ch"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment">//立即会向 `ch` 写入 0 和 1，接下来发生阻塞，直到 `ch` 内的值被读取</span>    <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">write</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token comment">//休眠，等待协程运行</span>    <span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read value"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span><span class="token string">"from ch"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/bKe5GdgMK9">在线运行程序</a></p><p>在上面的程序中，第 16 行在 Go 主协程中创建了容量为 2 的缓冲信道 <code>ch</code>，而第 17 行把 <code>ch</code> 传递给了 <code>write</code> 协程。接下来 Go 主协程休眠了两秒。在这期间，<code>write</code> 协程在并发地运行。<code>write</code> 协程有一个 for 循环，依次向信道 <code>ch</code> 写入 0～4。而缓冲信道的容量为 2，因此 <code>write</code> 协程里立即会向 <code>ch</code> 写入 0 和 1，接下来发生阻塞，直到 <code>ch</code> 内的值被读取。因此，该程序立即打印出下面两行：</p><pre class="language-none"><code class="language-none">successfully wrote 0 to ch  successfully wrote 1 to ch</code></pre><p>打印上面两行之后，<code>write</code> 协程中向 <code>ch</code> 的写入发生了阻塞，直到 <code>ch</code> 有值被读取到。而 Go 主协程休眠了两秒后，才开始读取该信道，因此在休眠期间程序不会打印任何结果。主协程结束休眠后，在第 19 行使用 for range 循环，开始读取信道 <code>ch</code>，打印出了读取到的值后又休眠两秒，这个循环一直到 <code>ch</code> 关闭才结束。所以该程序在两秒后会打印下面两行：</p><pre class="language-none"><code class="language-none">read value 0 from ch  successfully wrote 2 to ch</code></pre><p>该过程会一直进行，直到信道读取完所有的值，并在 <code>write</code> 协程中关闭信道。最终输出如下：</p><pre class="language-none"><code class="language-none">successfully wrote 0 to ch  successfully wrote 1 to ch  read value 0 from ch  successfully wrote 2 to ch  read value 1 from ch  successfully wrote 3 to ch  read value 2 from ch  successfully wrote 4 to ch  read value 3 from ch  read value 4 from ch</code></pre><h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"naveen"</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"paul"</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"steve"</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/FW-LHeH7oD">在线运行程序</a></p><p>在上面程序里，我们向容量为 2 的缓冲信道写入 3 个字符串。当在程序控制到达第 3 次写入时（第 11 行），由于它超出了信道的容量，因此这次写入发生了阻塞。现在想要这次写操作能够进行下去，必须要有其它协程来读取这个信道的数据。但在本例中，并没有并发协程来读取这个信道，因此这里会发生<strong>死锁</strong>（deadlock）。程序会在运行时触发 panic，信息如下：</p><pre class="language-none"><code class="language-none">fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:  main.main()      /tmp/sandbox274756028/main.go:11 +0x100</code></pre><h3 id="长度-vs-容量"><a href="#长度-vs-容量" class="headerlink" title="长度 vs 容量"></a>长度 vs 容量</h3><p>缓冲信道的容量是指信道可以存储的值的数量。我们在使用 <code>make</code> 函数创建缓冲信道的时候会指定容量大小。</p><p>缓冲信道的长度是指信道中当前排队的元素个数。</p><p>代码可以把一切解释得很清楚。:)</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"naveen"</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"paul"</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"capacity is"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"length is"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read value"</span><span class="token punctuation">,</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"new length is"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/2ggC64yyvr">在线运行程序</a></p><p>在上面的程序里，我们创建了一个容量为 3 的信道，于是它可以保存 3 个字符串。接下来，我们分别在第 9 行和第 10 行向信道写入了两个字符串。于是信道有两个字符串排队，因此其长度为 2。在第 13 行，我们又从信道读取了一个字符串。现在该信道内只有一个字符串，因此其长度变为 1。该程序会输出：</p><pre class="language-none"><code class="language-none">capacity is 3  length is 2  read value naveen  new length is 1</code></pre><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>在本教程的下一节里，我们会讲到<strong>工作池</strong>（Worker Pools）。而 <code>WaitGroup</code> 用于实现工作池，因此要理解工作池，我们首先需要学习 <code>WaitGroup</code>。</p><p><code>WaitGroup</code> 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。假设我们有 3 个并发执行的 Go 协程（由 Go 主协程生成）。Go 主协程需要等待这 3 个协程执行结束后，才会终止。这就可以用 <code>WaitGroup</code> 来实现。</p><p>理论说完了，我们编写点儿代码吧。:)</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//注意一定是传递的地址，使用同一个waitgroup变量 </span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"started Goroutine "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Goroutine %d ended\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      no <span class="token operator">:=</span> <span class="token number">3</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> no<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wg<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"All go routines finished executing"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/CZNtu8ktQh">在线运行程序</a></p><p><a href="https://golang.org/pkg/sync/#WaitGroup">WaitGroup</a> 是一个结构体类型，我们在第 18 行创建了 <code>WaitGroup</code> 类型的变量，其初始值为零值。<code>WaitGroup</code> 使用计数器来工作。当我们调用 <code>WaitGroup</code> 的 <code>Add</code> 并传递一个 <code>int</code> 时，**<code>WaitGroup</code> 的计数器会加上 <code>Add</code> 的传参**。要减少计数器，可以调用 <code>WaitGroup</code> 的 <code>Done()</code> 方法。<code>Wait()</code> 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。</p><p>上述程序里，for 循环迭代了 3 次，我们在循环内调用了 <code>wg.Add(1)</code>（第 20 行）。因此计数器变为 3。for 循环同样创建了 3 个 <code>process</code> 协程，然后在第 23 行调用了 <code>wg.Wait()</code>，确保 Go 主协程等待计数器变为 0。在第 13 行，<code>process</code> 协程内调用了 <code>wg.Done</code>，可以让计数器递减。一旦 3 个子协程都执行完毕（即 <code>wg.Done()</code> 调用了 3 次），那么计数器就变为 0，于是主协程会解除阻塞。</p><p><strong>在第 21 行里，传递 <code>wg</code> 的地址是很重要的。如果没有传递 <code>wg</code> 的地址，那么每个 Go 协程将会得到一个 <code>WaitGroup</code> 值的拷贝，因而当它们执行结束时，<code>main</code> 函数并不会知道</strong>。</p><p>该程序输出：</p><pre class="language-none"><code class="language-none">started Goroutine  2  started Goroutine  0  started Goroutine  1  Goroutine 0 ended  Goroutine 2 ended  Goroutine 1 ended  All go routines finished executing</code></pre><p>由于 Go 协程的执行顺序不一定，因此你的输出可能和我不一样。:)</p><h3 id="工作池的实现"><a href="#工作池的实现" class="headerlink" title="工作池的实现"></a>工作池的实现</h3><p>缓冲信道的重要应用之一就是实现<a href="https://en.wikipedia.org/wiki/Thread_pool">工作池</a>。</p><p>一般而言，工作池就是一组等待任务分配的线程。一旦完成了所分配的任务，这些线程可继续等待任务的分配。</p><p>我们会使用缓冲信道来实现工作池。我们工作池的任务是计算所输入数字的每一位的和。例如，如果输入 234，结果会是 9（即 2 + 3 + 4）。向工作池输入的是一列伪随机数。</p><p>我们工作池的核心功能如下：</p><ul><li>创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。</li><li>将作业添加到该输入型缓冲信道中。</li><li>作业完成后，再将结果写入一个输出型缓冲信道。</li><li>从输出型缓冲信道读取并打印结果。</li></ul><p>我们会逐步编写这个程序，让代码易于理解。</p><p>第一步就是创建一个结构体，表示作业和结果。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Job <span class="token keyword">struct</span> <span class="token punctuation">{</span>      id       <span class="token builtin">int</span>    randomno <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">type</span> Result <span class="token keyword">struct</span> <span class="token punctuation">{</span>      job         Job    sumofdigits <span class="token builtin">int</span><span class="token punctuation">}</span></code></pre><p>所有 <code>Job</code> 结构体变量都会有 <code>id</code> 和 <code>randomno</code> 两个字段，<code>randomno</code> 用于计算其每位数之和。</p><p>而 <code>Result</code> 结构体有一个 <code>job</code> 字段，表示所对应的作业，还有一个 <code>sumofdigits</code> 字段，表示计算的结果（每位数字之和）。</p><p>第二步是分别创建用于接收作业和写入结果的缓冲信道。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> jobs <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Job<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> results <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Result<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span></code></pre><p>工作协程（Worker Goroutine）会监听缓冲信道 <code>jobs</code> 里更新的作业。一旦工作协程完成了作业，其结果会写入缓冲信道 <code>results</code>。</p><p>如下所示，<code>digits</code> 函数的任务实际上就是计算整数的每一位之和，最后返回该结果。为了模拟出 <code>digits</code> 在计算过程中花费了一段时间，我们在函数内添加了两秒的休眠时间。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">digits</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>    no <span class="token operator">:=</span> number    <span class="token keyword">for</span> no <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        digit <span class="token operator">:=</span> no <span class="token operator">%</span> <span class="token number">10</span>        sum <span class="token operator">+=</span> digit        no <span class="token operator">/=</span> <span class="token number">10</span>    <span class="token punctuation">}</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span></code></pre><p>然后，我们写一个创建工作协程的函数。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> job <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>        output <span class="token operator">:=</span> Result<span class="token punctuation">{</span>job<span class="token punctuation">,</span> <span class="token function">digits</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span>randomno<span class="token punctuation">)</span><span class="token punctuation">}</span>        results <span class="token operator">&lt;-</span> output    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上面的函数创建了一个工作者（Worker），读取 <code>jobs</code> 信道的数据，根据当前的 <code>job</code> 和 <code>digits</code> 函数的返回值，创建了一个 <code>Result</code> 结构体变量，然后将结果写入 <code>results</code> 缓冲信道。<code>worker</code> 函数接收了一个 <code>WaitGroup</code> 类型的 <code>wg</code> 作为参数，当所有的 <code>jobs</code> 完成的时候，调用了 <code>Done()</code> 方法。</p><p><code>createWorkerPool</code> 函数创建了一个 Go 协程的工作池。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">createWorkerPool</span><span class="token punctuation">(</span>noOfWorkers <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfWorkers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wg<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">close</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上面函数的参数是需要创建的工作协程的数量。在创建 Go 协程之前，它调用了 <code>wg.Add(1)</code> 方法，于是 <code>WaitGroup</code> 计数器递增。接下来，我们创建工作协程，并向 <code>worker</code> 函数传递 <code>wg</code> 的地址。创建了需要的工作协程后，函数调用 <code>wg.Wait()</code>，等待所有的 Go 协程执行完毕。所有协程完成执行之后，函数会关闭 <code>results</code> 信道。因为所有协程都已经执行完毕，于是不再需要向 <code>results</code> 信道写入数据了。</p><p>现在我们已经有了工作池，我们继续编写一个函数，把作业分配给工作者。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">allocate</span><span class="token punctuation">(</span>noOfJobs <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfJobs<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        randomno <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span>        job <span class="token operator">:=</span> Job<span class="token punctuation">{</span>i<span class="token punctuation">,</span> randomno<span class="token punctuation">}</span>        jobs <span class="token operator">&lt;-</span> job    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上面的 <code>allocate</code> 函数接收所需创建的作业数量作为输入参数，生成了最大值为 998 的伪随机数，并使用该随机数创建了 <code>Job</code> 结构体变量。这个函数把 for 循环的计数器 <code>i</code> 作为 id，最后把创建的结构体变量写入 <code>jobs</code> 信道。当写入所有的 <code>job</code> 时，它关闭了 <code>jobs</code> 信道。</p><p>下一步是创建一个读取 <code>results</code> 信道和打印输出的函数。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">result</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> result <span class="token operator">:=</span> <span class="token keyword">range</span> results <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Job id %d, input random no %d , sum of digits %d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span>job<span class="token punctuation">.</span>id<span class="token punctuation">,</span> result<span class="token punctuation">.</span>job<span class="token punctuation">.</span>randomno<span class="token punctuation">,</span> result<span class="token punctuation">.</span>sumofdigits<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p><code>result</code> 函数读取 <code>results</code> 信道，并打印出 <code>job</code> 的 <code>id</code>、输入的随机数、该随机数的每位数之和。<code>result</code> 函数也接受 <code>done</code> 信道作为参数，当打印所有结果时，<code>done</code> 会被写入 true。</p><p>现在一切准备充分了。我们继续完成最后一步，在 <code>main()</code> 函数中调用上面所有的函数。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      startTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    noOfJobs <span class="token operator">:=</span> <span class="token number">100</span>    <span class="token keyword">go</span> <span class="token function">allocate</span><span class="token punctuation">(</span>noOfJobs<span class="token punctuation">)</span>    done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">result</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>    noOfWorkers <span class="token operator">:=</span> <span class="token number">10</span>    <span class="token function">createWorkerPool</span><span class="token punctuation">(</span>noOfWorkers<span class="token punctuation">)</span>    <span class="token operator">&lt;-</span>done    endTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    diff <span class="token operator">:=</span> endTime<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"total time taken "</span><span class="token punctuation">,</span> diff<span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"seconds"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我们首先在 <code>main</code> 函数的第 2 行，保存了程序的起始时间，并在最后一行（第 12 行）计算了 <code>endTime</code> 和 <code>startTime</code> 的差值，显示出程序运行的总时间。由于我们想要通过改变协程数量，来做一点基准指标（Benchmark），所以需要这么做。</p><p>我们把 <code>noOfJobs</code> 设置为 100，接下来调用了 <code>allocate</code>，向 <code>jobs</code> 信道添加作业。</p><p>我们创建了 <code>done</code> 信道，并将其传递给 <code>result</code> 协程。于是该协程会开始打印结果，并在完成打印时发出通知。</p><p>通过调用 <code>createWorkerPool</code> 函数，我们最终创建了一个有 10 个协程的工作池。<code>main</code> 函数会监听 <code>done</code> 信道的通知，等待所有结果打印结束。</p><p>为了便于参考，下面是整个程序。我还引用了必要的包。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>      <span class="token string">"fmt"</span>    <span class="token string">"math/rand"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Job <span class="token keyword">struct</span> <span class="token punctuation">{</span>      id       <span class="token builtin">int</span>    randomno <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">type</span> Result <span class="token keyword">struct</span> <span class="token punctuation">{</span>      job         Job    sumofdigits <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">var</span> jobs <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Job<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> results <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Result<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">digits</span><span class="token punctuation">(</span>number <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>      sum <span class="token operator">:=</span> <span class="token number">0</span>    no <span class="token operator">:=</span> number    <span class="token keyword">for</span> no <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        digit <span class="token operator">:=</span> no <span class="token operator">%</span> <span class="token number">10</span>        sum <span class="token operator">+=</span> digit        no <span class="token operator">/=</span> <span class="token number">10</span>    <span class="token punctuation">}</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> job <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>        output <span class="token operator">:=</span> Result<span class="token punctuation">{</span>job<span class="token punctuation">,</span> <span class="token function">digits</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span>randomno<span class="token punctuation">)</span><span class="token punctuation">}</span>        results <span class="token operator">&lt;-</span> output    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">createWorkerPool</span><span class="token punctuation">(</span>noOfWorkers <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfWorkers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wg<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">close</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">allocate</span><span class="token punctuation">(</span>noOfJobs <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfJobs<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        randomno <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span>        job <span class="token operator">:=</span> Job<span class="token punctuation">{</span>i<span class="token punctuation">,</span> randomno<span class="token punctuation">}</span>        jobs <span class="token operator">&lt;-</span> job    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">result</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> result <span class="token operator">:=</span> <span class="token keyword">range</span> results <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Job id %d, input random no %d , sum of digits %d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span>job<span class="token punctuation">.</span>id<span class="token punctuation">,</span> result<span class="token punctuation">.</span>job<span class="token punctuation">.</span>randomno<span class="token punctuation">,</span> result<span class="token punctuation">.</span>sumofdigits<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      startTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    noOfJobs <span class="token operator">:=</span> <span class="token number">100</span>    <span class="token keyword">go</span> <span class="token function">allocate</span><span class="token punctuation">(</span>noOfJobs<span class="token punctuation">)</span>    done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">result</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>    noOfWorkers <span class="token operator">:=</span> <span class="token number">10</span>    <span class="token function">createWorkerPool</span><span class="token punctuation">(</span>noOfWorkers<span class="token punctuation">)</span>    <span class="token operator">&lt;-</span>done    endTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    diff <span class="token operator">:=</span> endTime<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"total time taken "</span><span class="token punctuation">,</span> diff<span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"seconds"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/au5islUIbx">在线运行程序</a></p><p>为了更精确地计算总时间，请在你的本地机器上运行该程序。</p><p>该程序输出：</p><pre class="language-none"><code class="language-none">Job id 1, input random no 636, sum of digits 15  Job id 0, input random no 878, sum of digits 23  Job id 9, input random no 150, sum of digits 6  ...total time taken  20.01081009 seconds</code></pre><p>程序总共会打印 100 行，对应着 100 项作业，然后最后会打印一行程序消耗的总时间。你的输出会和我的不同，因为 Go 协程的运行顺序不一定，同样总时间也会因为硬件而不同。在我的例子中，运行程序大约花费了 20 秒。</p><p>现在我们把 <code>main</code> 函数里的 <code>noOfWorkers</code> 增加到 20。我们把工作者的数量加倍了。由于工作协程增加了（准确说来是两倍），因此程序花费的总时间会减少（准确说来是一半）。在我的例子里，程序会打印出 10.004364685 秒。</p><pre class="language-none"><code class="language-none">...total time taken  10.004364685 seconds</code></pre><p>现在我们可以理解了，随着工作协程数量增加，完成作业的总时间会减少。你们可以练习一下：在 <code>main</code> 函数里修改 <code>noOfJobs</code> 和 <code>noOfWorkers</code> 的值，并试着去分析一下结果。</p><h3 id="questions"><a href="#questions" class="headerlink" title="questions"></a>questions</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">allocate</span><span class="token punctuation">(</span>noOfJobs <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfJobs<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span> randomno <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span> job <span class="token operator">:=</span> Job<span class="token punctuation">{</span>i<span class="token punctuation">,</span> randomno<span class="token punctuation">}</span> jobs <span class="token operator">&lt;-</span> job <span class="token punctuation">}</span> <span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span> <span class="token punctuation">}</span> </code></pre><p>如果for循环结束后，jobs里面的数据worker还来不及取走，这时执行到close，会不会导致works取数据失败？或者取不到足额的任务？ </p><p>这里 <code>close</code> 和关闭文件的概念不同。<br>golang 里的 <code>close</code> 只是用于通知信道的接收方，所有数据都已经发送完毕，信道<strong>没有真正关闭</strong>。<br>若用 <code>for range</code> 接收数据时，对于关闭了的信道，会接收完剩下的有效数据，并退出循环。如果没有 <code>close</code> 提示数据发送完毕的话，<code>for range</code> 会接收完剩下所有有效数据后发生阻塞。<br>所以接收方 <code>worker</code> 是可以把 <code>jobs</code> 剩下的数据取走的。后面垃圾收集器会自动回收掉该信道的内存。</p><h2 id="爬虫（Web-crawler）"><a href="#爬虫（Web-crawler）" class="headerlink" title="爬虫（Web crawler）"></a>爬虫（Web crawler）</h2><ol><li><p>从一个种子网页 URL 开始</p></li><li><p>通过 HTTP 请求，获取其内容文本</p></li><li><p>解析其内容包含的所有 URL，针对所有 URL 重复过程 2，3</p><p>为了避免重复抓取，需要记下所有抓取过的 URL。</p></li></ol><p>由于：</p><ol><li>网页数量巨大</li><li>网络请求较慢<br>一个接一个的抓取用时太长，因此需要并行抓取。这里面有个难点，就是如何判断已经抓取完所有网页，并需要结束抓取。</li></ol><h3 id="抓取代码"><a href="#抓取代码" class="headerlink" title="抓取代码"></a>抓取代码</h3><p>代码在<a href="https://pdos.csail.mit.edu/6.824/notes/crawler.go">阅读材料</a>中有。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token comment">//</span><span class="token comment">// Several solutions to the crawler exercise from the Go tutorial</span><span class="token comment">// https://tour.golang.org/concurrency/10</span><span class="token comment">//</span><span class="token comment">//</span><span class="token comment">// Serial crawler</span><span class="token comment">//</span><span class="token keyword">func</span> <span class="token function">Serial</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">,</span> fetched <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span><span class="token function">Serial</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> fetched<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">// Concurrent crawler with shared state and Mutex</span><span class="token comment">//</span><span class="token keyword">type</span> fetchState <span class="token keyword">struct</span> <span class="token punctuation">{</span>mu      sync<span class="token punctuation">.</span>Mutex<span class="token comment">//除了bool数组之外还多了一个互斥锁mu。它的原理就是用来给共享变量fetched加锁，保证在多线程爬虫时，每次只有一个线程能访问fetched变量。</span>fetched <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">,</span> f <span class="token operator">*</span>fetchState<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//之所以使用*就是为了所有的线程都使用shared memory</span>f<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>already <span class="token operator">:=</span> f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment">//这里两个线程可能对于同一个网页提取（不同的url中的引用，然后都得到了false</span>f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment">//所以放在一起执行，line43，44是原子操作</span>f<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//当mu已经被锁上时，任何试图访问它的线程都会阻塞在mu.Lock()处，直到mu被释放掉才能往下进行（可以理解为二元信号量的wait操作）</span><span class="token keyword">if</span> already <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">var</span> done sync<span class="token punctuation">.</span>WaitGroup<span class="token comment">//用来确定何时结束爬虫的，WaitGroup 对象内部有一个计数器，最初从0开始，它有三个方法：Add(), Done(), Wait() 用来控制计数器的数量。Add(n) 把计数器设置为n ，Done() 每次把计数器-1 ，wait() 会阻塞代码的运行，直到计数器地值减为0 （可以理解为counting semaphore）</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>done<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        u2 <span class="token operator">:=</span> u<span class="token comment">//因为在一次循环之中用了u之后，传入的如果是地址，第二次循环的u会变化，但是其实我们并不期望这样的变化</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。对于每个域名下面的链接，会再启动一个ConcurrentMutex线程来抓取，而不是单纯的递归，这样就实现了多线程,类似于c中的fork()函数</span><span class="token keyword">defer</span> done<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//避免有的函数调用失败，无论如何都要调用done</span><span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>u2<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//go func(u string) {//go中默认传输的不是地址，是一份u的copy，注释掉的代码实现了一样的效果</span><span class="token comment">//defer done.Done()</span><span class="token comment">//ConcurrentMutex(u, fetcher, f)</span><span class="token comment">//}(u)</span><span class="token punctuation">}</span>done<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">makeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>fetchState <span class="token punctuation">{</span>f <span class="token operator">:=</span> <span class="token operator">&amp;</span>fetchState<span class="token punctuation">{</span><span class="token punctuation">}</span>f<span class="token punctuation">.</span>fetched <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">return</span> f<span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">// Concurrent crawler with channels</span><span class="token comment">//</span><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>ch <span class="token operator">&lt;-</span> urls<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">master</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>n <span class="token operator">:=</span> <span class="token number">1</span>fetched <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">for</span> urls <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span><span class="token keyword">if</span> fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>n <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>n <span class="token operator">-=</span> <span class="token number">1</span><span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">ConcurrentChannel</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">master</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">// main</span><span class="token comment">//</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"=== Serial===\n"</span><span class="token punctuation">)</span><span class="token function">Serial</span><span class="token punctuation">(</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"=== ConcurrentMutex ===\n"</span><span class="token punctuation">)</span><span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> <span class="token function">makeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"=== ConcurrentChannel ===\n"</span><span class="token punctuation">)</span><span class="token function">ConcurrentChannel</span><span class="token punctuation">(</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">// Fetcher</span><span class="token comment">//</span><span class="token keyword">type</span> Fetcher <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token comment">// Fetch returns a slice of URLs found on the page.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>urls <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// fakeFetcher is Fetcher that returns canned results.</span><span class="token keyword">type</span> fakeFetcher <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>fakeResult<span class="token keyword">type</span> fakeResult <span class="token keyword">struct</span> <span class="token punctuation">{</span>body <span class="token builtin">string</span>urls <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f fakeFetcher<span class="token punctuation">)</span> <span class="token function">Fetch</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> res<span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"found:   %s\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">.</span>urls<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"missing: %s\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"not found: %s"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// fetcher is a populated fakeFetcher.</span><span class="token keyword">var</span> fetcher <span class="token operator">=</span> fakeFetcher<span class="token punctuation">{</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>fakeResult<span class="token punctuation">{</span><span class="token string">"The Go Programming Language"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"http://golang.org/pkg/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/cmd/"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/"</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>fakeResult<span class="token punctuation">{</span><span class="token string">"Packages"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/cmd/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/fmt/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/os/"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/fmt/"</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>fakeResult<span class="token punctuation">{</span><span class="token string">"Package fmt"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/os/"</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>fakeResult<span class="token punctuation">{</span><span class="token string">"Package os"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span><span class="token string">"http://golang.org/pkg/"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>为了简便起见，这其实只是一个假的爬虫……并没有涉及网络访问，它的作用就是在fetcher中建立一个string-&gt;fakeResult类型的hash table，表示每个网页上的链接列表，并通过爬虫函数读取它们。为了演示go语言的并发，代码中实现了三种函数：Serial，ConcurrentMutex，ConcurrentChannel</p><p><strong>串行爬取</strong>。深度优先遍历（DFS ）全部网页构成的图结构，利用一个名为 fetched 的 set 来保存所有已经抓取过的 URL。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Serial</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">,</span> fetched <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  <span class="token punctuation">}</span>  fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>  urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>    <span class="token function">Serial</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> fetched<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">//。。。</span><span class="token function">Serial</span><span class="token punctuation">(</span><span class="token string">"http://golang.org/"</span><span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//。。。</span></code></pre><p>它的输入参数包括根域名url，fetcher（前面提到过的hash table），和一个bool数组fetched（用来记录哪些网站被访问过了）。注意163行这里有个神奇的用法make()，参考<a href="https://www.jianshu.com/p/f01841004810">Go内建函数make及切片slice、映射map详解</a>。serial函数本身比较简单，基本思路就是对fetcher中的每个域名，递归抓取它下面的链接（在fakeResult里面）。</p><p><strong>并行爬取</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> fetchState <span class="token keyword">struct</span> <span class="token punctuation">{</span>mu      sync<span class="token punctuation">.</span>Mutexfetched <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">,</span> f <span class="token operator">*</span>fetchState<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//之所以使用*就是为了所有的线程都使用shared memory</span>f<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>already <span class="token operator">:=</span> f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment">//这里两个线程可能对于同一个网页提取（不同的url中的引用，然后都得到了false</span>f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment">//所以放在一起执行，希望line43，44是原子操作</span>f<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> already <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">var</span> done sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>done<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        u2 <span class="token operator">:=</span> u<span class="token comment">//因为在一次循环之中用了u之后，传入的如果是地址，第二次循环的u会变化，但是其实我们并不期望这样的变化</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> done<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//避免有的函数调用失败，无论如何都要调用done</span><span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>u2<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//go func(u string) {//go中默认传输的不是地址，是一份u的copy，注释掉的代码实现了一样的效果</span><span class="token comment">//defer done.Done()</span><span class="token comment">//ConcurrentMutex(u, fetcher, f)</span><span class="token comment">//}(u)</span><span class="token punctuation">}</span>done<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><ol><li>将抓取部分使用 go 关键字变为并行。但如果仅这么改造，不利用某些手段（sync.WaitGroup）等待子 goroutine，而直接返回，那么可能只会抓取到种子 URL，同时造成子 goroutine 的泄露。</li><li>如果访问已经抓取的 URL 集合 fetched 不加锁，很可能造成多次拉取同一个网页。</li></ol><h3 id="WaitGroup-1"><a href="#WaitGroup-1" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> done sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>  done<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>u <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> done<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> f<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token comment">// u 被拷贝</span><span class="token punctuation">}</span>done<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>WaitGroup 内部维护了一个计数器：调用 <code>wg.Add(n)</code> 时候会增加 n；调用 <code>wait.Done()</code> 时候会减少 1。这时候调用 <code>wg.Wait()</code> 会一直阻塞直到当计数器变为 0 。所以 WaitGroup 很适合等待一组 goroutine 都结束的场景。</p><p><strong>Q&amp;A</strong></p><ol><li><p><em>如果 goroutine 异常退出没有调用 wg.Done () 怎么办</em>？可以使用 defer 将其写在 goroutine 开始：<code>defer wg.Done()</code></p></li><li><p><em>两个 goroutine 同时调用 wg.Done () 会有竞争（race），以至于内部计数器不能正确减少两次吗</em>？WaitGroup 应该有相应机制（锁什么的）来保证 Done () 的原子性。</p></li><li><p><em>定义匿名函数时，匿名函数中变量和外层函数同名变量间的关系</em>？这是个闭包（closure）问题。如果匿名函数中变量没有被参数覆盖（如上述代码中 <code>fetcher</code>），就会和外层同名变量<strong>引用</strong>同一个地址。如果通过传参传递（如上述代码中 <code>u</code>），哪怕参数和外层变量看起来一样，但匿名函数使用的也是传进来的参数，而非外层变量；尤其针对 for 循环变量，我们通常通过参数来将其在调用时拷贝一次，否则 for 循环启动的所有 goroutine 都会指向这个不断被 for 循环赋值改变的变量。</p><p><strong>对于闭包，go 中有个” 变量逃逸 “（Variable Escape）的说法，如果某个变量在函数声明周期结束时仍被引用，则将其分被到堆而非函数栈上。对闭包来说，某个变量同时被内层和外层函数引用，则其会被分配到堆上</strong>。</p></li><li><p><em>既然字符串 <code>u</code> 是不可变（immutable）的，为什么所有 goroutine 还会引用到不断变化的值</em>？string 的确是不可变的，但是 <code>u</code> 的值一直在变，而 goroutine 和外层 goroutine 共享 u 的引用。</p></li></ol><h3 id="去掉锁"><a href="#去掉锁" class="headerlink" title="去掉锁"></a>去掉锁</h3><p>如果在更新 map 的时候去掉锁，运行几次发现并没有什么异常，因为 race 其实很难检测。好在 go 提供了竞态分析工具帮你来找到潜在含有竞态的地方：<code>go run -race crawler.go</code></p><p>注意该工具没有做静态分析，而是在动态执行过程中观察、记录各个 goroutine 的执行轨迹，进行分析。</p><h3 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h3><p>Q&amp;A</p><p>\1. 该代码在整个运行中会同时多少线程在运行（goroutine）？<br>该代码并没有做明显的限制，但是其明显和 URL 数量、抓取时间正相关。例子中输入只有五个 URL，因此没有什么问题。但在现实中，这么做可能会同时启动上百万个 goroutine。因此一个改进是，实现启动一个固定数量的 worker 池子，每个 worker 干完后就去要 / 被分配下一个任务。</p><h3 id="使用-channel-通信"><a href="#使用-channel-通信" class="headerlink" title="使用 channel 通信"></a>使用 channel 通信</h3><p>我们可以实现一个新的爬虫版本，不用锁 + 共享变量，而用 go 中内置的语法：channel 来通信。具体做法类似实现一个生产者消费者模型，使用 channel 做消息队列。</p><ol><li>初始将种子 url 塞进 channel。</li><li>消费者：master 不断从 channel 中取出 urls，判断是否抓取过，然后启动新的 worker goroutine 去抓取。</li><li>生产者：worker goroutine 抓取到给定的<em>任务</em> url，并将解析出的<em>结果</em> urls 塞回 channel。</li><li>master 使用一个变量 n 来追踪发出的<em>任务</em>数；往发出一份<em>任务</em>增加一；从 channel 中获取并处理完一份<em>结果</em>（即将其再安排给 worker）减掉一；当所有任务都处理完时，退出程序。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>  urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    ch <span class="token operator">&lt;-</span> urls  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">master</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>  n <span class="token operator">:=</span> <span class="token number">1</span>  fetched <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> urls <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>      <span class="token keyword">if</span> fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>        fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>        n <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    n <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">ConcurrentChannel</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">master</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>Q&amp;A:</strong></p><ol><li><em>master 读 channel，多 worker 写 channel，不会有竞争问题吗</em>？channel 是线程安全的。</li><li><em>channel 不需要最后 close 吗</em>？我们用 n 追踪了所有执行中的任务数，因此当 n 为 0 退出时，channel 中不存在任何任务 / 结果，因此 master/worker 都不会对 channel 存在引用，稍后 gc collector 会将其回收。</li><li><em>为什么在 ConcurrentChannel 需要用 goroutine 往 channel 中写一个 url</em>？否则 master 在读取的时候会一直阻塞。并且 channel 是一个非缓冲 channel，如果不用 goroutine，将会永远阻塞在写的时候。</li></ol><p>参考：</p><p><a href="https://studygolang.com/">https://studygolang.com/</a></p><p><a href="https://www.qtmuniao.com/2020/02/29/6-824-video-notes-2/">https://www.qtmuniao.com/2020/02/29/6-824-video-notes-2/</a></p><p><a href="https://golangbot.com/buffered-channels-worker-pools/">https://golangbot.com/buffered-channels-worker-pools/</a></p><p>作者：<a href="https://golangbot.com/about/">Nick Coghlan</a> 译者：<a href="https://github.com/Noluye">Noluye</a> 校对：<a href="https://github.com/polaris1119">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/12512">Go语言中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 2022 notes 1 chinese version</title>
      <link href="/2022/02/16/mit-6-824-2022-notes-1-chinese-version/"/>
      <url>/2022/02/16/mit-6-824-2022-notes-1-chinese-version/</url>
      
        <content type="html"><![CDATA[<h1 id="chinese-version"><a href="#chinese-version" class="headerlink" title="chinese version"></a>chinese version</h1><h2 id="课程背景"><a href="#课程背景" class="headerlink" title="课程背景"></a>课程背景</h2><p>构建分布式系统的原因：</p><ol><li>Parallelism，资源并行（提高效率）。</li><li>Fault tolerance，容错。</li><li>Physical，系统内在的物理分散。</li><li>Security，不可信对端（区块链）。</li></ol><p>分布式系统面临的挑战：</p><ol><li>Concurrency，系统构件很多，并行繁杂，交互复杂。</li><li>Partial failure，存在部分失败，而不是像单机一样要么正常运行，要么完全宕机。</li><li>Performance，精巧设计才能获取与机器数量线性相关的性能。</li></ol><h2 id="课程组成"><a href="#课程组成" class="headerlink" title="课程组成"></a>课程组成</h2><ol><li>Lectures，授课，一些案例学习。</li><li>Papers，论文。<ul><li>包括一些经典的和前沿的、学术的和工业界的。</li><li>看其观点，学其实现，断其性能。</li><li>抓重要部分，略次要部分。</li><li>课程主页有所有论文链接。</li></ul></li><li>Exams，期中期末两次考试。</li><li>Labs：四个实验<ul><li>lab1： MapReduce</li><li>lab2： Raft 容错</li><li>lab3： K/V server use Raft</li><li>lab4： Shared K/V based on lab3<br>分布式系统巨难调试，做好心理准备，早点开做。</li></ul></li><li>Project，可以自选相关题目，组队完成，用来替代 lab4。</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>本课程旨在学习支撑应用的基础设施<strong>抽象</strong>（abstraction），包括</p><ol><li>Storage，存储，一个很直接并常用的抽象；如何构建多副本、容错、高性能分布式存储系统。</li><li>Communication，通信，如何可靠的通信。</li><li>Computation，现代的大规模计算，如 MapReduce</li></ol><p>最终理想是提供能够屏蔽分布式细节的、类似于单机的通用接口，同时能兼具<strong>容错</strong>和<strong>性能</strong>。</p><p>对于上述抽象，我们有哪些实现呢？</p><ol><li>RPC：像在本机调用一样跨节点通信</li><li>Concurrency，Threads：并发载体</li><li>Concurrency，Lock：并发控制。</li></ol><h3 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance 性能"></a>Performance 性能</h3><p>scalability，可扩展性</p><ul><li>可以线性的集结计算机资源：使用两倍的机器获取两倍的吞吐。</li><li>意味着遇到瓶颈你只需要花少量的钱买机器，而不用付很多的工资找程序员重构。</li><li>但这个特点很难实现。通常你将一个组件扩展后，瓶颈就转移到了另一个组件，全组件的无限扩展很难。</li></ul><h3 id="Fault-Tolerance-容错"><a href="#Fault-Tolerance-容错" class="headerlink" title="Fault Tolerance 容错"></a>Fault Tolerance 容错</h3><p>单机虽好，作为上千台机器组成的集群来说，故障却是常态。比如说：</p><ul><li>主机宕机</li><li>网络抖动</li><li>交换机故障</li></ul><p>Availability 可用性<br>Recoverbility 可恢复性，无干预 、不影响正确性的可恢复</p><p>手段：<br>NV storage：持久化<br>Replication：多副本</p><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>分布式系统产生不一致的因素：</p><ol><li>缓存</li><li>多副本</li></ol><p>不同程度的一致性：</p><ol><li>强一致性：每个客户端每次都能读到（自己 or 他人）之前所写数据。在多副本系统实现强一致性代价十分高昂，需要进行大量的通信。简单说两种方法：<ul><li>每次更改同时写到所有副本</li><li>每次读取都去读所有副本，使用具有最新时间戳的数据。</li></ul></li><li>弱一致性，为了性能，工业级系统通常选择弱一致性。</li></ol><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Google （2003 年左右）面对巨量（数十 T）的索引数据和全网结构的数据，需要找到最重要的网页。可以简化为一个排序问题，但如此数量级的排序，单机不是一个可选项。而又不是所有工程师都有手撸分布式系统的能力，因此产生了做一个分布式框架的需求，以对应用程序员屏蔽分布式环境细节：</p><ol><li>如何将工作高效分配到上千台机器上。</li><li>如何控制数据流动。</li><li>如何进行容错。</li></ol><p>等等。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以 WordCount 为例：</p><p><strong>Map</strong>: document -&gt; (word, 1)</p><p><strong>Shuffle</strong>：group by word in Map machine，send each key Range to the corresponding Reduce Machine。</p><p><strong>Reduce</strong>: List(word, 1) -&gt; (word, count)</p><h3 id="术语体系"><a href="#术语体系" class="headerlink" title="术语体系"></a>术语体系</h3><p><strong>任务</strong>：Job</p><p><strong>工作</strong>：Task，分为 Map Task 和 Reduce Task。</p><p><strong>工作节点</strong>：worker server</p><p><strong>工作进程</strong>：worker process</p><p><strong>主节点</strong>：master server</p><h3 id="存储配合"><a href="#存储配合" class="headerlink" title="存储配合"></a>存储配合</h3><p>为了更好的并行读写，需要一个网络文件系统来配合输入和输出，这就是 GFS（谷歌文件系统）。</p><p>GFS 可以简单理解为，一个将大文件拆为一个个小的 64M 的块分散到不同机器上网络文件系统。</p><h3 id="网络开销"><a href="#网络开销" class="headerlink" title="网络开销"></a>网络开销</h3><p>为了尽量绕开当时的主要瓶颈（网络传输），Google 做了一系列优化，包括 GFS 和 MR 跑在一个集群上，以减少读取和写入数据的网络传输。具体做法是让 Map 任务（Map Task）去找数据（Block）—— 将 Task 调度到其输入所在的机器上。但对于 Reduce 任务，无论如何都会存在大量网络开销：GFS 对数据都进行了冗余备份，意味着每个结果都要写多次。</p><p>不过，时下的数据中心可以通过很多手段使得网络传输的速度大大提高，比如使用多个根路由器进行分摊流量，意味着在设计时可以有更多灵活性，不用太为网络传输而优化。</p><p><em>中文版作者：木鸟杂记 <a href="https://www.qtmuniao.com/2020/02/29/6-824-video-notes-1/">https://www.qtmuniao.com/2020/02/29/6-824-video-notes-1/</a>, 转载请注明出处</em></p><p><strong>群号为：813098424 入群条件为独立完成第一个lab Map&amp;Reduce</strong> 实际上，第一个lab的难度并不大，可以说是热身性质的lab。入群请给出完成该lab的对应的repo的网址，管理员会审核是否满足条件。<strong>入群之后，请立刻将repo设置为private，避免影响其他学习这门课程的同学。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GFS chinese version</title>
      <link href="/2022/02/15/gfs-chinese-version/"/>
      <url>/2022/02/15/gfs-chinese-version/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Google-File-System中文版"><a href="#The-Google-File-System中文版" class="headerlink" title="The Google File System中文版"></a>The Google File System中文版</h1><p>2020-04-18 | <a href="https://chunlife.top/categories/%E8%AE%BA%E6%96%87/">论文</a></p><p>The Google File System</p><blockquote><h2 id="GFS-MapReduce-BigTable关系"><a href="#GFS-MapReduce-BigTable关系" class="headerlink" title="GFS MapReduce BigTable关系"></a>GFS MapReduce BigTable关系</h2><p>GFS（2003年发表）使用商用硬件集群存储海量数据。文件系统将数据在节点之间冗余复制。MapReduce（2004）是GFS架构的一个补充，因为它能够充分利用GFS集群中所有低价服务器提供的大量CPU。它与GFS一道形成了处理海量数据的核心力量，包括构建Google的搜索索引。不过这两个系统都缺乏实时随机存取数据的能力，意味着尚不足以处理Web服务。</p><p>GFS的另一个缺陷就是，它适合存储少许非常非常大的文件，而不适合存储成千数万的小文件，例如社交平台上的图片，因为文件的无数据信息最终要存储在主节点的内存中，文件越多master的压力越大。</p><p>这时候需要一个能够驱动交互应用的解决方案，且能够同时利用以上两种基础架构和依靠GFS 存储的数据冗余和数据可用性较强的特点。存储的数据应该拆分成特别小的条目，然后由系统将这些小记录聚合到非常大的文件中，并提供一些索引排序，让用户可以查找最少的磁盘就能够获取到数据。最终，它要能够及时存储爬虫的结果，并跟MapReduce协作生成搜索索引。于是考虑放弃关系型的特点，采用简单的API来进行增删改查操作，另加一个扫描函数，以在较大的键范围或全表上迭代扫描，最终形成一个管理结构化数据的分布式存储系统BigTable（2006）。</p><p>值得一提的是CAP定理，当中指出，一个分布式系统只能同时实现一致性、可用性和分区容忍性（独立性）中的两个，不可能三者兼顾。放宽一致性的要求会提升系统的可用性。</p></blockquote><p>[GFS中文版](GFS-chinese-version/The Google File System中文版.pdf)</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 2022 notes 1</title>
      <link href="/2022/02/14/mit-6-824-2022-notes-1/"/>
      <url>/2022/02/14/mit-6-824-2022-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lecture-1-Introduction"><a href="#Lecture-1-Introduction" class="headerlink" title="Lecture 1: Introduction"></a>Lecture 1: Introduction</h1><h2 id="why-do-we-use-distributed-systems"><a href="#why-do-we-use-distributed-systems" class="headerlink" title="why do we use distributed systems?"></a>why do we use distributed systems?</h2><ol><li>connect physically seperated machines<ul><li>Usually shared </li></ul></li><li>increase capacity through parallelism</li><li>tolerate faults</li><li>achieve security/via isolate</li></ol><h2 id="What-are-the-challenges"><a href="#What-are-the-challenges" class="headerlink" title="What are the challenges?"></a>What are the challenges?</h2><ol><li>Concurrency</li><li>Partial failure</li><li>High performance</li></ol><h2 id="Infrastructure-Abstractions"><a href="#Infrastructure-Abstractions" class="headerlink" title="Infrastructure Abstractions"></a>Infrastructure Abstractions</h2><ul><li>storage </li><li><strong>communication</strong></li><li>Computation </li></ul><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>RPC, threads, concurrency lock.</p><h2 id="performace"><a href="#performace" class="headerlink" title="performace"></a>performace</h2><p>Scalability </p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><ul><li>Availability </li><li>Recoverbility </li></ul><p>Solutions：</p><ul><li>NV storage(non-volatile storage)非易失性存储</li><li>Replication: management of replication copies, </li></ul><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>puts and gets for k-v store</p><h3 id="reasons-for-non-consistency"><a href="#reasons-for-non-consistency" class="headerlink" title="reasons for non-consistency"></a>reasons for non-consistency</h3><ul><li>cache </li><li>Replication </li></ul><h3 id="kinds"><a href="#kinds" class="headerlink" title="kinds"></a>kinds</h3><ul><li>Strong<ul><li>expensive to implement<ul><li>Communication </li></ul></li></ul></li><li><strong>weak</strong> <ul><li>Real world</li></ul></li></ul><h2 id="Mapreduce"><a href="#Mapreduce" class="headerlink" title="Mapreduce"></a>Mapreduce</h2><blockquote><p><strong>MapReduce</strong> is a <a href="https://en.wikipedia.org/wiki/Programming_model">programming model</a> and an associated implementation for processing and generating <a href="https://en.wikipedia.org/wiki/Big_data">big data</a> sets with a <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallel</a>, <a href="https://en.wikipedia.org/wiki/Distributed_computing">distributed</a> algorithm on a <a href="https://en.wikipedia.org/wiki/Cluster_(computing)">cluster</a>.</p><p>A MapReduce program is composed of a <a href="https://en.wikipedia.org/wiki/Map_(parallel_pattern)"><em>map</em></a> <a href="https://en.wikipedia.org/wiki/Procedure_(computing)">procedure</a>, which performs filtering and sorting (such as sorting students by first name into queues, one queue for each name), and a <em><a href="https://en.wikipedia.org/wiki/Reduce_(parallel_pattern)">reduce</a></em> method, which performs a summary operation (such as counting the number of students in each queue, yielding name frequencies). The “MapReduce System” (also called “infrastructure” or “framework”) orchestrates the processing by <a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">marshalling</a> the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, and providing for <a href="https://en.wikipedia.org/wiki/Redundancy_(engineering)">redundancy</a> and <a href="https://en.wikipedia.org/wiki/Fault-tolerant_computer_system">fault tolerance</a>.</p><p>——Wiki</p></blockquote><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><p>Map(k, v): k-the name of the file, v-the content of the maps inout file(full text).</p><p>Reduce(k, v): k-the word, v-value to be summaryed(count or frequency).</p><p>Master server: organize the whole computation</p><p>worker server: computation work</p><h3 id="Working-process"><a href="#Working-process" class="headerlink" title="Working process"></a>Working process</h3><p>If we want to run a MapReduce job that takes the entire crawled web as input the data is already stored in a way that split up evenly across all the file servers(a web file) and so that means that the map workers are able to read the data in parallel from these file servers. </p><blockquote><p><strong>Does Google have one set of physical machines among GFS and a separate set of physical machines that run MapReduce jobs?</strong></p><p><strong>No.</strong> (just for 2004)</p><p>In general case if we have big files stored in some big Network file system like  GFS. MapReduce worker process has to go off and talk across the network to the correct GFS server and maybe servers that store the data are part of the input and fetch servers spread data over the network to pass the map to the MapReduce worker machine. </p><p><strong>In this case we need massive network throughput capacity.</strong></p><p>If you just pick some MapReduce worker and some GFS servers, <strong>chances are at least half the time the communication between them has to pass through</strong>. This one wouldn’t switch their routes which had only some amount of total throughput.</p><p><strong>Usually we run the GFS servers and the MapReduce workers on the same set of machines.</strong> Possibly we have a thousand machines running the service.  </p><p>Now network is much faster and we can collect and process data from anywhere.</p></blockquote><p>GFS splits a big file into 64M pieces and process them on single physical machines, finally the MapReduce framework would gather them up and write them into giant files in GFS via network.(needs massive network throughput)</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式学习资料</title>
      <link href="/2022/02/14/fen-bu-shi-xue-xi-zi-liao/"/>
      <url>/2022/02/14/fen-bu-shi-xue-xi-zi-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>时下，随着通信技术的发展、移动互联网的普及、物联网车联网人工智能的兴起，每天所产生的数据呈爆炸性的增长。这种尺度的数据不是传统单机系统可以独立处理的，而只能借助于大规模的分布式系统，因而分布式系统渐渐的变成一门 “显学”。而作为一个分布式系统初学者，面对网上未加归类、浩如烟海的学习资料，很容易两眼抓瞎。</p><p>但分布式系统有其基本研究内容和独特发展脉络，比如：</p><ol><li>一些基本研究问题：时序问题、一致性问题、容错技术、共识算法、并发控制等等。</li><li>一些基本定理：CAP、PACELC、FLP</li><li>渐次发展的工业系统：MapReduce、Spark、GFS、Dynamo、Cosmos</li></ol><p>因此只需要在 “时空” 两个维度对分布式系统进行把握，就能提纲挈领，愈学愈明。“<strong>时</strong>” 表示分布式系统的演进脉络，可以通过阅读不同时期、学术界工业界的一些论文来把握。“<strong>空</strong>” 表示分布式系统中所研究的基本问题的拆解，可以通过阅读一些书籍建立分布式系统的知识体系。本文将我在学习分布式系统知识过程搜集到的一些资料，按类别简单汇总，以飨诸君。资料排名没有先后，请按需采用。</p><p><strong>注：</strong>文中推荐的资料大多为英文，如果阅读有困难，推荐使用 Chrome 浏览器，并且给 Chrome 装一个 “<a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb">google 翻译</a>” 的插件，可以点击一键 “翻译此页面”。</p><p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/2021/05/16/distributed-system-material/">https://www.qtmuniao.com/2021/05/16/distributed-system-material/</a>, 转载请注明出处</em></p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Dr-Martin-Kleppmann-Designing-Data-Intensive-Applications"><a href="#Dr-Martin-Kleppmann-Designing-Data-Intensive-Applications" class="headerlink" title="Dr. Martin Kleppmann. Designing Data-Intensive Applications"></a>Dr. Martin Kleppmann. Designing Data-Intensive Applications</h3><p>《构建数据密集型应用》，<a href="https://dataintensive.net/buy.html%EF%BC%8C%E4%BD%9C%E8%80%85%E6%8F%90%E4%BE%9B%E5%85%8D%E8%B4%B9%E8%8B%B1%E6%96%87%E7%89%88%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%BD%91%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E5%88%B0%E3%80%82">https://dataintensive.net/buy.html，作者提供免费英文版下载，网上也可以搜到。</a></p><p>全书分为三大部分：</p><ol><li>系统基石（Foundations of Data System）</li><li>分散数据（Distributed Data）</li><li>衍生数据（Derived Data）</li></ol><p><strong>系统基石</strong>部分探讨了数据系统的一些通用侧面：</p><ol><li>可靠性、可扩展性、可维护性（Reliable, Scalable, and Maintainable Applications）</li><li>数据模型和查询语言（Data Models and Query Languages）</li><li>数据存储和检索（Storage and Retrieval）</li><li>数据编码和演进（Encoding and Evolution）</li></ol><p><strong>分散数据</strong>部分讨论了构建分散在多机上的数据系统和一些原则和面临的问题：</p><ol><li>冗余（replication）</li><li>分片（Partition）</li><li>事务（Transactions）</li><li>分布式系统存在的问题（The Trouble With Distributed Systems）</li><li>一致性和共识（Consistency and Consensus）</li></ol><p><strong>衍生数据</strong>部分其实是在探讨分散在多机上的系统的处理问题。包括：</p><ol><li>批处理（Batch Processing）</li><li>流式处理（Stream Processing）</li><li>数据系统的未来（The Future of Data Systems）</li></ol><p>近年来流批系统趋于融合，从而让用户能够更加灵活、高效的对原始数据进行处理和变换。</p><p>这些章节拆分的都非常棒。熟读本书，让你在遇到一个新系统时，可以如庖丁解牛一般熟练拆解成为多个构件，并了每个构件背后的权衡取舍（trade off）。</p><h3 id="M-van-Steen-and-A-S-Tanenbaum-Distributed-Systems-3rd-ed-distributed-systems-net-2017"><a href="#M-van-Steen-and-A-S-Tanenbaum-Distributed-Systems-3rd-ed-distributed-systems-net-2017" class="headerlink" title="M. van Steen and A.S. Tanenbaum, Distributed Systems, 3rd ed., distributed-systems.net, 2017."></a>M. van Steen and A.S. Tanenbaum, Distributed Systems, 3rd ed., <a href="http://distributed-systems.net/">distributed-systems.net</a>, 2017.</h3><p>《分布式系统》第三版，<a href="https://www.distributed-systems.net/index.php/books/ds3/%E3%80%82%E4%BD%9C%E8%80%85%E6%8F%90%E4%BE%9B%E8%8B%B1%E6%96%87%E7%89%88">https://www.distributed-systems.net/index.php/books/ds3/。作者提供英文版</a> PDF 免费下载链接，简介：</p><p>本书分为九个小结：</p><ul><li>简介（Introduction）</li><li>架构（Architecture）</li><li>进程（Processes）</li><li>通信（Communication）</li><li>命名系统（Naming）</li><li>协同（Coordination）</li><li>一致性和多副本（Consistency and replication）</li><li>容错（Fault Tolerance）</li><li>安全（Security）</li></ul><p>作者还提供了 Python 示例代码和图表下载。</p><h3 id="Mikito-Takada-Distributed-System-for-fun-and-profit"><a href="#Mikito-Takada-Distributed-System-for-fun-and-profit" class="headerlink" title="Mikito Takada. Distributed System for fun and profit"></a>Mikito Takada. Distributed System for fun and profit</h3><p>一本免费的分布式系统小书：<a href="http://book.mixu.net/distsys/%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%BE%E8%AE%A1%E8%80%83%E9%87%8F%EF%BC%8C%E5%8A%A9%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9F%A5%E5%90%8D%E7%9A%84%E5%95%86%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%A6%82">http://book.mixu.net/distsys/，介绍了分布式系统中的一些关键概念和设计考量，助你了解知名的商用系统如</a> Dynamo、BigTable、MapReduce、Hadoop 背后的设计原理。作者将分布式编程的考量归结为两个方面：</p><ol><li>信息以光速传递</li><li>分离组件会独立出错</li></ol><p>然后将全书分为五个小结：</p><ol><li><strong>分布式系统基础（Basics）</strong>：粗粒度的介绍了一些名词和概念，探讨了系统的目标以及实现的难度</li><li><strong>自上而下的层层抽象（Up and down the level of abstraction）</strong>：介绍了 CAP 定理和 FLP impossibility ，然后探讨了多种一致性模型。</li><li><strong>时与序（time and order</strong>）。理解分布系统的关键之一，便是要理解分散的组件如何确定时间的先后顺序。</li><li><strong>多副本：避免分裂（Replication: preventing divergence）</strong>：多副本间如何保持一致</li><li><strong>多副本：接受分歧（Replication: accepting divergence）</strong>：多副本间如何处理冲突</li></ol><h2 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h2><h3 id="MIT-6-824-Distributed-Systems"><a href="#MIT-6-824-Distributed-Systems" class="headerlink" title="MIT 6.824: Distributed Systems"></a>MIT 6.824: Distributed Systems</h3><p>最经典的分布式系统课程之一：<a href="https://pdos.csail.mit.edu/6.824/schedule.html%E3%80%82">https://pdos.csail.mit.edu/6.824/schedule.html。</a></p><p>课程亮点在于：</p><ol><li>精选的论文列表</li><li>精巧的实验设计</li></ol><p>非常适合自学。</p><h3 id="Cambridge-Concurrent-and-Distributed-Systems"><a href="#Cambridge-Concurrent-and-Distributed-Systems" class="headerlink" title="Cambridge Concurrent and Distributed Systems"></a>Cambridge Concurrent and Distributed Systems</h3><p>剑桥大学的并发和分布式课程， <a href="https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/materials.html">https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/materials.html</a></p><p>DDIA 作者 Martin Kleppmann 主讲。</p><h3 id="CMU-15-440-Distributed-Systems"><a href="#CMU-15-440-Distributed-Systems" class="headerlink" title="CMU 15-440: Distributed Systems"></a>CMU 15-440: Distributed Systems</h3><p>cmu 的分布式系统：<a href="https://www.cs.cmu.edu/~dga/15-440/S14/syllabus.html%E3%80%82">https://www.cs.cmu.edu/~dga/15-440/S14/syllabus.html。</a></p><h3 id="standford-cs244b-Distributed-System"><a href="#standford-cs244b-Distributed-System" class="headerlink" title="standford cs244b Distributed System"></a>standford cs244b Distributed System</h3><p>斯坦福的分布式系统课程：<a href="http://www.scs.stanford.edu/20sp-cs244b/">http://www.scs.stanford.edu/20sp-cs244b/</a></p><p>CS244b 是一个讨论课，也给了一些经典的论文列表。</p><h3 id="UW-CSE490H-Distributed-Systems"><a href="#UW-CSE490H-Distributed-Systems" class="headerlink" title="UW CSE490H: Distributed Systems"></a>UW CSE490H: Distributed Systems</h3><p>华盛顿大学的分布式系统课程：<a href="https://courses.cs.washington.edu/courses/cse490h/11wi/%E3%80%82%E6%9C%80%E8%BF%91%E5%87%A0%E5%B9%B4%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%B2%A1%E6%9C%89%E5%BC%80%E8%BF%98%E6%98%AF%E6%B2%A1%E6%9C%89%E5%85%AC%E5%BC%80%EF%BC%8C%E6%9C%80%E8%BF%91%E7%9A%84%E6%98%AF">https://courses.cs.washington.edu/courses/cse490h/11wi/。最近几年的课程没有开还是没有公开，最近的是</a> 2011 年的。也提供了一个不错的论文阅读列表。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol><li>Hadoop， <a href="https://github.com/apache/hadoop">https://github.com/apache/hadoop</a> ，Java：可以通过 tag 看早期代码，包含 MapReduce 和 GFS 的开源实现</li><li>seaweedfs ，<a href="https://github.com/chrislusf/seaweedfs%EF%BC%8C">https://github.com/chrislusf/seaweedfs，</a> Golang：参考了 Facebook Haystack 和 F4</li><li>Minio，<a href="https://github.com/minio/minio%EF%BC%8C">https://github.com/minio/minio，</a> Golang：一个经典的开源实现的对象存储</li><li>TiDB，<a href="https://github.com/pingcap/tidb%EF%BC%8CGolang%EF%BC%8C%E6%8F%90%E4%BE%9B">https://github.com/pingcap/tidb，Golang，提供</a> MySql 访问接口的分布式数据库</li></ol><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><ol><li>Etcd，<a href="https://github.com/etcd-io/etcd%EF%BC%8CGolang%EF%BC%9ARaft">https://github.com/etcd-io/etcd，Golang：Raft</a> 的一个实现，用于 k8s 中。也可以用于任何分布式系统的控制面的数据存储。</li><li>Zookeeper，<a href="https://github.com/apache/zookeeper%EF%BC%8CJava%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BA%86">https://github.com/apache/zookeeper，Java：实现了</a> Zab 共识协议，最初用于 Hadoop 中存储元信息，地位和 Etcd 类似。</li></ol><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ol><li>Spark，<a href="https://github.com/apache/spark%EF%BC%8CScala%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E3%80%81%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E">https://github.com/apache/spark，Scala：一个大数据处理、分析引擎</a></li><li>Flink，<a href="https://github.com/apache/flink%EF%BC%8CJava%EF%BC%9A%E6%B5%81%E6%89%B9%E4%B8%80%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E">https://github.com/apache/flink，Java：流批一体的数据处理引擎</a></li><li>Ray，<a href="https://github.com/ray-project/ray%EF%BC%8CPython/C++%EF%BC%9A%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B%E5%BC%BA%E5%A4%A7%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E">https://github.com/ray-project/ray，Python/C++：表达能力强大的通用计算引擎</a></li></ol><h2 id="系列博客"><a href="#系列博客" class="headerlink" title="系列博客"></a>系列博客</h2><h3 id="写给分布式系统初学者的一些笔记"><a href="#写给分布式系统初学者的一些笔记" class="headerlink" title="写给分布式系统初学者的一些笔记"></a>写给分布式系统初学者的一些笔记</h3><p>Jeff Hodges <a href="https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/</a></p><p>博主将从事分布式系统工作所得到的经验教训做了一个概要性的总结，对新人进入分布式领域转换思想很有启发性作用。包括：</p><ol><li>故障频发是分布式系统区别于其他系统的显著特点</li><li>构建健壮的分布式系统要远难于单机系统</li><li>分布式系统的开源协作不同于单机系统</li><li>多机协同很难</li><li>很慢这个事情在分布式系统中很难定位</li><li>寻找使服务部分可用的手段</li><li>充分利用局部性原理</li><li>使用 CAP 原理来审视你的分布式系统</li><li>…</li></ol><h3 id="给分布式系统工程师的一些分布式理论"><a href="#给分布式系统工程师的一些分布式理论" class="headerlink" title="给分布式系统工程师的一些分布式理论"></a>给分布式系统工程师的一些分布式理论</h3><p><a href="https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/">https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/</a></p><p>博主给出了分布式系统的一个入门路径和参考资料：</p><ol><li><strong>第一步（First steps）：</strong>推荐了一些书</li><li><strong>故障和时序（Failure and Time）</strong>：分布系统中最重要的两个基石，给出了一些经典论文引用</li><li><strong>容错的基本考量（The basic tension of fault tolerance）</strong>：要做冗余以容错，但过分冗余又会浪费性能</li><li><strong>基本源语（Basic primitives）</strong>：分布系统中的一些基本概念论文链接，包括选举算法、一致性快照、共识协议、分布式状态机、广播、链式冗余。</li><li><strong>一些工业系统论文列表</strong>：谷歌的居多，非谷歌的也有一些</li></ol><h2 id="Meetup"><a href="#Meetup" class="headerlink" title="Meetup"></a>Meetup</h2><h3 id="Papers-we-love"><a href="#Papers-we-love" class="headerlink" title="Papers we love"></a>Papers we love</h3><p>PapersWeLove 计算机论文分享： <a href="https://www.zhihu.com/column/c_1353678180390162432">https://www.zhihu.com/column/c_1353678180390162432</a></p><h3 id="Microsoft-Distributed-System-Meetup"><a href="#Microsoft-Distributed-System-Meetup" class="headerlink" title="Microsoft-Distributed-System-Meetup"></a>Microsoft-Distributed-System-Meetup</h3><p>微软同学搞的一个分布式系统 meetup，包括 一块学 6.824、一块读 DDIA、有意思的主题演讲等等：<a href="https://microsoft-distributed-system-meetup.github.io/home/">https://microsoft-distributed-system-meetup.github.io/home/</a></p><h3 id="Distributed-Systems-Reading-Group"><a href="#Distributed-Systems-Reading-Group" class="headerlink" title="Distributed Systems Reading Group"></a>Distributed Systems Reading Group</h3><p>MIT 同学在 2013 年搞的一个论文阅读小组：<a href="http://dsrg.pdos.csail.mit.edu/papers/">http://dsrg.pdos.csail.mit.edu/papers/</a></p><p>包括共识协议、数据冗余、事务相关、并发问题等等。</p><h3 id="计算机系统学习小组"><a href="#计算机系统学习小组" class="headerlink" title="计算机系统学习小组"></a><strong>计算机系统学习小组</strong></h3><p>@<a href="https://www.zhihu.com/people/hu-jin-ming-31">胡津铭</a> 组织的系统学习小组：<a href="https://learn-sys.github.io/cn/">https://learn-sys.github.io/cn/</a></p><h3 id="The-Last-Thing"><a href="#The-Last-Thing" class="headerlink" title="The Last Thing"></a>The Last Thing</h3><p>最后，附赠一个 github 上经典的 awesome 系列中，分布式系统的 repo：<a href="https://github.com/theanalyst/awesome-distributed-systems">https://github.com/theanalyst/awesome-distributed-systems</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anna论文笔记</title>
      <link href="/2022/02/10/anna-lun-wen-bi-ji/"/>
      <url>/2022/02/10/anna-lun-wen-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记"><a href="#Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记" class="headerlink" title="Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记"></a>Anna（支持任意扩展和超高性能的KV数据库系统）阅读笔记</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初略看了一眼Paper，似乎很是牛X。说是支持任意规模的扩展，并且性能不低于 <a href="https://github.com/fastio/pedis">pedis</a>。于是抽空来看看并了解下这套系统的设计特点和这种夸张的单机性能和扩展性的来源。</p><h1 id="主流分布式KVS的比较"><a href="#主流分布式KVS的比较" class="headerlink" title="主流分布式KVS的比较"></a>主流分布式KVS的比较</h1><table><thead><tr><th>系统名词</th><th>扩容设计</th><th>内存模型</th><th>针对单个Key的一致性策略</th><th>针对多个Key一致性策略</th></tr></thead><tbody><tr><td>Masstree</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Bw-tree</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>PALM</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>MICA</td><td>多核</td><td>共享内存</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Redis</td><td>单核</td><td>N/A</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a></td></tr><tr><td>COPS, Bolt-on</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a></td></tr><tr><td>Bayou</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, 单调读/写, <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td></tr><tr><td>Dynamo</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Cassandra</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>PNUTS</td><td>分布式</td><td>消息队列</td><td>线性写, 单调读</td><td>无</td></tr><tr><td>CouchDB</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Voldemort</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>HBase</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Riak</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>DocumentDB</td><td>分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, <a href="https://www.allthingsdistributed.com/2007/12/eventually_consistent.html"><strong>Session</strong></a>, <a href="http://pbs.cs.berkeley.edu/"><strong>Bounded Staleness</strong></a>, <a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>Memcached</td><td>多核&amp;分布式</td><td>共享内存&amp;消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>MongoDB</td><td>多核&amp;分布式</td><td>共享内存&amp;消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td>无</td></tr><tr><td>H-Store</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a></td><td><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a></td></tr><tr><td>ScyllaDB</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a></td><td>无</td></tr><tr><td>Anna</td><td>多核&amp;分布式</td><td>消息队列</td><td><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a>, Item Cut, Writes Follow Reads, 单调读/写, <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a>, <a href="https://en.wikipedia.org/wiki/PRAM_consistency"><strong>PRAM</strong></a></td><td><a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a>, <a href="https://jepsen.io/consistency/models/read-uncommitted"><strong>Read Uncommitted</strong></a></td></tr></tbody></table><blockquote><p>一致性说明:</p><ul><li><a href="https://en.wikipedia.org/wiki/Linearizability"><strong>线性(Linearizable)</strong></a> 是指在更新了某行之后，后续的客户端不会读到老数据，通常用在单行一致性上，最强的一致性模型；</li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性(Eventual)</strong></a> 是指在更新了某行之后，后续的客户端可能在某些（缓存）结点上会读到老数据（特别是并发执行的事务），但是最后（一段时间后）一定会读到一致的最新数据；</li><li><a href="https://en.wikipedia.org/wiki/Serializability"><strong>串行化(Serializable)</strong></a> 是指对多个读写同一行数据的事务，采用排序和排队执行的机制，这样也能保证数据的严格一致性，但是通常这涉及加锁（<a href="https://ai.google/research/pubs/pub39966">spanner</a>/<a href="https://ai.google/research/pubs/pub41344">f1</a>）或单点原子化操作（<a href="https://redis.io/">redis</a>）；</li><li><strong>单调读(Monotonic Reads)</strong> 是指在某一个客户端读取到新数据后，不会再读到老数据，但是有可能在更新一行后短期内客户端仍然读到老数据，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><strong>单调写(Monotonic Writes)</strong> 是指对单个客户端的写入操作一定是有序的，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a> 是指在某个客户端上对一组Key的读写操作会被认为有因果关系，那么在进程上也都保持一样的可见性顺序，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种。通常通过 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 实现；</li><li><a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 是指当一个数据行被更新后，这个进程后面的读操作一定会读到这个新值。通常如果数据库系统有 <strong>N个副本节点</strong> ， <strong>W个节点感知到写入</strong> ， <strong>R个节点对读操作返回的数据一致</strong> ， 且如果 <strong>W + R &gt; N</strong> ， 那么我们认为当前系统符合 <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 一致性，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="https://www.allthingsdistributed.com/2007/12/eventually_consistent.html"><strong>Session</strong></a> 是<a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a>的一种更具体的行为，即每一次客户端连接到服务器的Session中保证 <a href="http://www.dbms2.com/2010/05/01/ryw-read-your-writes-consistency/"><strong>Read Your Writes</strong></a> 一致性，如果重新建立Session则不保证，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><a href="http://pbs.cs.berkeley.edu/"><strong>Bounded Staleness</strong></a> 是指读取操作最多滞后于写入操作最多k个版本或t个周期之后，属于 <a href="https://en.wikipedia.org/wiki/Eventual_consistency"><strong>最终一致性</strong></a> 的一种；</li><li><strong>Writes follows reads</strong> 是指对一个Key的读操作后一定跟着这个Key的写操作；</li><li><a href="https://en.wikipedia.org/wiki/PRAM_consistency"><strong>PRAM</strong></a> 是指对于某个进程对多个Key的写入，其他进程看到的写入顺序和这个写入进程的写入顺序一致。因为这些Key在这个写入进程上是同一个pipeline；</li><li><a href="https://jepsen.io/consistency/models/read-uncommitted"><strong>Read Uncommitted</strong></a> 是指对同一组事务禁止 <em><strong>脏写</strong></em> ，即多个未提交事务同时修改一组数据；</li><li><a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a> 是指事务读取数据时，不允许看到其他未提交事务所写入的数据，通常涉及多个事务并发执行且需要访问同一组数据；</li></ul><p>See <a href="https://en.wikipedia.org/wiki/Consistency_model">https://en.wikipedia.org/wiki/Consistency_model</a> for more details</p></blockquote><h1 id="Anna-架构设计"><a href="#Anna-架构设计" class="headerlink" title="Anna 架构设计"></a><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 架构设计</h1><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 整体上依赖 <a href="https://en.wikipedia.org/wiki/Semilattice"><strong>bounded join semilattice</strong></a> (文中简称 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> ) 的核心设计，也就是代数结构中讲的格。</p><p>数学上 <a href="https://en.wikipedia.org/wiki/Semilattice">Semilattice</a> 符合 <strong>ACI</strong> 特性：</p><ul><li><p>交换律（Commutativity）: $\sqcup (a, b) = \sqcup (b, a), \forall_{a,b} \in S⊔(a,b)=⊔(b,a),∀a,b∈S $，即操作和顺序无关</p></li><li><p>结合律（Associativity）:$$ \sqcup (\sqcup (a, b), c) = \sqcup (a, \sqcup (b, c)), \forall_{a,b,c} \in S⊔(⊔(a,b),c)=⊔(a,⊔(b,c)),∀a,b,c∈S$$ ，即操作和先后次序无关</p></li><li><p>幂等性（Idempotence）: $\sqcup (a, a) = a, \forall_{a} \in S⊔(a,a)=a,∀a∈S$ ，即操作多次不影响结果</p></li><li><p><strong>join-semilattice</strong> : join操作 $\sqcup (a, b)⊔(a,b) $指a,b的最小上界。</p><blockquote><p>这里是数学定义，我的理解在 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 中指数据合并操作。</p></blockquote></li><li><p><strong>bounded</strong> : 指存在特定元素 <strong>1</strong>，使得 $\sqcup (a, 1) = a , \forall_{a,1} \in S⊔(a,1)=a,∀a,1∈S$</p></li></ul><p>详见维基百科: <a href="https://en.wikipedia.org/wiki/Semilattice">https://en.wikipedia.org/wiki/Semilattice</a></p><p>我的理解就是一个比较细粒度的模块化数据块，互相之间没有强交互和关联，大多数情况下仅处理自己的数据集。然后对于数据合并的操作，要设计成符合上面的 <strong>ACI</strong> 特性。</p><p>在 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的基础上，很容易就可以设计出适合这种场景的分布式状态模型和通信模型。</p><p>整个架构使用了actor模型。和 <a href="https://github.com/scylladb/seastar">seastar</a> 框架相似，系统采用多线程结构，并且按CPU核心数分配线程。并且和 golang 的核心思想一样，用 <strong>Message-passing</strong> 来 <strong>shared-memory</strong> 。 这样虽然是多线程，但是每个线程跑自己的 <strong>Actor Core</strong> ，在业务处理的时候互相之间几乎不需要互相通信。每个actor线程由自己的数据变更集(<strong>changeset</strong>)，然后定期访问广播通道执行集群管理或者是合并操作。</p><p><img src="/2022/02/10/anna-lun-wen-bi-ji/1905-01.png" alt="1905-01.png"></p><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的key和节点的分布也是一致性哈希。采用 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 算法来处理actor的容灾和扩缩容。按文中的意思似乎数据分片的同步也采用的是 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 。不过在这一点上 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> 对分布式系统的局部分片扩容天生是比 <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a> 和 <a href="https://raft.github.io/">Raft</a> 要好很多。</p><p>另外在 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的actor中，记录了所有其他actor最后感知到这个actor事件的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> ，这样在多副本时，比如出现任意副本对某个Key的删除操作，就可以用因果关系感知到其他副本的actor都同步了这个事件之后再执行真正的垃圾回收操作。这就避免了不一致的时候再被同步回来的问题。这个事件最差情况也会由广播机制定期同步。</p><blockquote><p>其实有点怀疑这种方案在大规模集群上的延迟，这样意味着每个actor两两之间都需要比较高密度的数据同步。后面给出的各项测试模式里也没有涉及大量节点和大规模跨机器的测试结果。大多数给的都是少数机器几十个节点的性能报告。</p></blockquote><h1 id="弹性可扩展的一致性策略"><a href="#弹性可扩展的一致性策略" class="headerlink" title="弹性可扩展的一致性策略"></a>弹性可扩展的一致性策略</h1><p><a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是通过设计成一个无需交互，并且让内部符合ACI特性来实现这个高性能高并发的KVS的。<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 通过一种自底向上的方法，通过把复杂数据结构切割成一个一个的 <a href="https://en.wikipedia.org/wiki/Semilattice"><strong>ACI Building Blocks（Lattice）</strong></a> 来保证整体的保持ACI特性。系统内置了一些一致性模型的设计，然后用户也可以自定义Merge函数。 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的设计重点之一就是方便用户可以用 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 已有提供好的符合 <strong>ACI</strong> 的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 来组合成自己需要的也符合 <strong>ACI</strong> 的新形态。然后以此来很方便地实现上面提到的那么多种一致性策略。</p><blockquote><p>文中说是以C++模板来实现易扩展的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的。感觉和STL的思路比较像。</p></blockquote><p>比如说实现了 <strong>MapLattice</strong> （KV结构） 、 <strong>PairLattice</strong> （带版本号的数据对） 、 <strong>MaxIntLattice</strong> （递增整数） 、 <strong>ValueLattice</strong> （用户自定义数据）。可以按下面的结构实现 <a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a>。</p><p><img src="/2022/02/10/anna-lun-wen-bi-ji/1905-02.png" alt="1905-02.png"></p><p>如图，使用Key为 ClientID， Value为 <strong>MaxIntLattice</strong> 的 <strong>MapLattice</strong> 来实现因果一致性所需的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 。 大部分情况下，分片稳定并且系统运行良好的情况下，数据的因果关系可以通过 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 判定出来。少数情况下，如果发生了冲突，就要走冲突合并流程了。只要合并操作符合上面的 <strong>ACI</strong> 特性，等到一定时间窗以后，无论哪个节点先执行合并、数据合并的顺序是怎样，一定会有一个统一的最终结果。</p><blockquote><p>比如合并数据的时候采用按时间+节点ID排序，然后舍弃老数据。就是无论怎么合并。最终的结果一定是一致的。</p></blockquote><p>再比如 <a href="https://jepsen.io/consistency/models/read-committed"><strong>Read Committed</strong></a> 的一致性策略。 其他的部分和 <a href="https://en.wikipedia.org/wiki/Causal_consistency"><strong>因果一致性(Causal)</strong></a> 一样，只要把维护Key的 <a href="https://en.wikipedia.org/wiki/Vector_clock">向量时钟(Vector Clock)</a> 改成用 <strong>MaxIntLattice</strong> 表示的最大时间戳，然后合并策略改成按最新时间戳就行了。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>看 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 对比其他的 KVS 都是碾压的，但是我个人对其他 KVS的设计不熟，对 <a href="https://redis.io/">redis</a> 倒是比较熟悉。所以这里贴出来它和 <a href="https://redis.io/">redis</a> (主要是 redis-cluster) 的对比。</p><p><img src="//anna%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/1905-03.png" alt="1905-03.png"></p><p>如图，在低争用的情况下，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的表现和 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 相近。在高争用的时候，这里说是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的优势比较明显。但是我个人的理解， <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的这部分性能完全来自于对一致性的舍弃上。 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 是很容易配置成强一致，但是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是采用了多个 <strong>Actor Core</strong> 独立运行，然后最终进行Merge的形式。那么在高争用的时候， <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 相当于收敛到了少数节点上运行，但是仍然是可以实现保证一致性的；而 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是先跑完再Merge，这种的话一致性就比较差，也很难实现CAS类的操作（否则也会fallback到少数节点执行，那么和 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的设计模式就相背离了）。</p><p>它在性能消耗分析的部分也说明了，如果一致性策略选的比较弱的话，多副本高争用的情况下还会有Merge开销激增的情况。这个Merge因为是跨节点通信的操作，在Paper提供的3副本的部署结构下大约69%的CPU消耗在这上面。所以影响还是蛮大的，相当于单点性能退化了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终一致性和强一致性的数据库系统还是有很大区别，最终一致性不能保证大家看到的中间状态是一致的，并且可能需要自己去选择或者提供冲突时的处理方法。感觉上可能比较适合非关键性数据的分发和存储。至少在游戏项目中，感觉更实用的还是能保证强一致性的系统，即便是NoSQL系统。因为很多东西有比较复杂的逻辑关系，不太能接受多个节点结果不一致的状态。</p><p>上面 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 和其他系统的比较里也有列出一些强一致性的系统，我觉得和这些强一致的系统比性能其实不太公平。但是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 的一些设计层面的东西还是值得参考的，比如它对worker的设计和考量。这方面它和 <a href="https://github.com/fastio/pedis">pedis</a> 也很像，而且 <a href="https://github.com/fastio/pedis">pedis</a> 性能比它没差太多，但是我的理解没错的话它可以保持强一致，感觉更胜一筹。当然 <a href="https://github.com/fastio/pedis">pedis</a> 功能上目前实现也还是弱了一些，事务的支持和CAS的支持都没有。也就是说乐观锁和悲观锁都还不支持，目前还是没法用于要求强一致的业务里，也就和 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 没太大区别了。</p><p>从分布式设计来看，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 和 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 的大体结构是一样的。节点间通信都是消息传递，节点维护都是 <a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip</a> ，节点收到其他节点的请求都是redirect过去。区别是 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 使用的多线程设计， 而 <a href="https://redis.io/topics/cluster-spec">redis-cluster</a> 是多进程模型；<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 提供了更完备的proxy层，而redis-cluster目前这方面还得靠客户端支持；然后 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 对于resharding的自动化更好一些，并且还实现了热Key的动态副本。如果单单从单点性能的话，<a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 是和redis差不多的。</p><p>个人感觉 <a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna</a> 最大的优势还是在于它的 <a href="https://en.wikipedia.org/wiki/Semilattice">lattice</a> 的设计。这极大地方便了对多种一致性策略的扩展。以后如果有什么新的技术方案出来也能够比较容易在这上面实现和测试。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anna </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体制内还是体制外工作</title>
      <link href="/2022/01/31/ti-zhi-nei-huan-shi-ti-zhi-wai-gong-zuo/"/>
      <url>/2022/01/31/ti-zhi-nei-huan-shi-ti-zhi-wai-gong-zuo/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f564e0d6058947b50e8228d87a53391a4d285672bb4906aa67b4c3b2ba4318ef">4630436162ade97ba2718b7d0c4b3b637b36f73ede6be941aac35e3df96976c4a56777b7d8b8cc9cd79f3a46dd74fb1aea033e89109c1f0fa9acd49ef4da2d22c668c432f3520ba44a7bc38c3d7da6a6d32bb6fed56edd62a427aa61d3dfae4c40b0fbf45afe3ef45d10669b45701934820d040ba5a653328761b9d19983d819922b91fd455585b32857badfadf0cc72d3c1765fd698102925f24ee3469b83b0afa93fe27be93261c7d0cbf75a8f06a3c5c84930910b960249138b31290616944b33956aa553cd4ad6e14f6de1506ebd2d31c55a88ee2893acc5053b0b9da5f0b06b372abc151edf22d0bf977ca95423bc6f19210d23abaaa590a54b7f111387aa43829818576969eb6849775b5844d08deaf0a3cd3b84d23a9a203843b0a4a92f01f474898617401d731619ae1a4f158abb72ad37e39b4b0503cc780cb734b4a23d37a6af67b04cd5f60308bc2ac5b7613092128ad34f48b25936f0f032abf951c203462acb257e6110262f7078b94044242ce6c14eb8ac2862a37ef5da27f381edae5a4c3712a00911de62add46f27e0e1123f4c214348a4d24f76ddd52512ab068c2996fed1ce9d49af7ef37d7b53eb63cf2994f79ed122799d680cc712ecc6ae3c321fe36860bbbfd8776fa4c052ba166a4527702e423072c148c6bc115439bf6b93c9e219a633aef35909fcd5f3acc34a8a84dd2b57571b59332e93b4674abae42af9c09aaf94d5b89dc42c814acae985a7dc9726dd279ec82f67fbfb993dfa449453e930c3725c492e4de1a2b80e5ba6a6e8abb52436c754ac05beaa637abf5db681ad24657b0f036429a54a4c393a31cc4a90697beeb383cfc5edb2e9065b03e2fd64071afd129bf4425bec9e8253e07c94958f7b566fc0d6861993ff4170ff2249c29f33fdb4cd6f4d14d1ff3e4c930baedd3468990002a8b4b54d9ffac924486dbf5ddfc01306b16da747393c7e249b756c423907e061c7f1fe8fcb8e95720ca86174bb4eab42799b2f419e89bf5b6818adea736a1345fc1688d1ff3a15bcca425819b67006da56e3ae64aaedef308f42d9b829108074e227cbcf5bdf9feff2075e9dc63362f45a52efffce4dc4ba83fb63ac5cdd18344b0741dfaa6fa96a8e4235e3fe3372fe79d27fc85603f4d89640e6baeed195bb56e71f7413a48e1b4c41b00c5cd4f25bfda6517668f96b70563810b56ff650615606733549753015a81d9f38665f063ae4d36b5ee2383535bc0d5a521a2ecfd267321f7d8c38f87f26a614331af6ff68a271e3bcc62354e3057d7296117b9cc209302385e9f698fbfde9338544b07cca3ccc607d4c8ff9c2fad8845278c332a054e014207e7cf4d8547890e59a374b3ce225a7d5f3714acb7fc9162440da418f9ac39f5750e05afaf66371a8b27c73ca4925ce71da7141b05cff66fb982056dd9a456694adcf5aa3de90135a29df64905ebe030ec82dafb6bb5c38d975afe90d643383ce654af78d318faf0df32f94222d53897d9130dc657dd66f07a36555db6236107490d7399eaafb44098ed656dd1420bf51e7de7236f00f27f60c55caf435fea42268cf5bee34deca07f78ac962cb3b8500cc7cccbaed148f74b4e2f3b44ba834dfdd798314381db545fa2afbfa7c8279aa808a3985116e3e824def2ef9f9aef80edf065e007799d80f6f222aa0f23a7798ae42efd6f1bdd2250d6c97c227feb248c72440b0ed8ae672a2c480e531441e61c9d2a7002e78019f9b51587b721d7541403e33375a4da0dcab46a4a105bf891ff725fb45367cf9ce62dc93c6adb746dd18e1b7f7415d5bd8281d34b546cd6f54b69e29e02d775c404cc0432deb81101fe4aa8eae4b1933576f3c980723d2a975946392d1eeec035856509fac51810ec50a4b2be51f444d39d87653c564c0643b27</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>译Dynamo Amazon&#39;s Highly Available Key-value Store</title>
      <link href="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/"/>
      <url>/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://arthurchiao.art/blog/amazon-dynamo-zh/">arthurchiao.art /blog/amazon-dynamo-zh/</a></p><h1 id="译-论文-Dynamo-Amazon’s-Highly-Available-Key-value-Store（SOSP-2007）"><a href="#译-论文-Dynamo-Amazon’s-Highly-Available-Key-value-Store（SOSP-2007）" class="headerlink" title="[译] [论文] Dynamo: Amazon’s Highly Available Key-value Store（SOSP 2007）"></a>[译] [论文] Dynamo: Amazon’s Highly Available Key-value Store（SOSP 2007）</h1><p>39-49 minutes</p><hr><p>Published at 2019-07-06 | Last Update 2019-07-06</p><h3 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h3><p>本文翻译自 2007 年 Amazon 的分布式存储经典论文：<strong>Dynamo: Amazon’s Highly Available Key-value Store</strong> (<a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">PDF</a>)。</p><p>标题直译为：<strong>《Dynamo：Amazon 的高可用键值仓库（存储）》</strong>。</p><p>对排版做了一些调整，以更适合 web 阅读。</p><p>Dynamo 是 Amazon 的高可用分布式键值存储（key/value storage）系统。这篇论文发表 的时候（2007）它还只是一个内部服务，现在（改名为 DynamoDB）已经发展成 AWS 最核心 的存储产品（服务）之一，与 S3 等并列。据了解，国内某一线大厂的公有云键值 存储服务，也是参考这篇文章设计和实现的。</p><p>现在提到键值存储，大家首先想到的可能是 Redis，那么 Dynamo 和 Redis 是不是竞品， 只是一个开源一个是商业的？不是的，二者针对的场景不同，这里非常粗地列举几方面：</p><ol><li>使用场景：Dynamo 定位是永远可写（always writable）的持久文件系统，Redis 主要用作（易失）缓存或内存数据库</li><li>存储方式：Dynamo 是磁盘，Redis 是内存</li><li>系统规模：Dynamo 是<strong>分布式</strong>（distributed）存储系统，设计之初（2006）就能支 撑几百台 node；Redis 是<strong>单机或集群（主从复制</strong>），规模不同</li><li>性能指标：以上差异必然导致各自设计时的性能考虑（例如延迟、吞吐、容错等）和实 际的性能量级不同</li></ol><p>精读一篇经典比泛读几十篇水文收获要大的多，尤其是那些领域开山之作。这篇论文适合精读。</p><p><strong>翻译仅供个人学习交流。由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问， 请查阅原文。</strong></p><p>以下是译文。</p><hr><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Amazon 是世界上最大的电商之一。</p><p>在这里我们所遇到的最大挑战之一就是<strong>超大规模下的稳定性问题</strong>（reliability at massive scale）。即使是最微小的故障（the slightest outage），也会造成巨大的经济 损失，而且会降低客户对我们的信任。Amazon.com 作为一个为全球提供 web 服务的平台， 其底层的基础设施是由分布在全球的数据中心中成千上万的服务器和网络设备组成的。在如 此庞大的规模下，大大小小的组件故障是不断在发生的，而我们应对这些故障时所采取 的<strong>管理持久状态的方式</strong>（the way persistent state is managed），<strong>驱动着软件系 统的可靠性（reliability）和可扩展性（scalability）的发展</strong>。</p><p>本文介绍 Dynamo —— 一个<strong>高可用键值存储系统</strong> —— 的设计和实现。Amazon 的一些核心 服务就是基于 Dynamo 提供不间断服务的（always-on experience）。为了达到这种等级的 可用性（level of availability），Dynamo <strong>牺牲了几种特定故障场景下的一致性</strong>。另 外，Dynamo 大量使用了<strong>对象版本化</strong>（object versioning）和<strong>应用协助的冲突解决</strong> （application-assisted conflict resolution）机制，给开发者提供了一种新颖的接口。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>Amazon 是一个全球电商平台，峰值用户达到几千万。支撑 Amazon 的是分布在全球的数据 中心中成千上万的服务器。Amazon 平台对<strong>性能、可靠性和效率</strong>等指标有着很高的要求 。而且，为了支撑持续增长（continous growth），平台需要有<strong>高度的可扩展性</strong>。<strong>可 靠性是我们最重要的需求之一</strong>，因为即使是最微小的故障也会造成巨大的经济损失，而且 会降低客户对我们的信任。</p><p>我们从打造 Amazon 平台的切身实践中总结出的一条经验是：<strong>一个系统的可靠性和可扩展 性取决于如何管理它的应用状态</strong>。</p><blockquote><p>The reliability and scalability of a system is dependent on how its application state is managed.</p></blockquote><p>Amazon 使用的是高度去中心化的、松耦合的、面向服务的架构，由几百个服务组成。这样 的环境对<strong>永远可用</strong>（always available）的存储技术有着强烈的需求。例如，<strong>即使磁 盘挂掉、路由抖动、甚至数据中心被飓风摧毁，用户应该仍然能向他们的购物车添加和查看 商品</strong>。要实现这样的目标，管理购物车的系统就必须永远能读写它的 数据仓库，而且 数据仓库还要跨多个数据中心可用。</p><p>对于我们这种由几百万台设备组成的基础设施，故障是家常便饭；在任何时刻都会有<strong>比例小 但数量不少</strong>（small but significant number）的服务器和网络设备发生故障。因此， Amazon 的软件系统要<strong>将故障视为正常的、可预期的行为（treat failure handling as the normal case），不应因设备故障而影响可用性和性能</strong>。</p><p>为了满足可靠性和可扩展性的需求，Amazon 开发了一些存储技术，S3 （Simple Storage Service）可能是最广为人知的一种。本文介绍 Amazon 的另一个存储产品 Dynamo —— 一个 高可用键值存储数据仓库（data store）—— 的设计和实现。</p><p>Dynamo 用于管理<strong>对可靠性要求非常高的服务</strong>的状态，这些服务还要求对可靠性、一致 性、成本-效率（cost-effectiveness）和性能有很强的控制能力。</p><blockquote><p>Dynamo is used to manage the state of services that have very high reliability requirements and need tight control over the tradeoffs between availability, consistency, cost-effectiveness and performance.</p></blockquote><p>Amazon 平台有很多类型的应用，不同的类型对存储的需求差异很大。例如，其中一类应用 希望能 <strong>数据仓库的配置足够灵活，以便在成本最经济的方式下，由开发者来决定如何 在可用性和性能之间取得折中</strong>。</p><p>Amazon 的一些服务<strong>只需以主键（primary key）的方式访问数据仓库</strong>。对于很多服 务，例如畅销排行榜、购物车、客户喜好偏向、session 管理、销售排名、商品目录等等， 常见的关系型数据库会非常低效，而且限制了规模的扩展性和可用性。Dynamo 提供了只使 用主键（primary key only）的访问接口来满足这类应用的需求。</p><p><strong>Dynamo 基于一些众所周知的（well known）技术实现了可扩展性和高可用性</strong>：</p><ul><li>数据通过<strong>一致性哈希</strong>分散和复制（partitioned and replicated）[10]</li><li>通过<strong>对象版本化</strong>（object versioning）实现一致性 [12]</li><li>副本之间的一致性由一种<strong>类似仲裁的技术</strong>（quorum-like technique）和一个去中 心化的<strong>副本同步协议</strong>（replica synchroni protocol）保证</li><li>gossip-based 分布式故障检测和成员检测（membership）协议</li></ul><p>Dynamo 是一个只需最少人工管理的、完全去中心化的系统。</p><blockquote><p>Dynamo is a completely decentralized system with minimal need for manual administration.</p></blockquote><p>向 Dynamo 添加或移除存储节点不需要人工 partition（调整哈希节点）或 redistribution（在节点之间重新平衡数据分布）。</p><p>Dynamo 在过去的几年已经成为 Amazon 很多核心服务的底层存储技术。在节假日购物高峰 ，它能实现不停服（平滑）扩容以支持极高的峰值负载。例如购物车服务的几千万请求会 产生单日 300 万次的付款动作，管理 session 状态的服务能处理几千万的并发活跃用户等 等。</p><p><strong>本文对该领域的主要贡献</strong>：</p><ul><li>评估了如何通过组合不同技术实现一个高度可用的（highly-available）系统</li><li>证明了最终一致性存储系统可以用于生产环境，满足应用的高要求</li><li>展示了若干优化技术，以满足生产环境的非常严格的性能要求</li></ul><p>本文章节结构介绍（略，见下面全文）。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p>Amazon 的电商平台由几百个服务组成，它们协同工作，提供的服务包罗万象，从推荐系统 到订单处理到欺诈检测等等。每个服务对外提供定义良好的 API，被其他服务通过网络的方 式访问。这些服务运行在分布在全球的数据中心中，成千上万的服务器组成的基础设施之上 。有些服务是无状态的（例如，聚合其他服务的响应的服务），有些是有状态的（例如，基 于存储在数据仓库里的状态，执行业务逻辑并产生响应的服务）。</p><p>传统上，生产系统使用关系型数据库来存储状态。但对很多<strong>持久状态的存储</strong>需求来说， 关系型数据库并不是一种理想的方式。这一类型中的大多数服务只用主键去检索，并不需要 RDBMS 提供的复杂查询和管理功能。这些额外的功能需要昂贵的硬件和专门的技能，而实际 上服务根本用不到，最终的结果就是使用关系型数据库非常不经济。另外，这类数据库的复 制功能很受限，而且通常是靠<strong>牺牲可用性来换一致性</strong>。虽然近些年有了一些改进，但总 体来说水平扩展（scale-out）以及使用智能（smart）partitioning 来做负载均衡还是很不 方便。</p><p>本文介绍 Dynamo 是如何解决以上需求的。Dynamo 有易用的 key/value 接口，高度可用 ，有定义清晰的一致性窗口（clearly defined consistency window），资源使用效率很高 ，并且有易用的水平扩展方案以解决请求量或数据增长带来的挑战。<strong>每个使用 Dynamo 的 服务，使用的都是它们独立的一套 Dynamo 系统</strong>。</p><blockquote><p>Each service that uses Dynamo runs its own Dynamo instances.</p></blockquote><h3 id="2-1-系统假设与需求"><a href="#2-1-系统假设与需求" class="headerlink" title="2.1 系统假设与需求"></a>2.1 系统假设与需求</h3><p>Dynamo 对使用它的服务有如下几点假设。</p><h4 id="查询模型（Query-Model）"><a href="#查询模型（Query-Model）" class="headerlink" title="查询模型（Query Model）"></a>查询模型（Query Model）</h4><p><strong>通过唯一的 key 对数据进行读写</strong>。状态以<strong>二进制对象</strong>（binary objects，e.g. blobs）形式存储，以唯一的 key 索引。</p><p><strong>任何操作都不会跨多个 data items</strong>（数据单元），没有关系型 schema 需求。</p><p>Dynamo 面向的应用<strong>存储的都是相对较小的文件（一般小于 1 MB）</strong>。</p><h4 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h4><p>ACID（Atomicity, Consistency, Isolation, Durability）是一组保证数据库事务可 靠执行的特性。在数据库领域，对数据的单次逻辑操作（single logical operation） 称为一次事务（transaction）。 我们在 Amazon 的实践表明，让数据仓库支持 ACID 会使得它的可用性（availability） 非常差，工业界和学术界也已经就这一点达成了广泛共识 [5]。</p><p><strong>Dynamo 的目标应用具有这样的特点：如果能给可用性（CAP 里面的 A）带来很大提升 ，那牺牲一些一致性（C）也是允许的</strong>。</p><p>Dynamo 不提供任何隔离保证，并且只允许带单个 key 的更新操作（permit only single key updates）。</p><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><p>系统需要运行在通用硬件（commodity hardware）之上。Amazon 的服务对延迟有着严格的 要求，通常用百分位值（percentile）<code>P99.9</code> 衡量。</p><p>考虑到对状态数据的访问是服务的核心操作之一，我们的存储系统必须满足那些严格的 SLA （见 Section 2.2）。另外，服务要有配置 Dynamo 的能力，以便能满足服务的延迟和吞吐 需求。最终，就是在性能、成本效率、可用性和持久性之间取得折中。</p><h4 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h4><p>Dynamo 定位是 Amazon 内部使用，因此我们假设环境是安全的，不需要考虑认证和鉴权 等安全方面的问题。</p><p>另外，<strong>由于设计中每个服务都使用各自的一套 Dynamo，因此 Dynamo 的初始设计规模是 几百个存储节点</strong>。后面会讨论可扩展性限制的问题，以及可能的解决方式。</p><h3 id="2-2-SLA-Service-Level-Agreements"><a href="#2-2-SLA-Service-Level-Agreements" class="headerlink" title="2.2 SLA (Service Level Agreements)"></a>2.2 SLA (Service Level Agreements)</h3><p>要<strong>保证一个应用完成请求所花的时间有一个上限</strong>（bounded time），它所依赖的那些服 务就要有一个更低的上限。<strong>对于给定的系统特性</strong>，其中最主要的是客户端期望的<strong>请求 率分布</strong>（request rate distribution），<strong>客户端和服务端会定义一个 SLA（服务级别 协议）</strong>来作为契约。</p><p>举个简单例子：某个服务向客户端保证，在 500 QPS 的负载下，它处理 <code>99.9%</code> 的请求 所花的时间都在能 <code>300ms</code> 以内。</p><p>在 Amazon 的去中心化的、面向服务的基础设施中，SLA 扮演着重要角色。例如，对购物 页面的一次请求，在典型情况下会使渲染引擎向多达 150 个服务发送子请求，而这些子服 务又都有自己的依赖，最终形成一张多层的（more than one level）调用图（call graph ）。为了保证渲染引擎能在一个上限时间内返回一个页面，调用链中的所有服务就都必须遵 循各自的性能契约（contract）。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/1.png" alt="img"></p><p>图 1 Amazon 平台的面向服务架构</p><p>图 1 是一张简化之后的 Amazon 平台架构图。可以看到，动态 web 内容由页面渲染组件 提供，而它是通过调用其他的一些服务来完成这项工作的。</p><p><strong>每个服务可以选择不同类型的数据仓库（data store）来管理（存储）它们的状态数据， 这些数据仓库只能在各自的服务边界（service boundaries）内访问</strong>。一些服务会通过聚 合其他服务的数据来组合产生一个响应（composite response）。典型情况下，聚合服务（ aggregator service）是无状态的，虽然它们大量使用缓存技术。</p><p>对于面向性能的 SLA（performance oriented SLA），业内一般习惯使用<strong>平均值、中位数 和方差</strong>来描述。但在 Amazon 我们发现，要打造一个让所有用户——而不是大部分用户——都 有良好体验的系统，以上 SLA 并不合适。例如，<strong>如果使用了个性化推荐技术，那用户的 访问历史越多，他的请求被处理的时间就越长，最终落到了性能分布的长尾区</strong>。基于平均 值或中位数的 SLA 并不能反映这种情况。为了解决这个问题，<strong>我们使用了 <code>P99.9</code> 分布。<code>99.9%</code> 这个精度是经过大量实验分析，权衡了成本和性能之后得到的</strong>。 我们在生产环境的实验显示，这比基于均值或中位数的 SLA 有更好的用户体验。</p><p>本文多处都将引用 P99.9 分布，这也显示了 Amazon 的工程师对提高用户体验所做的持续 不断的努力。一些基于均值的论文，我们会在它真正有意义的场景才拿出来作为比较，但我 们自己的工程和优化都不是以<strong>均值 SLA</strong> 为核心的。某些技术，例如 write coordinator（写操作协调者），是完全面向 P99.9 来控制性能的。</p><p><strong>存储系统在构建一个服务的 SLA 中经常扮演着重要角色，尤其是业务逻辑相对轻量的 场景</strong>，Amazon 的服务即属于这一类。因此，<strong>状态管理</strong> 就成了服务的 <strong>SLA 的主要 部分</strong>。</p><p><strong>Dynamo 的设计目标之一就是：允许服务自己控制自己的系统特性</strong>——例如持久性和一 致性——<strong>让服务自己决定如何在功能、性能和成本效率之间取得折中</strong>。</p><blockquote><p>One of the main design considerations for Dynamo is to give services control over their system properties, such as durability and consistency, and to let services make their own tradeoffs between functionality, performance and cost-effectiveness.</p></blockquote><h3 id="2-3-设计考虑"><a href="#2-3-设计考虑" class="headerlink" title="2.3 设计考虑"></a>2.3 设计考虑</h3><p><strong>商业系统中数据复制算法一般都是同步的，以提供一个强一致性的数据访问接口。 为了达到这种级别的一致性，这些算法被迫牺牲了某些故障场景下的数据可用性</strong>。例如， 如果数据有冲突，它们会禁止访问这个数据，直到数据的不一致完全得到了解决。在早期，这 种<strong>复制式数据库</strong>（replicated database）是可以工作的。</p><p>但众所周知，分布式系统是无法同时满足<strong>强一致性、高可用性和正确处理网络故障（CAP ）</strong>这几个条件的 [2, 11]。<strong>因此，系统和应用都需要知道，在什么场景下选择满足什么 特性</strong>。</p><p>对于<strong>服务器和网络故障较高的场景</strong>，可以通过<strong>乐观复制</strong>（optimistic replication ）技术增强<strong>可用性</strong>，在后台将数据变动同步到其他节点，并发更新和失联也是可以容忍 的。这种方式的问题是会<strong>导致数据冲突，需要检测并解决冲突</strong>。而解决数据冲突又会带 来两个额外问题：</p><ul><li>何时解决？</li><li>谁来解决？</li></ul><p><strong>Dynamo 设计为最终一致数据仓库</strong>（eventually consistent data store），即，最终 所有的更新会应用到所有的副本。</p><h4 id="何时解决冲突？"><a href="#何时解决冲突？" class="headerlink" title="何时解决冲突？"></a>何时解决冲突？</h4><p>设计时的一个重要考虑是：<strong>何时解决更新冲突</strong>，例如，是读的时候还是写的时候。</p><blockquote><p>An important design consideration is to decide when to perform the process of resolving update conflicts, i.e., whether conflicts should be resolved during reads or writes.</p></blockquote><p>一些传统的数据仓库是在<strong>写的时候解决冲突</strong>，这样可以<strong>保证读的复杂度很低</strong> [7]。 在这种系统中，任何时候<strong>如果数据仓库不能访问所有（或者大多数）副本，写就会被拒绝</strong>。</p><p>Dynamo 的设计与此相反，它的目标是提供一个<strong>“永远可写”（always writable）</strong>的数据 仓库（例如，一个对写操作高度可用的数据仓库）。对很多 Amazon 服务来说，拒绝写 入会造成很差的用户体验。比如即使发生服务器或网络故障，也应该允许用户往购物车添 加或删除商品。<strong>这个需求使我们将解决冲突的复杂度放到了读操作，以保证写永远不会 被拒绝</strong>。</p><h4 id="谁来解决冲突？"><a href="#谁来解决冲突？" class="headerlink" title="谁来解决冲突？"></a>谁来解决冲突？</h4><p>下一个需要考虑的问题是：<strong>谁来解决冲突</strong>。<strong>数据仓库</strong>和<strong>应用</strong>都可以做这件事情。</p><p><strong>如果由数据仓库来做，那选择会相当受限</strong>。在这种情况下，数据仓库只能使用一些 非常简单的策略，例如<strong>“最后一次写有效”</strong>（last write wins） [22]，来解决更新冲突。</p><p>另一方面，由于<strong>应用理解数据描述的是什么</strong>（application is aware of the data schema），<strong>它可以自主选择对用户体验最好的冲突解决算法</strong>。例如，购物车应用可以选择“ 合并”冲突的版本，返回一个合并后的（unified）购物车。尽管这样可以带来很大的灵活性 ，但一些应用开发者并不想自己实现一套冲突解决机制，因此在这种情况下，解决冲突的问 题就下放给了数据仓库，由后者来选择一些简单的策略，例如 “last write wins”。</p><h4 id="其他设计原则"><a href="#其他设计原则" class="headerlink" title="其他设计原则"></a>其他设计原则</h4><ul><li><strong>增量扩展性</strong>（Incremental scalability）：应当支持<strong>逐机器（节点）扩容</strong>，而 且对系统及运维人员带来的影响尽量小</li><li><strong>对称性</strong>（Symmetry）：<strong>每个节点的职责应该是相同的</strong>，不应当出现某些节点承担 特殊职责或特殊角色的情况。以我们的实践经验，<strong>对称性简化了系统的交付和运维</strong></li><li><strong>去中心化</strong>（Decentralization）：<strong>“去中心化”是“对称性”的进一步扩展</strong>，系统应 该是去中心化的、点对点的，而不应该是集中式控制的。在过去，集中式控制导致了很多 服务故障（outage），我们应当极力避免它。去中心化会使得系统更简单、更具扩展性和 可用性</li><li><strong>异构性</strong>（Heterogeneity）：系统要能够利用到基础设施的异构性。例如，<strong>负载的 分布要和存储节点的能力成比例</strong>。对于逐步加入能力更强的新节点，而不是一次升级所 有节点来说，这种异构支持能力是不可或缺的</li></ul><h2 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h2><h3 id="3-1-点对点系统（Peer-to-Peer-Systems）"><a href="#3-1-点对点系统（Peer-to-Peer-Systems）" class="headerlink" title="3.1 点对点系统（Peer to Peer Systems）"></a>3.1 点对点系统（Peer to Peer Systems）</h3><p>一些点对点（peer-to-peer, P2P）系统关注了<strong>数据存储和分散</strong>（data storage and distribution）的问题。</p><h4 id="P2P-系统"><a href="#P2P-系统" class="headerlink" title="P2P 系统"></a>P2P 系统</h4><p>第一代 P2P 系统，例如 Freenet 和 Gnutella，在文件共享系统（file sharing system） 领域使用广泛。它们都是<strong>非受信（untrusted）P2P 网络</strong>的代表，节点之间的 overlay （网络术语，和 underlay 对应，请参考 Wikipedia 或其他资料，译者注）链路都是随机 （随意）建立的（established arbitrarily）。在这种网络中，一次查询请求通常是<strong>泛 洪（flood）到整张网络，找到尽量多的共享这个数据的节点</strong>。</p><h4 id="结构化-P2P-系统"><a href="#结构化-P2P-系统" class="headerlink" title="结构化 P2P 系统"></a>结构化 P2P 系统</h4><p>P2P 网络到下一代，就是有名的<strong>结构化 P2P 网络</strong>（structured P2P network）。这种 网络使用了全局一致性协议（globally consistent protocol），保证<strong>任何一个节点可以 高效地将查询请求路由到存储这个数据的节点</strong>。</p><p>Pastry [16] 和 Chord [20] 这样的系统<strong>利用路由机制可以保证查询在若干（有上限） 跳</strong>（a bounded number of hops）之内收到应答。</p><p>为了减少多跳（multi-hop）路由带来的额外延迟，一些 P2P 系统（例如 [14]）使用了 <strong><code>O(1)</code>路由机制</strong>，在这种机制中，<strong>每个节点维护了足够多的路由信息</strong>，因此它可以 将（访问数据的）请求在常量跳数（constant number of hops）内路由到合适的对端节点 。</p><p>包括 Oceanstore [9] 和 PAST [17] 在内的很多存储系统都是构建在这种路由（routing） overlay 之上的。Oceanstore 提供全球分布的、事务型的、持久的存储服务，支持分布在 很大地理范围内的副本的串行化更新（serialized updates on widely replicated data） 。<strong>为了支持并发更新，同时避免广域锁</strong>（wide-are locking）内在的一些问题，它使用了一 种基于冲突解决（conflict resolution）的更新模型。conflict resolution 在 [21] 中 提出，用于减少事务异常中止（transaction abort）的数量。<strong>Oceanstore 处理冲突的方式是 ：对并发更新进行排序（order），将排好序的若干个更新作为原子操作应用到所有副本</strong>。 Oceanstore 是为在<strong>不受信的基础设施上做数据复制的场景</strong>设计的。</p><p>作为对比，PAST 是在 Pastry 之上提供了一个简单的抽象层，以此来提供持久和<strong>不可变对 象</strong>（persistent and immutable objects）。它假设<strong>应用可以在它之上构建自己需要的 存储语义</strong>（storage semantics）（例如可变文件）。</p><h3 id="3-2-分布式文件系统与数据库"><a href="#3-2-分布式文件系统与数据库" class="headerlink" title="3.2 分布式文件系统与数据库"></a>3.2 分布式文件系统与数据库</h3><p>文件系统和数据库系统领域已经对<strong>通过分散数据（distributing data）来提高性能、可 用性和持久性</strong>进行了广泛研究。和 <strong>P2P 存储系统只支持扁平命名空间</strong>（flat namespace）相比，<strong>典型的分布式文件系统都支持层级化的命名空间</strong>（hierarchical namespace）。</p><ul><li>Ficus [5] 和 Coda [19] 这样的系统通过文件复制来提高可用性，代价是牺牲一致性。 解决更新冲突一般都有各自特殊的解决方式</li><li>Farsite [1] 是一不使用中心式服务器（例如 NFS）的分布式文件系统，它通过复制实现 高可用和高扩展</li><li><strong>Google File System</strong> [6] 是另一个分布式文件系统，用于存储 Google 内部应用的 状态数据。GFS 的设计很简单，一个主节点（master）管理所有元数据，数据进行分片（ chunk），存储到不同数据节点（chunkservers）。</li><li>Bayou 是一个分布式关系型数据库系统，允许在失联情况下进行操作（disconnected operation），提供最终一致性</li></ul><p>在这些系统中，Bayou、Coda 和 Ficus 都支持失联情况下进行操作，因此对网络分裂和宕 机都有很强的弹性，它们的不同之处在于如何解决冲突。例如，Coda 和 Ficus 在系统层面 解决（system level conflict resolution），而 Bayou 是在应用层面（application level）。相同的是，它们都提供最终一致性。与这些系统类似，<strong>Dynamo 允许在网络发生 分裂的情况下继续执行读写操作，然后通过不同的冲突解决机制来处理更新冲突</strong>。</p><p>分布式块存储系统（distributed block storage system），例如 FAB [18]，将一个大块 分割成很多小块并以很高的可用性的方式存储。和这类系统相比，<strong>我们的场景更适合使用键 值存储</strong>，原因包括：</p><ul><li>系统定位是<strong>存储相对较小的文件</strong>（ <code>size &lt; 1 MB</code>）</li><li><strong>键值存储</strong>（key-value store）更容易在应用级别<strong>针对单个应用</strong>（per-application）进行配置</li></ul><p>Antiquity 是一个广域分布式文件系统，设计用于处理多个服务器挂掉的情况 [23]。它使 用<strong>安全日志</strong>（secure log）保证数据完整性，在不同服务器之间复制 secure log 来保 证持久性（durability），使用<strong>拜占庭容错协议</strong>（Byzantine fault tolerance protocols）保证数据一致性。与此不同，<strong>Dynamo 并不将数据完整性和安全性作为主要关 注点，因为我们面向的是受信环境</strong>。</p><p><strong>Bigtable 是一个管理结构化数据</strong>（structured data）的分布式文件系统，它维护了一 张稀疏的多维有序映射表（sparse, multi-dimensional sorted map），允许应用通过多重 属性访问它们的数据（access their data using multiple attributes） [2]。与此不同 ，<strong>Dynamo 面向的应用都是以 key/value 方式访问数据的，我们的主要关注点是高可用</strong> ，即使在发生网络分裂或服务器宕机的情况下，写请求也是不会被拒绝的。</p><p>传统的复制型关系数据库系统（replicated relational database systems）都将关注点放 在<strong>保证副本的强一致性</strong>。虽然强一致性可以<strong>给应用的写操作提供方便的编程模型</strong>， 但导致系统的扩展性和可用性非常受限 [7]，无法处理网络分裂的情况。</p><h3 id="3-3-讨论"><a href="#3-3-讨论" class="headerlink" title="3.3 讨论"></a>3.3 讨论</h3><p>Dynamo 面临的需求使得它与前面提到的集中式存储系统都不相同。</p><p>首先，Dynamo 针对的主要是<strong>需要“永远可写的”（always writable）数据仓库的应用</strong>， 即使发生故障或并发更新，写也不应该被拒绝。对于 Amazon 的很多应用来说，这一点是非 常关键的。</p><p>第二，Dynamo 构建在<strong>受信的、单一管理域的基础设施</strong>之上。</p><p>第三，使用 Dynamo 的应用<strong>没有层级命名空间（hierarchical namespace）的需求</strong>（这是很 多文件系统的标配），也没有复杂的关系型 schema 的需求（很多传统数据库都支持）。</p><p>第四，Dynamo 是为<strong>延迟敏感型应用</strong>（latency sensitive application）设计的，至少 <code>99.9%</code> 的读写操作都要在几百毫秒内完成。为了到达如此严格的响应要求，在多节点 之间对请求进行路由的方式（被很多分布式哈希表系统使用，例如 Chord 和 Pastry ）就无法使用了。因为多跳路由会增加响应时间的抖动性，因此会增加长尾部分的延迟。 Dynamo 可以被描述为：一个<strong>零跳（zero hop）分布式哈希表（DHT）</strong>，每个节点在本地 维护了足够多的路由信息，能够将请求直接路由到合适节点。</p><h2 id="4-系统架构"><a href="#4-系统架构" class="headerlink" title="4. 系统架构"></a>4. 系统架构</h2><p>生产级别的存储系统的架构是很复杂的。除了最终存储数据的组件之外，系统还要针对下列 方面制定可扩展和健壮的解决方案：负载均衡、成员管理（membership）、故障检测、故障 恢复、副本同步、过载处理（overload handling）、状态转移、并发和任务调度、请求 marshalling、请求路由（routing）、系统监控和告警，以及配置管理。</p><p>详细描述以上提到的每一方面显然是不可能的，因此本文将关注下面几项 Dynamo 用到的分 布式系统核心技术：</p><ul><li>partitioning（分区，经哈希决定将数据存储到哪个/些节点）</li><li>复制（replication）</li><li>版本化（versioning）</li><li>成员管理（membership）</li><li>故障处理（failure handling）</li><li>规模扩展（scaling）</li></ul><p>表 1 总结了 Dynamo 使用的这些技术及每项技术的好处。</p><p>表 1 Dynamo 用到的技术及其好处</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/table-1.png" alt="img"></p><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><ul><li>技术：<strong>一致性哈希</strong></li><li>好处：增量可扩展性</li></ul><h4 id="写高可用"><a href="#写高可用" class="headerlink" title="写高可用"></a>写高可用</h4><ul><li>技术：读时协调（解决冲突）的<strong>向量时钟</strong>（vector clocks with reconciliation during reads）</li><li>好处：version size（？）和更新频率（update rates）解耦</li></ul><h4 id="短时故障处理"><a href="#短时故障处理" class="headerlink" title="短时故障处理"></a>短时故障处理</h4><ul><li>技术：<strong>宽松的选举和 hinted handoff</strong>（移交给其他节点处理，附带提示信息）</li><li>好处：部分副本不可用时，仍然可以提供高可用性和持久性</li></ul><h4 id="持久（permanent）故障恢复"><a href="#持久（permanent）故障恢复" class="headerlink" title="持久（permanent）故障恢复"></a>持久（permanent）故障恢复</h4><ul><li>技术：<strong>基于 Merkle tree 的逆熵</strong>（anti-entropy）</li><li>好处：后台同步版本不一致的副本</li></ul><h4 id="成员管理和故障检测"><a href="#成员管理和故障检测" class="headerlink" title="成员管理和故障检测"></a>成员管理和故障检测</h4><ul><li>技术：<strong>基于 Gossip 的成员管理协议和故障检测</strong></li><li>好处：保持了<strong>架构的对称性</strong>，无需一个中心组件（centralized registry）来存储成员和节点状态等信息</li></ul><h3 id="4-1-系统接口"><a href="#4-1-系统接口" class="headerlink" title="4.1 系统接口"></a>4.1 系统接口</h3><p>Dynamo 存储键值对象的接口非常简单，它提供两个操作：</p><ul><li><code>get()</code></li><li><code>put()</code></li></ul><p><code>get(key)</code> 会定位到存储系统中 <code>key</code> 对应的所有对象副本，<strong>返回对象</strong> ——可能是单个对 象，也可能是一个对象列表（有冲突情况下，包括了所有版本）—— <strong>以及一个 <code>context</code>（ 上下文）</strong>。</p><p><code>put(key)</code> 确定对象应该存放的位置，然后写到相应的磁盘。</p><p><code>context</code> 包含了系统中对象的元数据，例如对象的版本，<strong>对调用方是不透明的</strong>（ opaque）。<strong>上下文信息是和对象存储在一起的</strong>，这样系统很<strong>容易验证 <code>put</code> 请求的 <code>context</code> 是否合法</strong>。</p><p>Dynamo <strong>将调用方提供的 key 和对象都视为不透明的字节序列</strong>（opaque array of bytes） 。它<strong>对 key 应用 MD5 哈希得到一个 128bit 的 ID，并根据这个 ID 计算应该存储 到哪些节点</strong>。</p><blockquote><p>Dynamo treats both the key and the object supplied by the caller as an opaque array of bytes. It applies a MD5 hash on the key to generate a 128-bit identifier, which is used to determine the storage nodes that are responsible for serving the key.</p></blockquote><h3 id="4-2-数据分散（Partitioning）算法"><a href="#4-2-数据分散（Partitioning）算法" class="headerlink" title="4.2 数据分散（Partitioning）算法"></a>4.2 数据分散（Partitioning）算法</h3><p>Dynamo 的核心需求之一是：系统必须支持<strong>增量扩展</strong>（scale incrementally）。 这就要求有一种机制能够将数据分散到系统中的不同的节点（例如，以一台机器作为一个 节点的维度）上。</p><p>Dynamo 的<strong>分散方案基于一致性哈希</strong> [10]。在一致性哈希中，哈希函数的<strong>输出是一个 固定的范围，通常作为一个循环空间，或称环（ring）</strong>。<strong>每个节点都会随 机分配一个在这个循环空间内的值</strong>，这个值代表了节点在这个环上的位置。</p><p>用如下方式找到一个数据项（data item）对应的存储节点：</p><ol><li>首先对它的 key 做哈希得到一个哈希值</li><li>然后，在环上沿着顺时针方向找到第一个<strong>所带的值比这个哈希值更大的节点</strong>（前面 提到每个节点都会被分配一个值）</li></ol><p>即，每个节点要负责环上从它自己到它的下一个节点之间的区域。<strong>一致性哈希的主要好处是 ：添加或删除节点只会影响相邻的节点，其他节点不受影响。</strong></p><blockquote><p>The principle advantage of consistent hashing is that departure or arrival of a node only affects its immediate neighbors and other nodes remain unaffected.</p></blockquote><p>但是，<strong>初级的一致性哈希算法在这里是有一些问题的</strong>。 首先，给每个节点随机分配一个位置会导致数据和负载的非均匀分布。 其次，初级的一致性哈希算法没有考虑到节点的异构因素，导致性能不理想。</p><p>为了解决这些问题，Dynamo 使用了一致性哈希的一个变种（和 [10, 20] 的类似）：<strong>每个 节点并不是映射到环上的一个点，而是多个点</strong>。</p><blockquote><p>Intead of mapping a node to a single point in the circle, each node gets assigned to multiple points in the ring.</p></blockquote><p>为了实现这种设计，Dynamo 使用了<strong>虚拟节点</strong>（virtual node）的概念。一个虚拟节点 看上去和一个普通节点一样，但<strong>实际上可能管理不止一台虚拟节点</strong>。具体来说， <strong>当一个新节点添加到系统后，它会在环上被分配多个位置（对应多个 token）</strong>。 我们会在 Section 6 介绍 Dynamo 分散策略（算法）的深入调优 。</p><p><strong>虚拟节点可以代来如下好处</strong>：</p><ol><li>当一个节点不可用时（故障或例行维护），这个节点的负载会均匀分散到其他可用节点上</li><li>当一个节点重新可用时，或新加入一个节点时，这个节点会获得与其他节点大致相同的 负载</li><li>一个节点负责的虚拟节点的数量可用根据节点容量来决定，这样可用充分利用物理基础 设施中的异构性信息</li></ol><h3 id="4-3-数据复制（Replication）"><a href="#4-3-数据复制（Replication）" class="headerlink" title="4.3 数据复制（Replication）"></a>4.3 数据复制（Replication）</h3><p>为了实现高可用性和持久性，Dynamo 将数据复制到多台机器上。每个数据会被复制到 N 台 机器，这里的 N 是每套 Dynamo 可以自己配置的。</p><p>上节介绍到，<strong>每个 key <code>k</code>，会被分配一个 coordinator（协调者）</strong>节点。 coordinator <strong>负责落到它管理的范围内的数据的复制</strong>。它除了自己存储一份之外，还会 在环上顺时针方向的其他 <code>N-1</code> 个节点存储一份副本。因此在系统中，每个节点要负责从 它自己往后的一共 N 个节点。</p><p>例如，图 2 中，B 除了自己存储一份之外，还会将其复制到 C 和 D 节点。因此，D 实际 存储的数据，其 key 的范围包括 <code>(A, B]</code>、<code>(B, C]</code> 和 <code>(C, D]</code>（例如，落在 <code>(A, B]</code> 范围内的 key 会沿顺时针方向找到第一个值比它大的节点，因此找到的是 B，而 B 会 将自己存储的数据复制到 C 和 D，因此 D 会包含 key 在 <code>(A, B]</code> 范围内的对象。其他 几个范围也是类似的。译者注）。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2.png" alt="img"></p><p>图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）</p><p>存储某个特定 key 的所有节点组成一个列表，称为 <strong>preference list</strong>（优先列表）。 我们在 4.8 节会看到，Dynamo 的设计是，<strong>对于给定的 key，每个节点都能决定哪些 节点可以进入这个列表</strong>。<strong>为了应对节点失败的情况，preference list 会包含多余 N 个节 点</strong>。</p><blockquote><p>todo：这里的优先列表会不会非常非常大？占用资源太多？</p></blockquote><p>另外注意，由于我们引入了虚拟节点，存储一个 key 的 N 个节点，实际上对应的物理节 点可能少于 N 个（例如，一个节点可能会占用环上的不止一个节点）。为了避免这个问题 ，<strong>preference list 在选择节点的时候会跳过一些位置，以保证 list 里面的节点都在不 同的物理节点上</strong>。</p><h3 id="4-4-数据版本化（Data-Versioning）"><a href="#4-4-数据版本化（Data-Versioning）" class="headerlink" title="4.4 数据版本化（Data Versioning）"></a>4.4 数据版本化（Data Versioning）</h3><p>Dynamo 提供最终一致性，所有更新操作会异步地传递给所有的副本。</p><p><code>put()</code> 操作返回时，数据（更新）可能还没有应用到所有副本，因此紧接着的 <code>get()</code> 操作可能获取不到最新数据。在没有故障的情况下，传递更新的耗时有一个上限；但在特定 故障场景下（例如服务器宕机或网络分裂），更新可能会在限定的时间内无法传递到所有副 本。</p><p>Amazon 有些应用是可以容忍这种不一致性的，应用在这种情况下能继续运行。例如，购物 车应用要求“添加到购物车”的请求永远不能被丢失或拒绝。如果购物车的最新状态不可用， 而用户对一个稍老版本的购物车状态做了修改，那这种修改也是有意义的，需要保留；但它 不能直接覆盖最新的状态，因为最新的状态中可能也有一些修改需要保留。这里要注意，不 管是“添加到购物车”还是“从购物车删除”，在系统中转换成的都是 Dynamo 的 <code>put()</code> 操作 。如果最新的状态不可用，而用户又基于稍的大版本做了修改，那这两个版本都需要保留， 由随后的步骤来处理更新冲突。</p><h4 id="如何解决更新冲突"><a href="#如何解决更新冲突" class="headerlink" title="如何解决更新冲突"></a>如何解决更新冲突</h4><p>为了满足以上需求，Dynamo <strong>将每次修改结果都作为一个新的、不可变的版本</strong>。</p><blockquote><p>Dynamo treats the result of each modification as a new and immutable version of the data.</p></blockquote><p>即，允许系统中同时存在多个不同版本。</p><h5 id="冲突调和（使一致化）方式"><a href="#冲突调和（使一致化）方式" class="headerlink" title="冲突调和（使一致化）方式"></a>冲突调和（使一致化）方式</h5><ul><li>syntactic reconciliation（<strong>基于句法的调和</strong>）</li><li>semantic reconciliation（<strong>基于语义的调和</strong>）</li></ul><p>在<strong>大部分情况下，新版本都包含老版本的数据，而且系统自己可以判断哪个是权威版本</strong> （syntactic reconciliation）。</p><p>但是，在发生故障并且存在并发更新的场景下，版本会发生分叉（version branching）， 导致冲突的对象版本。<strong>系统本身无法处理这种情况，需要客户端介入，将多个分支合并成 一个</strong>（semantic reconciliation）。一个典型的例子是：合并多个不同版本的购物车。 有了这种调和机制（reconciliation mechanism），“添加到购物车”操作就永远不会失败 ；但是，这种情况会导致<strong>已经删除的商品偶尔又在购物车中冒出来</strong>（resurface）。</p><p>有很重要的一点需要注意：某些故障模式（failure mode）会导致存在多个冲突的版本，而 不仅仅是两个。服务器故障或网络分裂会导致一个对象有多个版本，每个版本有各自的子历 史（version sub-histories），随后要由系统来将它们一致化。这需要<strong>将应用 设计为：显式承认多版本存在的可能性（以避免丢失任何更新）</strong></p><h5 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h5><p><strong>Dynamo 使用向量时钟（vector clock）[12] 来跟踪同一对象不同版本之间的因果性</strong>。 一个向量时钟就是一个 <code>(node, counter)</code> 列表。一个向量时钟关联了一个对象的所有版 本，可以通过它来判断对象的两个版本是否在并行的分支上，或者它们是否有因果关系。 <strong>如果对象的第一个时钟上的所有 counter 都小于它的第二个时钟上的 counter，那第一个 时钟就是第二的祖先，可以安全的删除；否则，这两个修改就是有冲突的，需要 reconciliation</strong>。</p><p>在 Dynamo 中，<strong>客户端更新一个对象时，必须指明基于哪个版本进行更新</strong>。流程是先执 行读操作，拿到 context，其中包含了 vector clock 信息，然后写的时候带上这个 context。</p><p>在处理读请求的时候，如果 Dynamo 能够访问到多个版本，并且无法 reconcile 这些版本 ，那它就会返回所有版本，并在 context 中附带各自的 vector clock 信息。 <strong>基于 context 指定版本更新的方式解决了冲突</strong>，将多个分支重新合并为一个唯 一的新分支。</p><blockquote><p>An update using this context is considered to have reconciled the divergent versions and the branches are collapsed into a single new version.</p></blockquote><h4 id="一个具体例子"><a href="#一个具体例子" class="headerlink" title="一个具体例子"></a>一个具体例子</h4><p>我们通过 图 3 来展示 vector clock 是如何工作的。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/3.png" alt="img"></p><p>图 3 一个对象在一段时间内的版本演进</p><p>首先，客户端写入一个对象。处理这个 key 的写请求的节点 <code>Sx</code> 增加 key 的序列号（计 数），并用这个序列号创建对象的 vector clock。至此，系统有了一个对象 <code>D1</code> 和它的 时钟 <code>[(Sx, 1)]</code>。</p><p>第二步，客户端更新这个对象。假设还是 <code>Sx</code> 处理这个请求。此时，系统有了对象 <code>D2</code> 和它的时钟 <code>[(Sx, 2)]</code>。<code>D2</code> 是 <code>D1</code> 的后代，因此可以覆盖 <code>D1</code>；<strong>但是，<code>D1</code> 在 其他节点上的副本可能还没有看到 <code>D2</code> 这次更新</strong>。</p><p>第三步，假设还是这个客户端，再次更新了对象，并且这次是由另外的一个节点 <code>Sy</code> 处理 请求。此时，系统有了 <code>D3</code> 和它的时钟 <code>[(Sx, 2), (Sy, 1)]</code>.</p><p>接下来，假设另一个客户端读取 <code>D2</code>，并尝试更新它，写请求由另一个节点 <code>Sz</code> 处理。 现在，系统有 <code>D4</code>（<code>D2</code> 的后代），版本 clock 是 <code>[(Sx, 2), (Sz, 1)]</code>。如果一个节 点知道 <code>D1</code> 和 <code>D2</code>，那它收到 <code>D4</code> 和它的 clock 后，就可以断定 <code>D1</code> 和 <code>D2</code> 被同 一个新数据覆盖了，因此可以安全地删除 D1 和 D2。但如果一个节点只知道 <code>D3</code>，那它受 到 <code>D4</code> 后就看不出这两个版本有何因果关系。<strong>换言之，<code>D3</code> 和 <code>D4</code> 各自的改动并没 有反映在对方之中。因此这两个版本都应当被保留，然后交给客户端，由客户端（在下一次 读到时候）执行 semantic reconciliation</strong>。</p><p>现在，假设一些客户端把 <code>D3</code> 和 <code>D4</code> 都读到了（<code>context</code> 会同时显示 <code>D3</code> 和 <code>D4</code> ）。读操作返回的 <code>context</code> 综合了 <code>D3</code> 和 <code>D4</code> 的 clock，即 <code>[(Sx, 2), (Sy, 1), (Sz, 1)]</code>。如果客户端执行 reconciliation，并且节点 <code>Sx</code> 执行协调写（coordinates the write），<code>Sx</code> 会更新自己在 clock 中的序列号。最终新生成的数据 <code>D5</code> 的 clock 格式如下：<code>[(Sx, 3), (Sy, 1), (Sz, 1)]</code>。</p><h4 id="Vector-clock-的潜在问题"><a href="#Vector-clock-的潜在问题" class="headerlink" title="Vector clock 的潜在问题"></a>Vector clock 的潜在问题</h4><p>vector clock 的一个潜在问题是：<strong>如果有多个节点先后 coordinate 同一个对象 的写操作，那这个对象的 clock vector 会变得很长</strong>。但在实际中这不太可能发生，因为 写操作 coordination 只会由 preference list 中前 N 个 节点中的一个来执行。 只有在网络分裂或多台服务器挂掉的情况下，写操作才可能由非 preference list 前 N 个 节点来执行，导致 vector clock 变长。在这种情况下，应该要限制 vector clock 的长度 。</p><p>Dynamo 采用了一种 clock 截断方案（clock truncation scheme）： 另外保存一个和 <code>(node, counter)</code> 对应的时间戳，记录对应的节点最后一次更新该记录 的时间。当 vector clock 里的 <code>(node, counter)</code> 数量达到一个阈值（例如，10）时， 就删除最老的一项。</p><p>显然，这种截断方案会给 reconciliation 带来一定问题，因为截断后可能无法精确判断部 分后代的因果关系。但到目前为止，我们还没有在生产环境遇到这个问题，因此没有继续深 入研究下去。</p><h3 id="4-5-get-和-put-的执行过程"><a href="#4-5-get-和-put-的执行过程" class="headerlink" title="4.5 get() 和 put() 的执行过程"></a>4.5 <code>get()</code> 和 <code>put()</code> 的执行过程</h3><p><strong>在 Dynamo 中，任何存储节点都可以接受任何 key 的 <code>get</code> 和 <code>put</code> 操作请求</strong>。</p><blockquote><p>Any storage node in Dynamo is eligible to receive client get and put operations for any key.</p></blockquote><p>本节先介绍在无故障场景下这些操作是如何执行的，下一节介绍有故障的场景。</p><p><code>get</code> 和 <code>put</code> 操作由 Amazon 基础设施相关的请求处理框架发起，使用 HTTP。 客户端有两种选择：</p><ol><li>将请求路由到负载均衡器，由后者根据负载信息选择一个后端节点</li><li>使用能感知 partition 的客户端，直接将请求路由到某 coordinator 节点</li></ol><p>第一种方式的好处是使用客户端的应用不需要了解任何 Dynamo 相关的代码，第二种的好处 是延迟更低，因为跳过了一次潜在的转发步骤。</p><p><strong>负责处理读或写请求的节点称为 coordinator</strong>。<strong>通常情况下</strong>，这是 preference list 内前 N 个节点中的<strong>第一个节点</strong>。如果请求是经过负载均衡器转发的，那这个请求 可能会被转发到环上的任意一个节点。在这种情况下，如果收到请求的节点不是 preference list 的 前 N 个节点中的一个，那它就不会处理这个请求，而是将其转发到 preference list 前 N 个节点中的第一个节点。</p><p><strong>读或写操作需要 preference list 中前 N 个节点处于健康状态</strong>，如果有 down 或不可 访问状态的节点，要跳过。如果所有节点都是健康的，那就取 preference list 的前 N 个 节点。如果发生节点故障或网络分裂，优先访问 preference list 中编号较小的节点。</p><h4 id="读写操作仲裁算法"><a href="#读写操作仲裁算法" class="headerlink" title="读写操作仲裁算法"></a>读写操作仲裁算法</h4><p>为了保证副本的一致性，Dynamo 使用了一种类似仲裁系统（quorum systems）的一致性协议。 这个协议有两个配置参数：<code>R</code> 和 <code>W</code>：</p><ul><li><code>R</code>：允许执行一次读操作所需的最少投票者</li><li><code>W</code>：允许执行一次写操作所需的最少投票者</li></ul><p><strong>设置 <code>R + W &gt; N</code><strong>（<code>R</code> 或 <code>W</code> 至少有一个超过半数 N/2，译者注），</strong>就得到了一 个类似仲裁的系统</strong>。</p><p>在这种模型下，一次 <code>get</code> （或 <code>put</code>）的延迟由 <code>R</code>（或 <code>W</code>）个<strong>副本中最慢的一个决 定</strong>。因此，为了降低延迟，<code>R</code> 和 <code>W</code> 通常设置的比 <code>N</code> 小。</p><h4 id="写和读过程"><a href="#写和读过程" class="headerlink" title="写和读过程"></a>写和读过程</h4><p>当收到一个 <code>put()</code> 请求后，coordinator 会为新版本生成 vector clock，并将其保存到 节点本地；然后，将新版本（及对应的新 vector clock）发送给 N 个排在最前面的、可到 达的节点。只要有至少 <code>W-1</code> 个节点返回成功，这次写操作就认为是成功了。</p><p>类似地，对于一次 <code>get()</code> 请求，coordinator 会向排在最前面的 N 个（highest-ranked ）可访问的节点请求这个 key 对应的数据的版本，等到 R 个响应之后，就将结果返回给客 户端。如果 coordinator 收集到了多个版本，它会<strong>将所有它认为没有因果关系的版本返 回给客户端</strong>。客户端需要对版本进行 reconcile，合并成一个最新版本，然后将结果写回 Dynamo。</p><h3 id="4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）"><a href="#4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）" class="headerlink" title="4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）"></a>4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）</h3><p>如果使用传统仲裁算法，Dynamo 无法在服务器宕机或网络分裂的时候仍然保持可用，而且 在遇到最简单故障情况下，持久性（durability）也会降低。</p><p>因此，Dynamo 采用了一种<strong>宽松的仲裁机制</strong>（sloppy quorum）：<strong>所有读和写操作在 preference list 的前 N 个健康节点上执行</strong>；注意这 N 个节点不一定就是前 N 个节点， 因为遇到不健康的节点，会沿着一致性哈希环的顺时针方向顺延。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2-20220130214812411.png" alt="img"></p><p>图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）</p><p>以图 2 的配置为例，其中 N=3。<strong>如果 A 临时不可用，正常情况下应该到达 A 的写请求就 会发送到 D</strong>。这样设计是为了保证期望达到的可用性和持久性。<strong>发送到 D 的副本的元 数据中会提示（hint）这个副本本来应该发送给谁</strong>（这里是 A），然后这个数据会被 D 保存到本地的一个独立数据库中，并且有一个<strong>定期任务不断扫描，一旦 A 可用了，就将 这个数据发送回 A</strong>，然后 D 就可以从本地数据库中将其删除了，这样系统内的副本数还 是保持不变。</p><p>使用这种 hinted handoff 的方式，Dynamo <strong>保证了在节点或网络发生短时故障时读和写 操作不会失败</strong>。希望可用性最高的应用可以将 <code>W</code> 设为 1，这样可以保证只要一个节点 完成写，这次写操作就被系统接受了。在这种情况下，除非全部节点都不可用，否则写操作 就不会被拒绝。但实际上，大部分 Amazon 的应用都是设置一个比 1 大的值，以达到期望 的持久性（durability）等级。我们会在第 6 节更深入地讨论 <code>N</code>、<code>R</code> 和 <code>W</code> 的配置。</p><p><strong>高度可用的存储系统必须能够处理整个数据中心挂掉的情况。</strong>掉电、制冷失效、网络故 障以及自然灾难都会导致整个数据中心发生故障。Dynamo 可以配置<strong>向多个数据中心同步 副本</strong>，只要<strong>将 preference list 里的节点分散到不同数据中心</strong>。这些数据中心之间 通过高速网络互连。这使得我们可以在整个数据中心挂掉的情况下仍然可以提供服务。</p><h3 id="4-7-持久（permanent）故障处理-副本跨数据中心同步"><a href="#4-7-持久（permanent）故障处理-副本跨数据中心同步" class="headerlink" title="4.7 持久（permanent）故障处理: 副本跨数据中心同步"></a>4.7 持久（permanent）故障处理: 副本跨数据中心同步</h3><p>在节点成员变动较小、节点故障只是短时的情况下，hinted handoff 方式工作良好。但也 有一些场景，在 hinted 副本移交给原本应该存储这个副本的节点之前，该副本就不可用了 。为了解决这个问题，以及其他威胁到持久性（durability）的场景，Dynamo 实现了一种 <strong>逆熵（副本同步）协议</strong>来<strong>保证副本是同步的</strong>。</p><blockquote><p>To handle this and other threats to durability, Dynamo implements an anti-entropy (replica synchronization) protocol to keep the replicas synchronized.</p></blockquote><h4 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h4><p>为了实现<strong>快速检测副本之间的不一致性，以及最小化转移的数据量</strong>，Dynamo 使用了 Merkle trees [13].</p><p>一个 Merkle tree 就是一个<strong>哈希树</strong>，其叶子节点是 <strong>key 对应的 value 的哈希值</strong>。 <strong>父节点是其子节点的哈希</strong>。</p><p>Merkle tree 的主要优点是：</p><ul><li>每个分支都可以独立查看（check），节点无需下载整棵树或者整个数据集</li><li>减少检查副本一致性时所需传输的数据量</li></ul><p><strong>例如，如果两棵树的根节点的哈希值相同，那这两棵树的叶子节点必然相同，这两台 node 之间就无需任何同步</strong>；否则，就说明两台 node 之间的某些副本是不同的，这种情 况下两台 node 就需要交换树的子节点哈希值，直到到达叶子节点，就找到了未同步（out of sync）的 key。Merkle tree 最小化了同步时需要转移的数据量，<strong>减少了逆熵过程中 读取磁盘的次数</strong>。</p><p>Dynamo 使用 Merkle tree 实现<strong>逆熵的过程</strong>如下：<strong>每个节点为每段 key range（一台 虚拟节点所覆盖的 key 的范围）维护了一棵单独的 Merkle tree</strong>。</p><p>这使得节点之间可以比较 key range，确定其维护的 range 内的 key 是否是最新的（up to date）。在这种方案中，两个节点会交换他们都有的 key range 所对应的 Merkle tree 的 根节点。然后，基于前面提到的树遍历方式， node 可以判断是是否有不一致，如果有，就 执行同步。</p><p>这种方案的缺点是：<strong>每当有节点加入或离开系统时，一些 key range 会变，因此对应的 tree 需要重新计算</strong>。我们会在 6.2 节介绍如何通过改进的 partitioning scheme 解决 这个问题。</p><h3 id="4-8-节点成员（Membership）管理和故障检测"><a href="#4-8-节点成员（Membership）管理和故障检测" class="headerlink" title="4.8 节点成员（Membership）管理和故障检测"></a>4.8 节点成员（Membership）管理和故障检测</h3><h4 id="4-8-1-哈希环（ring）成员"><a href="#4-8-1-哈希环（ring）成员" class="headerlink" title="4.8.1 哈希环（ring）成员"></a>4.8.1 哈希环（ring）成员</h4><p>在 Amazon 的环境中，节点服务不可用（故障或维护导致的）通常情况下持续时间都很短， 但也存在中断比较长的情况。一个节点服务中断并不能说明这个节点永久性的离开了系统， 因此不应该导致系统对 partition 进行再平衡（rebalance），或者修复无法访问的副本。 与此类似，无意的手动操作可能导致新的节点加入到 Dynamo。</p><p>因此，为了避免以上这些问题，我们决定<strong>使用显式机制（explicit mechanism）来向 Dynamo Ring 增删节点</strong>。管理员通过命令行或 web 方式连接到 Dynamo node，然后下发 一个成员变更命令，来将这个 node 添加到 ring 或从 ring 删除。负责处理这个请求的 node 将成员变动信息和对应的时间写入持久存储。成员变动会形成历史记录，因为一个节 点可能会多次从系统中添加和删除。Dynamo <strong>使用一个 gossip-based 的算法通告（ propagete）成员变动信息</strong>，维护成员的一份最终一致视图。</p><p>每个节点每秒会随机选择另一个节点作为对端，这两个节点会高效地 reconcile 它们的成 员变动历史。</p><p><strong>一个节点第一次起来时，首先会选择它的 token 集合</strong>（一致性哈希空间内的虚拟节点 ），然后<strong>将节点映射到各自的 token 集合</strong>。</p><blockquote><p>When a node starts for the first time, it chooses its set of tokens (virtual nodes in the consistent hash space) and maps nodes to their respective token sets.</p></blockquote><p><strong>映射关系会持久存储到磁盘上</strong>，初始时只包含本节点（local node）和 token set。存 储在不同 Dynamo 节点上的<strong>映射关系，会在节点交换成员变动历史时被 reconcile</strong>。因 此，partitioning 和 placement（数据的放置信息）也会通过 gossip 协议进行扩散，<strong>最 终每个节点都能知道其他节点负责的 token 范围</strong>。</p><blockquote><p>The mappings stored at different Dynamo nodes are reconciled during the same communication exchange that reconciles the membership change histories.</p><p>Therefore, partitioning and placement information also propagates via the gossip-based protocol and each storage node is aware of the token ranges handled by its peers.</p></blockquote><p>这<strong>使得每个节点可以将一个 key 的读/写操作直接发送给正确的节点</strong>进行处理。</p><h4 id="4-8-2-系统外部发现（External-Discovery）和种子节点"><a href="#4-8-2-系统外部发现（External-Discovery）和种子节点" class="headerlink" title="4.8.2 系统外部发现（External Discovery）和种子节点"></a>4.8.2 系统外部发现（External Discovery）和种子节点</h4><p>以上机制<strong>可能导致 Dynamo ring 在逻辑上临时分裂</strong>。</p><p>例如，管理员先联系 node A，将 A 将入 ring，然后又联系 node B 加入 ring。在这种情 况下，A 和 B 都会认为它们自己是 ring 的成员，但不会立即感知到对方。</p><p><strong>为了避免逻辑分裂，我们会将一些 Dynamo 节点作为种子节点</strong>。种子节点是通过外部机 制（external mechanism）发现的，所有节点都知道种子节点的存在。因为所有节点最终都 会和种子节点 reconcile 成员信息，所以逻辑分裂就几乎不可能发生了。</p><p>种子或者从静态配置文件中获取，或者从一个配置中心获取。通常情况下，种子节点具有普 通节点的全部功能。</p><h4 id="4-8-3-故障检测"><a href="#4-8-3-故障检测" class="headerlink" title="4.8.3 故障检测"></a>4.8.3 故障检测</h4><p>故障检测在 Dynamo 中用于如下场景下跳过不可达的节点：</p><ul><li><code>get()</code> 和 <code>put()</code> 操作时</li><li>转移 partition 和 hinted replica 时</li></ul><p>要避免尝试与不可达节点通信，一个<strong>纯本地概念（pure local notion）的故障检测</strong>就 足够了：节点 B 只要没有应答节点 A 的消息，A 就可以认为 B 不可达（即使 B 可以应答 C 的消息）。</p><p>在客户端有持续频率的请求的情况下，Dynamo ring 的节点之间就会有持续的交互；因此只 要 B 无法应答消息，A 可以很快就可以发现；在这种情况下，A 可以选择和与 B 同属一个 partition 的其他节点来处理请求，并定期地检查 B 是否活过来了。</p><p><strong>在没有持续的客户端请求的情况下，两个节点都不需要知道另一方是否可达。</strong></p><blockquote><p>In the absence of client requests to drive traffic between two nodes, neither node really needs to know whether the other is reachable and responsive.</p></blockquote><p><strong>去中心化故障检测协议使用简单的 gossip 风格协议，使得系统内的每个节点都可以感知 到其他节点的加入或离开</strong>。想详细了解去中心化故障检测机制及其配置，可以参考 [8]。</p><p>Dynamo 的早期设计中使用了一个去中心化的故障检测器来维护故障状态的全局一致视图 （globally consistent view of failure state）。</p><p>后来我们发现，我们<strong>显式的节点加入和离开机制</strong>使得这种全局一致视图变得多余了。因 为节点的真正（permanent）加入和离开消息，依靠的是我们的显式添加和删除节点机制， 而临时的加入和离开，由于节点之间的互相通信（转发请求时），它们自己就会发现。</p><h3 id="4-9-添加-移除存储节点"><a href="#4-9-添加-移除存储节点" class="headerlink" title="4.9 添加/移除存储节点"></a>4.9 添加/移除存储节点</h3><p>当一个新节点 <code>X</code> 加入到系统后，它会<strong>获得一些随机分散在 ring 上的 token</strong>。对每 个分配给 <code>X</code> 的 key range，当前可能已经有一些（小于等于 <code>N</code> 个）节点在负责处理了 。因此,将 key range 分配给 <code>X</code> 后，这些节点就不需要处理这些 key 对应的请求了，而 要将 keys 转给 <code>X</code>。</p><p>考虑一个简单的情况：<code>X</code> 加入 图 2 中 <code>A</code> 和 <code>B</code> 之间。这样，<code>X</code> 就负责处理落到 <code>(F, G], (G, A] and (A, X]</code> 之间的 key。结果，<code>B</code>、<code>C</code> 和 <code>D</code> 节点就不需负责相应 range 了。因此，在收到 <code>X</code> 的转移 key 请求之后，**<code>B</code>、<code>C</code> 和 <code>D</code> 会向 X 转移相 应的 key**。当移除一个节点时，key 重新分配的顺序和刚才相反。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/2-20220130214820871.png" alt="img"></p><p>图 2</p><p>我们的实际运行经验显示，这种方式<strong>可以在存储节点之间保持 key 的均匀分布</strong>，这对 于保证延迟需求和快速 bootstrapping 是非常重要的。另外，在源和目的节点之间加了确 认（转移），可以保证不会转移重复的 key range。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>Dynamo 中的<strong>每个存储节点上主要有三个组件</strong>，都是用 Java 实现的：</p><ul><li>request coordination（请求协调）组件</li><li>成员验证和故障检测组件</li><li>本地持久存储引擎</li></ul><h3 id="本地存储引擎"><a href="#本地存储引擎" class="headerlink" title="本地存储引擎"></a>本地存储引擎</h3><p>Dynamo 的本地持久存储组件支持以插件的方式使用不同的存储引擎。在使用的引擎包括：</p><ul><li>Berkeley Database (BDB) Transactional Data Store2</li><li>BDB Java Edition</li><li>MySQL</li><li>an in-memory buffer with persistent backing store</li></ul><p>将其设计为可插拔的原因是：<strong>为不同应用访问类型选择最合适的存储引擎</strong>。例如，BDB 通常用于处理几十 KB 大小的对象，而 MySQL 可以处理更大的对象。应用可以根据它们的 对象大小分布选择合适的持久化引擎。</p><p>我们生产环境的 Dynamo 大部分使用的都是 BDB Transactional Data Store。</p><h3 id="请求协调"><a href="#请求协调" class="headerlink" title="请求协调"></a>请求协调</h3><p>request coordination 组件构建在一个事件驱动的消息系统之上，其中的消息处理 pipeline 分为多个阶段，和 SEDA 架构类似 [24]。所有通信都基于 Java NIO channel 实现。</p><p><strong>coordinator 代替客户端执行读和写请求</strong>：读操作时会从一个或多个节点收集数据，写操作 时会向一个或多个节点存储数据。每个客户端请求都会<strong>在收到这个请求的节点上创建一个状 态机</strong>。这个状态机包含了识别 key 对应的节点、发送请求、等待响应、重试、处理响应和 组合响应返回给客户端等所有逻辑。</p><h4 id="read-coordination"><a href="#read-coordination" class="headerlink" title="read coordination"></a>read coordination</h4><p>每个状态机处理且只处理一个客户端请求。例如，一个读操作实现了包含如下步骤的状态机：</p><ol><li>发送读请求给节点</li><li>等待所需的最少数量响应</li><li>如果在规定的上限时间内收到的响应数量太少，认定请求失败</li><li>否则，收集对象的所有版本，确定应该返回哪些</li><li>如果打开了版本化（versioning）配置，执行 syntactic reconciliation，生成一个不 透明的写上下文（context），其中包含了合并之后的版本对应的的 vector clock</li></ol><p>为了描述的简单，以上没有提及故障处理和重试的步骤。</p><p><strong>读操作的响应发送给调用方之后，状态机会继续等待一小段时间，接收可能的有效响应</strong>（ outstanding responses，例如最小数量响应之外的其他节点的响应，译者注）。</p><p>如果返回中有过期版本（stale version），coordinator 就需要合并版本，并将最新版本 更新回这些节点。这个过程称为<strong>“读时修复”（read repair）</strong>，因为它<strong>在一个乐观的 时间点</strong>（at an opportunistic time）<strong>修复了那些错过了最新更新的副本</strong>（replicas that have missed a recent update），<strong>减少了逆熵协议的工作</strong>（本来应该是稍后由逆 熵协议做的）。</p><h4 id="write-coordination"><a href="#write-coordination" class="headerlink" title="write coordination"></a>write coordination</h4><p>前面提到过，写请求是由 preference list 内的前 N 个节点中的任意一个 coordinate 的 。总是让 N 个节点中的第一个来 coordinate 有一些好处，例如可以使得在同一个地方完 成写操作的顺序化（serializing all writes），但是，这种方式也有缺点：它会导致不均 匀的负载分布，损害 SLA。这是因为对象请求并不是均匀分布的（request load is not uniformly distributed across objects）。</p><p>为了解决这个问题，<strong>preference list 内的所有 N 个节点都可以 coordinate 写操作</strong>。 而且，因为一个写操作之前通常有一个读操作，因此写操作的 coordinator 都选择为：<strong>前 一次读操作返回最快的那个节点</strong>，这个信息存储在读操作返回的上下文中。</p><p>这项优化还使在下一次读取时，前一次读操作选中的存储这个数据的节点更容易被选中，提 高了“读取刚写入的数据”（“read-your-writes”）的概率。</p><blockquote><p>This optimization enables us to pick the node that has the data that was read by the preceding read operation thereby increasing the chances of getting “read-your-writes” consistency.</p></blockquote><p>同时，还降低了请求处理性能的抖动性，提高了 <code>P99.9</code> 性能。</p><h2 id="6-测试结果及学到的经验"><a href="#6-测试结果及学到的经验" class="headerlink" title="6. 测试结果及学到的经验"></a>6. 测试结果及学到的经验</h2><p>Dynamo 被几种不同类型的服务使用，每种场景下的配置不同。这些不同体现在 vesion reconciliation 逻辑和读/写仲裁特点上。几种主要的场景：</p><ul><li><strong>业务逻辑相关的 reconciliation</strong>：这种场景使用很广。每个数据对象都会复制到不同节 点上，发生<strong>版本冲突时由应用执行自己的 reconciliation 逻辑</strong>。前文提到的购物 车服务就是一个典型的例子，应用自己来合并冲突的购物车版本</li><li><strong>基于时间戳的 reconciliation</strong>：和第一种的不同仅仅是 reconciliation 机制。当 发生版本冲突时，Dynamo 根据<strong>“最后一次写胜出”</strong>（last write wins）机制，例如， 选择时间戳最近的一个版本作为最终版本。一个例子是维护客户 session 信息的服务</li><li><strong>高性能读引擎</strong>：虽然 Dynamo 设计为永远可写（always writeable） 数据仓库, 但 一些服务通过<strong>对 Dynamo 的仲裁特性进行调优（tuning），而将其作为一个高性能读引 擎使用</strong>。典型情况下，这类服务有很高的读频率和很小的写频率。<strong>在这种配置中， <code>R</code> 一般设为 1，<code>W</code> 设为 <code>N</code><strong>。对于这些服务，Dynamo 提供了 partition 和数据跨 多节点复制的能力，因而提供了增量可扩展性。</strong>数据的权威持久缓存</strong>（the authoritative persistence cache for data）存储在更重量级的后端存储中（more heavy weight backing stores）。<strong>维护产品目录和促销商品的服务</strong>会用到这种类型 的 Dynamo 配置</li></ul><p>Dynamo 的最大优势是：<strong>客户端应用可以通过对 N、R 和 W 三个参数进行调优来达到期 望的性能、可用性和持久性等级</strong>。</p><blockquote><p>The main advantage of Dynamo is that its client applications can tune the values of N, R and W to achieve their desired levels of performance, availability and durability.</p></blockquote><p>例如，N 的大小决定了每个对象的持久性。Dynamo 用户最常用的 N 配置是 3。</p><p>W 和 R 的值会影响对象的可用性、持久性和一致性。例如，如果 W 设为 1，那只要系统还 有一台正常的 node，写操作就不会被拒绝。但是，太小的 W 和 R 配置会增加不一致的风 险，因为一次写操作即使在没有大多数副本都写成功的情况下，还是会给客户端返回成功。 这也导致存在一个<strong>风险窗口</strong>（vulnerability window）：<strong>一次写操作即使只在少量节 点上完成了持久化，也会向客户端返回成功</strong>。</p><p>传统观点认为，持久性和可用性是相伴而生（go hand in hand）的，但在这里不一定成立。 例如，增加 W 就会减小持久性的风险窗口；但是，这可能会增加请求被拒绝的概率（因此 降低了可用性），因为这种情况下需要更多的健康存储节点来处理写请求。</p><p>我们**最常用的 Dynamo 集群 <code>(N,R,W)</code> 配置是 <code>(3,2,2)</code>**。这个配置符合我们所需的 性能、持久性、一致性和可用性（SLA）等级。</p><p>本节所有的数据都是从一套线上 Dynamo 环境获得的，配置是 <code>(3,2,2)</code>， 有几百台节点（a couple hundred nodes），配置利用到了异构硬件信息。</p><p>之前我们提到，每套 Dynamo 的节点都是跨数据中心部署的，这些数据中心之间通过高速网 络互联。执行一次成功的 <code>get</code> （或 <code>put</code>）需要 <code>R</code> （或 <code>W</code>）个节点向 coordinator 发送响应，因此很明显，数据中心之间的时延会影响到响应时间，因此在选择节点（以及它 所在的数据中心的位置）的时候要特别注意，以保证能满足应用期望的 SLA。</p><h3 id="6-1-性能和持久性的平衡"><a href="#6-1-性能和持久性的平衡" class="headerlink" title="6.1 性能和持久性的平衡"></a>6.1 性能和持久性的平衡</h3><p>虽然 Dynamo 的首要设计目标是一个高可用数据仓库，但性能指标在 Amazon 也同样重要。 前面提到过，为了提供一致的用户体验，Amazon 的服务会设置一个很高的用百分比衡量的 （例如 <code>P99.9</code> 或 <code>P99.99</code>）性能指标。典型的 SLA 指标是：读和写操作的 <code>P99.9</code> 要 在 <code>300ms</code> 以内成。</p><p>由于 Dynamo 是在<strong>通用硬件</strong>上运行的，和高端企业级服务器相比，<strong>I/O 吞吐性能要差 很多</strong>，因此提供一致的高性能读写并不是一项简单的工作。而且，每次读/写操作都要涉 及多台节点，给这项工作带来了更大的挑战性，因为<strong>最终的性能受限于最慢的那个副本所 在的节点</strong>。</p><h4 id="通用配置下的性能"><a href="#通用配置下的性能" class="headerlink" title="通用配置下的性能"></a>通用配置下的性能</h4><p>图 4 显示了 30 天内 Dynamo 的读和写操作延迟平均值和 <code>P99.9</code>：</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/4.png" alt="img"></p><p>图 4 2006 年 12 月峰值请求季的读写延迟平均值和 P99.9。 X 轴一个刻度 12 小时。延迟走势和每天的请求量走势一致，延迟的 P99.9 比平均值要大一个数量级。</p><p>从图上可以看出，延迟曲线每天的走势（diurnal pattern）都类似，这和平台每天的请求 量走势也是一致的（例如，白天和晚上的请求量明显不一样）。另外，写延迟明显高于读延 迟，因为<strong>写操作永远需要访问磁盘</strong>。另外，**<code>P99.9</code> 大约为 <code>200ms</code>，比平均值高一 个数量级**。这是因为 P99.9 有很多影响因素，例如请求负载变化、对象大小和 locality patterns。</p><h4 id="低延迟配置下的性能"><a href="#低延迟配置下的性能" class="headerlink" title="低延迟配置下的性能"></a>低延迟配置下的性能</h4><p>以上性能对很多服务来说都足够了，但有少数面向用户的服务，它们对性能有更高的要求。 对于这种情况，Dynamo 提供了<strong>牺牲持久性换性能</strong>的能力。具体来说，每个存储节点会 <strong>在主内存中维护一个对象缓存</strong>（object buffer），写操作将数据存储到缓存直接返回， 另有一个独立的写线程定期将数据写入磁盘。读操作会先检查缓存中是否有，如果有，就直 接从缓存读，从而避免了访问存储引擎。</p><p>这项优化可以**将峰值流量期间的 P99.9 降低到原来的 <code>1/5</code>**，即使只使用一个很小的 、只能存放 1000 个对象的缓存，见图 5。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/5.png" alt="img"></p><p>图 5 带缓存和不带缓存的 P99.9 性能对比，时间跨度 24 小时，X 轴一个刻度一个小时</p><p>另外，从图中可以看到，缓存写（write buffering）可以对百分比延迟进行平滑。显然， 这种方案中持久性和性能之间做了折中：一台<strong>节点挂掉会导致缓存里还未落盘的数据丢失</strong>。 为了减小这种风险，写操作进行了优化（refine），由 coordinator <strong>从 <code>N</code> 个副本中选择 一个进行持久化写入</strong>（durable write）。因为 coordinator 只等待 <code>W</code> 个写操作，因此整 体的写操作不受这次写盘操作的影响。</p><blockquote><p>以上优化的意思是，每次写操作到达 coordinator 时，它会将请求转发给相应个节点， 这些节点都是写完内存 buffer 就直接返回的；除此之外，coordinator 还会挑一个节点 进行持久写入，跟其他节点的写是并行进行的，这样可以降低其他节点挂掉时内存数据丢 失的风险。由于 coordinator 只等待 W 个结果就返回了，因此虽然这个执行持久写的节 点（相对）很慢，但 coordinator 并不会依赖它的结果才返回，因此文中说对写性能来 说是没有影响的，译者注。</p></blockquote><h3 id="6-2-均匀负载分布（Uniform-Load-distribution）"><a href="#6-2-均匀负载分布（Uniform-Load-distribution）" class="headerlink" title="6.2 均匀负载分布（Uniform Load distribution）"></a>6.2 均匀负载分布（Uniform Load distribution）</h3><p>Dynamo 通过一致性哈希将它的 key 空间进行 partition，保证负载分布的均匀性。 只要 key 的访问不是极度不均衡，均匀的 key 分布就可以帮助我们实现负载的均衡分布。 特别地，即使出现了明显的 key 访问不平衡的情况，只要这些 key 足够多，Dynamo 也能 保证这些 key 在后端节点之间是均衡分散的。 本节介绍 Dynamo 中的负载不平衡问题，几种解决策略及其对负载分布的影响。</p><p>为了研究负载不平衡（load imbalance）以及它和请求负载（request load）的相关性，我 们测量了 24 个小时内每台节点收到的请求量，以 30 分钟作为一个点。在规定的时间内， 只要节点收到的请求量偏离平均值的程度不超过一个阈值（例如，15%），这台节点就认为 是平衡的（inbalance）；否则，就是不平衡的（out of balance）。</p><p>图 6 展示了不平衡的节点所占的比例（imbalance ratio）：</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/6.png" alt="img"></p><p>图 6 不平衡节点比例，及其负载（请求数），X 轴一个刻度 30 分钟</p><p>作为参考，图中也画出了这段期间系统的总负载（请求量）。从图中可以看出，随着请求量 的上升，不平衡的比例在下降。例如，低负载期间的不平衡比例高达 20%，而高负载期间降 到了 10%。直观上可以解释：随着负载（请求量）的上升，大量的活跃 key 的访问会均匀 的分发到节点，导致负载平衡分布。而低峰期间（请求量只有峰值的 1/8），只有很少的 活跃 key 访问，导致负载非常不平衡。</p><p>本节接下来介绍 Dynamo 的 partition scheme 是如何随时间演进的，以及它对负载分布的 影响。</p><h4 id="策略-1：每个节点-T-个随机-token，按-token-值分散"><a href="#策略-1：每个节点-T-个随机-token，按-token-值分散" class="headerlink" title="策略 1：每个节点 T 个随机 token，按 token 值分散"></a>策略 1：每个节点 T 个随机 token，按 token 值分散</h4><p>这是生产环境最早部署的策略（在 4.2 节介绍过了）。</p><p>在这种策略中，会<strong>给每个节点（从哈希空间）随机分配 T 个 token</strong>。所有节点的 token 在哈希空间中是有序的（按 token 值）。<strong>两个相邻的 token 定义一个范围</strong>（ key range）。最后一个 token 和第一个 token 收尾相连。</p><p>因为 token 是随机选择的，因此范围有大有小。<strong>当有节点加入或离开系统的时，token 集合会变化，导致范围也会跟着变</strong>。注意，<strong>每个节点用来维护成员信息所需的空间随着 系统中的节点数线性增长</strong>。</p><p>这种策略在使用过程中发现如下几个问题。</p><p>首先，一个<strong>新节点加入到系统后，需要从其他节点“偷”出它要用的 key range</strong>。 这会导致那些需要将一部分 key range 移交给新节点的节点，<strong>扫描它们全部的本地持久存 储</strong>，以过滤出所需的数据。在生产环境环境执行这种扫描操作是很棘手的，因为它 会<strong>占用大量磁盘 IO</strong>；为了不影响正常的请求处理，需要把这个任务放到后台。 这要求我们只能将新节点加入集群的任务调到最低优先级。这带来的后果就是，<strong>节点上线的 速度非常慢</strong>，尤其是购物高峰季每天处理百万请求时，上线一台节点需要花费几乎一整天时 间。</p><p>第二，一个节点加入或离开系统时，很多节点负责的 key range 会发生变化，对应的 <strong>Merkle tree 需要重新计算</strong>。对于生产环境来说，这也是一项不小的工作。</p><p>最后，由于 key range 的随机性，<strong>无法快速地对整个 key 空间进行快照</strong>（snapshot）。 这使得存档（备份）工作变得复杂。在这种方案下，我们进行一次快照需要分别从所有节 点获取 key，非常低效。</p><p><strong>这种策略的根本问题出在：数据的 partition 和 placement 方案混在了一起</strong>（ intertwined）。例如，在某些场景下希望通过增加节点应对请求量的上涨，但是在这种方 案中，<strong>无法做到添加新节点不影响数据 partition</strong>。</p><p>理想情况下，应该使用独立的数据 partition 和 placement 方案。为此，我们考察了下面的几种方案。</p><h4 id="Strategy-2-每个节点-T-个随机-token，平均分散"><a href="#Strategy-2-每个节点-T-个随机-token，平均分散" class="headerlink" title="Strategy 2: 每个节点 T 个随机 token，平均分散"></a>Strategy 2: 每个节点 T 个随机 token，平均分散</h4><p>这种策略将哈希空间分为 <code>Q</code> 个相同大小的 partition/range，每个节点分配 <code>T</code> 个 随 机 token。<code>Q</code> 的选择通常要满足：<code>Q &gt;&gt; N</code> 和 <code>Q &gt;&gt; S*T</code>（<code>&gt;&gt;</code>：远大于，译者注）， 其中 <code>S</code> 是系统中节点的数量。</p><p>在这种策略中，token 仅用于<strong>哈希空间的值映射到有序节点列表</strong>的过程，并<strong>不影响数 据 partition</strong>。</p><p>一个 partition 会放在从该 partition 末尾开始<strong>沿顺时针方向得到的前 N 个独立节点</strong>。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/7.png" alt="img"></p><p>图 7 三种策略中 key 的 partition 和 placement。N=3，A、B、 C 是 key k1 的 preference list 中的三个独立节点。阴影区域表示 preference list 是 [A,B,C] 的 key range，箭头表示不同节点对应的 token 位置</p><p>图 7 展示了 <code>N=3</code> 时这种策略的示意图。</p><p>这种策略的主要优点：</p><ol><li>将数据的 partition 和 placement 解耦</li><li>提供了在运行时更改 placement 方案的能力</li></ol><h4 id="Strategy-3-每个节点-Q-S-个-token-平均分散"><a href="#Strategy-3-每个节点-Q-S-个-token-平均分散" class="headerlink" title="Strategy 3: 每个节点 Q/S 个 token, 平均分散"></a>Strategy 3: 每个节点 <code>Q/S</code> 个 token, 平均分散</h4><p>和策略 2 类似，策略 3 也将哈希空间等分为 <code>Q</code> 个 partition，而且 placement 从 partition 解耦。不同的是，每个节点会分配 <code>Q/S</code> 个 token，其中 <code>S</code> 是系统中的节点 数量。</p><p>当一个节点离开时，它的 token 会随机地分配给其他节点，因此 <code>Q/S</code> 个 token 的特性 还是能成立。类似地，当一个节点加入系统时，它会从其他节点“偷”一些 token 过来，同 时保证 <code>Q/S</code> 特性仍然成立。</p><h4 id="几种策略的性能对比"><a href="#几种策略的性能对比" class="headerlink" title="几种策略的性能对比"></a>几种策略的性能对比</h4><p>对一套 <code>S=30</code>，<code>N=3</code> 的 Dynamo 测试了以上三种策略。需要说明的是，公平地比较这三 种策略的性能是很难做到的，因为它们有各自特殊的配置可以调优。例如，策略 1 的负载 分布特性取决于 token 的数量（例如 <code>T</code>），而策略 3 取决于 partition 的数量（例如 <code>Q</code>）。</p><p>一种比较公平的方式是：<strong>所有的策略都使用相同大小的空间存储成员信息时，测量它们的 负载分布倾斜度</strong>（skew in load distribution）。例如，策略 1 中每个节点需要为环上 的全部节点维护各自的 token 位置，而策略 3 中每个节点需要维护系统分配给每个节点的 partition 信息。</p><p>实验中我们将通过改变相关的参数（<code>T</code> 和 <code>Q</code>）来评估这三种策略。测试每个节点需要维 护的成员信息的大小（size）不同时，几种策略的<strong>负载均衡效率</strong>。其中负载均衡效率（ load balancing efficiency）的定义是：每个节点平均处理的请求数 <code>/</code> 负载最高的节点处 理的请求数。</p><p>结果如图 8 所示。</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/8.png" alt="img"></p><p>图 8 三种策略的负载均衡效率对比，30 个几点，N=3，每个节点维护相同大小的元数据</p><p>如图所示，<strong>策略 3 取得了最好的负载均衡性能，策略 2 最差</strong>。在某段较短的时期内， 策略 2 充当了将线上的一些 Dynamo 从策略 1 迁移到策略 3 的过渡策略。</p><p>和 策略 1 相比，策略 3 性能更好，而且减少了每个节点所需维护的成员信息的大小。</p><p><strong>虽然存储这些成员信息并不会占用太多存储，但是，节点通过 gossip 协议定期地将成员 信息发送给其他节点</strong>（gossip the membership information periodically），因此<strong>保 持这些信息越紧凑越好。</strong></p><p>此外，策略 3 部署更加方便，原因包括：</p><ol><li><strong>bootstrap 和恢复更快</strong>：因为 <strong>partition 范围是固定的</strong>，因此可以将其存放 到<strong>单独的文件</strong>，这样下次 relocation 的时候可以直接将<strong>整个文件</strong>发送给其他节点 （避免了为了定位特点的数据而进行的<strong>随机访问</strong>）。简化了 bootstrap 和恢复的过程</li><li><strong>易于存档</strong>：定期对数据集（dataset）进行存档是 Amazon 存储服务的硬性要求之一 。在策略 3 中，存档过程会变得更容易，因为 partition 文件可以单独存档。作为对 比，在策略 1 中，token 是随机选取的，存档的时候需要从所有节点分别获取它们存储 的 key 信息，通常非常低效，速度也很慢。</li></ol><p>策略 3 的不足：<strong>变更节点成员时，需要 coordination</strong>，以保持平均分配所需的前提特 性（preserve the properties required of the assignment）。</p><h3 id="6-3-版本分叉：什么时候？有多少？"><a href="#6-3-版本分叉：什么时候？有多少？" class="headerlink" title="6.3 版本分叉：什么时候？有多少？"></a>6.3 版本分叉：什么时候？有多少？</h3><p>我们已经提到过，Dynamo 是通过牺牲一些一致性（consistency）来换可用性（ availability）的。要准确地理解不同类型的一致性失败带来的影响需要考虑很多因素：故障时 常（outage length）、失败类型（type of failures）、组件可靠性、负载等等。 详细地展示这些数据超出了本文范围。但是，本节可以提供一个很好的总结指标：一份真实 的生产环境里<strong>应用看到的分叉版本数量</strong>（number of divergent versions seen by the application）。</p><p>有两种情况会出现数据版本的分叉：</p><ol><li>遇到节点失败、数据中心故障或网络分裂等故障场景</li><li>同一数据对象的大量并发写操作，不同节点都在 coordinating 写操作</li></ol><p>从使用性（usability）和效率的角度，最好在任何时间都保证分叉的版本数尽量小。</p><p>如果冲突的版本无法仅通过向量时钟做句法调和（syntactically reconcile），那就需要 将它们交给业务逻辑，执行语义调和（semantic reconciliation）。</p><blockquote><p>If the versions cannot be syntactically reconciled based on vector clocks alone, they have to be passed to the business logic for semantic reconciliation.</p></blockquote><p><strong>Semantic reconciliation 会给服务引入额外的负担</strong>，因此应当越少越好。</p><p>我们采集了 24 小时内返回到购物车应用的版本数量。结果显示在这段时间内，<code>99.94%</code> 的请求看到的都是一个版本（无冲突）；<code>0.00057%</code> 的请求看到能 2 个，<code>0.00047%</code> 能看 到 3 个，<code>0.00009%</code> 的能看到 4 个。这说明版本分叉的概率还是相当小的。</p><p>实验还显示，导致分叉版本数量增多的并不是故障，而是并发写数量的增加。并发写数据上 升通常都是 busy robots（自动化客户端程序）导致的，极少是人（的应用）导致的。由于 涉及商业机密，在此不再就这一问题进行更深入的讨论。</p><h3 id="6-4-客户端驱动或服务端驱动的-Coordination"><a href="#6-4-客户端驱动或服务端驱动的-Coordination" class="headerlink" title="6.4 客户端驱动或服务端驱动的 Coordination"></a>6.4 客户端驱动或服务端驱动的 Coordination</h3><p>第 5 节提到，Dynamo 有一个 request coordination 组件，利用状态机处理收到的请求。</p><h4 id="服务端驱动"><a href="#服务端驱动" class="headerlink" title="服务端驱动"></a>服务端驱动</h4><p>客户请求会通过负载均衡器均匀地分发给哈希环上的所有节点。每个节点都可以作为读请求 的 coordinator，而写操作的 coordinator 必须由 key 的 preference list 里面的节点 才能充当。有这种限制是因为，preference list 中的这些节点<strong>被赋予了额外的职责：创 建一个新的版本戳（version stamp），在因果关系上包含被它的写操作更新的版本</strong>。注 意，如果 Dynamo 的版本化方案使用的是物理时间戳（physical timestamps），那任何节 点都可以 coordinate 写操作。</p><h4 id="客户端驱动"><a href="#客户端驱动" class="headerlink" title="客户端驱动"></a>客户端驱动</h4><p>另一中 coordinate request 的方式是：<strong>将状态机前移到客户端</strong>（move the state machine to the client nodes）。在这种方式中，客户端应用使用库（library）在本地执 行请求 coordination。每个客户端定期地随机选择一个 Dynamo 节点，下载它的系统成员 状态（Dynamo membership state）的当前视图（current view）。有了这个信息，客户端 就可以知道任何 key 对应的 preference list 由哪些节点组成。</p><p>读请求可以在客户端节点（client node）coordinate，因此如果请求是被负载均衡器随机 分给一个 Dynamo 节点，那这种方式可以避免额外的网络转发跳数。写操作或者转发给 key 对应的 preference list 里面的一个节点，或者，如果使用的是基于时间戳的版本化方式 ，可以在本地 coordinate。</p><p>客户端驱动的一个重要<strong>优势</strong>是：不再需要一个负载均衡器才能均匀地分发客户负载。 在存储节点上近乎均匀分布的 key，暗含了（implicitly guaranteed）负载的均匀分布。</p><p>显然，这种方式的效率取决于客户端侧的成员信息的新鲜程度（how fresh the membership information）。当前，每个客户端会每隔 <code>10s</code> 随机地轮询（poll）一个 Dynamo 节点， 获取成员更新（membership updates）。这里选用 pull 而不是 push 模型是考虑前者在大 量客户端的情况下可扩展性更好，而且相比于客户端侧，只需在服务端侧维护很少的状态信 息。</p><p>然而，在最差的情况下，客户端的 membership 信息会有 <code>10s</code> 的脏数据。 因此，如果客户端检测到它的成员表（membership table）过期了（例如，当一些成员不可 达的时候），它会立即更新它的成员信息。</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>表 2 显示了客户端驱动比服务端驱动的 coordination 的性能提升，测量时间为 24 个小时。</p><p>表 2 客户端驱动和服务端驱动的 coordination 性能对比</p><p><img src="/2022/01/30/yi-dynamo-amazon-s-highly-available-key-value-store/table-2.png" alt="img"></p><p>从中可以看出，客户端驱动的方式比服务端方式 <code>P99.9</code> 减少了至少 <code>30ms</code>，平均值减少 了 <code>3ms~4ms</code>。</p><p>延迟降低是因为客户端驱动的方式没有了负载均衡器的开销，而且减少了可能的将请求转发 给一个随机节点的网络跳数。</p><p>另外从表中还可以看出，平均延迟远远小于 <code>P99.9</code>。这是因为 Dynamo 的存储引擎缓存（ storage engine caches）和写缓存（write buffer）命中率很高。</p><p>另外，由于负载均衡器和网络会给延迟引入额外的抖动性，因此 <code>P99.9</code> 的性能提升要比 均值更明显。</p><h3 id="6-5-平衡后台和前台任务"><a href="#6-5-平衡后台和前台任务" class="headerlink" title="6.5 平衡后台和前台任务"></a>6.5 平衡后台和前台任务</h3><p>每个节点除了执行正常的前台 <code>put</code>/<code>get</code> 操作之外，还需要为副本同步和数据移交（ handoff）（由于 hinting 或添加/删除节点）执行不同种类的后台任务。</p><p>在早期的生产系统中，这些后台任务触发了资源竞争问题，影响了常规的 <code>get</code>/<code>put</code> 操 作性能。</p><p>因此，必须在保证常规的关键操作不受明显影响的情况下，才允许执行后台任务。为此，我 们将后台任务关联了一种<strong>许可控制机制</strong>（admission control mechanism）。每个后台 任务通过这个控制器<strong>申请资源（例如数据库）的运行时时间片</strong>（runtime slice），这 些资源是在所有后台任务之间共享的。对前台任务性能的监控会通过<strong>反馈机制</strong>改变后台 任务可以使用的时间片数量。</p><p>许可控制器（admission controller）在执行一个前台 <code>put</code>/<code>get</code> 操作的时候，会持续 监控资源访问的状况。<strong>监控的指标</strong>包括磁盘操作延迟、锁竞争和事务超时导致的数据库 访问失败次数，以及请求队列的等待时间。这些信息用于判断在给定的时间窗口之内的延迟 （或失败）性能是否在可接受的范围内。例如，后台控制器检查数据库（过去 <code>60s</code>）的 <code>P99</code> 读延迟是否离预设的阈值（例如 <code>50ms</code>）足够近。控制器正是根据这些对比信息为 前台操作评估资源的可用性，然后决定给后台任务分配多少时间片，因此利用反馈回路限制 了后台任务的侵入性（intrusiveness ）。[4] 也研究了类似的后台任务管理问题。</p><h3 id="6-6-讨论"><a href="#6-6-讨论" class="headerlink" title="6.6 讨论"></a>6.6 讨论</h3><p>本节总结我们在开发和维护 Dynamo 的过程中获得的一些经验。</p><p>很多 Amazon 的内部服务在过去的两年都开始使用 Dynamo，它给应用提供了非常高等级（ significant levels）的可用性。具体来说，使用 Dynamo 的应用，响应成功率（不包括超 时？）达到了 <code>99.9995%</code>（<strong>applications have received successful responses (without timing out) for <code>99.9995%</code> of its requests</strong>），并且到目前位置还没有发 生过丢失数据的情况。</p><p>Dynamo 的主要优势是：给应用提供了配置能力，应用可以根据自己的需求对 <code>(N,R,W)</code> 进 行调优。</p><p>和流行的商业数据仓库不同，Dynamo 将数据一致性和 reconciliation 逻辑开放给了开发 者。刚开始时，有人可能会觉得这样会使应用逻辑变得更复杂。但从传统来看（ historically），Amazon 平台就是为高可用设计的，很多<strong>应用在设计的时候就考虑了如 何处理可能出现的各种故障模式（failure modes）和不一致问题</strong>。对于这类应用来说， 适配 Dynamo 相对还是比较简单的。对于想要使用 Dynamo 的新应用，就需要首先花一些时 间做一些分析，在开发初期，选择满足业务需求的合适的冲突解决机制（conflict resolution mechanisms）。</p><p>最后，Dynamo 采用了一种<strong>full membership model</strong>（完整成员模型），在这种模型中， 每个节点都知道它的对端（peer）节点存储哪些数据。在实现中，每个节点要主动将完整路 由表 gossip 给系统内的其他节点。这个模型<strong>对几百台、上千台节点的规模很适用</strong>。但 对于上万台节点的规模就不适应了，因为维护这么大一个系统的路由表开销会大大增加。 但是，可以通过向 Dynamo 引入<strong>hierarchical extensions</strong>（层级扩展）来解决这个限制。 <code>O(1)</code> 复杂度的的动态哈希树系统（DHS）（例如 [14]）解决的就是这种问题。</p><blockquote><p>this problem is actively addressed by O(1) DHT systems(e.g., [14]).</p></blockquote><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7. 结束语"></a>7. 结束语</h2><p>本文介绍了 Dynamo，一个高可用、高可扩展的数据仓库（data store），在 Amazon 电商 平台用于存储许多核心服务的状态数据。</p><p>Dynamo 提供了期望的可用性和性能等级，可以正确地处理服务器故障、数据中心故障和网 络分裂。</p><p>Dynamo 可以增量扩展，允许服务所有者根据负载高低动态的对 Dynamo 系统进行扩缩容； 允许服务所有者根据他们的性能、持久性和一致性 SLA 需求，通过调优 <code>N``R``W</code> 三个参 数来定制化它们的存储系统。</p><p>过去几年 Dynamo 在生产环境的实践表明：一些去中心化技术结合起来，可以提供一个高度 可用的系统。这种在极具挑战性的应用环境的成功也表明，<strong>最终一致性存储系统可以作为 高可用应用（highly available applications）的一块基石</strong>。</p><blockquote><p>The production use of Dynamo for the past year demonstrates that decentralized techniques can be combined to provide a single highly-available system. Its success in one of the most challenging application environments shows that an eventualconsistent storage system can be a building block for highlyavailable applications.</p></blockquote><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>The authors would like to thank Pat Helland for his contribution to the initial design of Dynamo. We would also like to thank Marvin Theimer and Robert van Renesse for their comments. Finally, we would like to thank our shepherd, Jeff Mogul, for his detailed comments and inputs while preparing the camera ready version that vastly improved the quality of the paper.</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>Adya, et al. Farsite: federated, available, and reliable storage for an incompletely trusted environment. SIGOPS 2002</li><li>Bernstein, P.A., et al. An algorithm for concurrency control and recovery in replicated distributed databases. ACM Trans. on Database Systems, 1984</li><li>Chang, et al. <strong>Bigtable: a distributed storage system for structured data</strong>. In Proceedings of the 7th Conference on USENIX Symposium on Operating Systems Design and Implementation, 2006</li><li>Douceur, et al. Process-based regulation of low-importance processes. SIGOPS 2000</li><li>Fox, et al. Cluster-based scalable network services. SOSP, 1997</li><li>Ghemawat, et al. <strong>The Google file system</strong>. SOSP, 2003</li><li>Gray, et al. The dangers of replication and a solution. SIGMOD 1996</li><li>Gupta, et al. On scalable and efficient distributed failure detectors. In Proceedings of the Twentieth Annual ACM Symposium on Principles of Distributed Computing. 2001</li><li>Kubiatowicz, et al. OceanStore: an architecture for global-scale persistent storage. SIGARCH Comput. Archit. News, 2000</li><li>Karger, et al. Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web. STOC 1997</li><li>Lindsay, et al. “Notes on Distributed Databases”, Research Report RJ2571(33471), IBM Research, 1979</li><li>Lamport, L. <strong>Time, clocks, and the ordering of events in a distributed system</strong>. ACM Communications, 1978</li><li>Merkle, R. A digital signature based on a conventional encryption function. Proceedings of CRYPTO, 1988</li><li>Ramasubramanian, et al. Beehive: O(1)lookup performance for power-law query distributions in peer-topeer overlays. In Proceedings of the 1st Conference on Symposium on Networked Systems Design and Implementation, , 2004</li><li>Reiher, et al. Resolving file conflicts in the Ficus file system. In Proceedings of the USENIX Summer 1994 Technical Conference, 1994</li><li>Rowstron, et al. Pastry: Scalable, decentralized object location and routing for large-scale peerto- peer systems. Proceedings of Middleware, 2001.</li><li>Rowstron, et al. Storage management and caching in PAST, a large-scale, persistent peer-to-peer storage utility. Proceedings of Symposium on Operating Systems Principles, 2001</li><li>Saito, et al. FAB: building distributed enterprise disk arrays from commodity components. SIGOPS 2004</li><li>Satyanarayanan, et al. Coda: A Resilient Distributed File System. IEEE Workshop on Workstation Operating Systems, 1987.</li><li>Stoica, et al. Chord: A scalable peer-to-peer lookup service for internet applications. SIGCOMM 2001</li><li>Terry, et al. Managing update conflicts in Bayou, a weakly connected replicated storage system. SOSP 1995</li><li>Thomas. A majority consensus approach to concurrency control for multiple copy databases. ACM Transactions on Database Systems, 1979.</li><li>Weatherspoon, et al. Antiquity: exploiting a secure log for wide-area distributed storage. SIGOPS 2007</li><li>Welsh, et al. SEDA: an architecture for well-conditioned, scalable internet services. SOSP 2001</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis哨兵sentinels</title>
      <link href="/2022/01/27/redis-shao-bing-sentinels/"/>
      <url>/2022/01/27/redis-shao-bing-sentinels/</url>
      
        <content type="html"><![CDATA[<h2 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h2><p>Sentinel节点本质上是一个特殊的Redis节点</p><p>它可以监视任意多个主服务器以及这些主服务器属下的所有从服务器，并在被监视的主服务器进人下线状态时(根据ping的时间间隔判断是否是下线了)， 自动将下线主服务器属下的某个从服务器升级为新的主服务器， 然后由新的主服务器代替已下线的主服务器继续处理命令请求  </p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211119220249825.png" alt="image-20211119220249825"></p><p>当 serverl 的下线时长超过用户设定的下线时长上限时， Sentinel 系统就会对server1 执行故障转移操作：</p><ul><li>首先， Sentinel 系统会挑选 server1属下的其中一个从服务器， 并将这个被选中的从服务器升级为新的主服务器。  </li><li>之后， Sentinel 系统会向 serverl 属下的所有从服务器发送新的复制指令， 让它们成为新的主服务器的从服务器， 当所有从服务器都开始复制新的主服务器时， 故障转移操作执行完毕。</li><li>另外， Sentinel 还会继续监视已下线的 serverl， 并在它重新上线时， 将它设置为新的主服务器的从服务器。  </li></ul><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211119220709722.png" alt="image-20211119220709722"></p><h3 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h3><p>每个Sentinel实例会维护与所监测的主从实例之间的两个连接，分别是命令连接（Command Connection）和发布/订阅连接（Pub/Sub Connection）。但是<strong>Sentinel和其他Sentinel之间只有一个命令连接</strong>。</p><h4 id="命令连接"><a href="#命令连接" class="headerlink" title="命令连接"></a>命令连接</h4><p>Sentinel维护命令连接是为了与其他主从实例以及Sentinel实例通过发送接收命令的方式进行通信</p><p>作用包括：</p><ol><li>Sentinel会默认以每1s间隔发送PING 命令给其他实例以主观判断其他实例是否下线。</li><li>Sentinel会通过Sentinel和主实例之间的命令连接每隔10s发送INFO命令给主从实例以得到主实例和从实例的最新信息。</li><li>在主实例下线的情况下，Sentinel会通过Sentinel和从实例的命令连接发送SLAVEOF NO ONE命令给选定的从实例从而使从实例提升为新的主节点。</li><li>Sentinel会默认每隔1s发送is-master-down-by-addr命令以询问其他Sentinel节点关于监控的主节点是否下线。</li></ol><p>实现函数sentinel.c/sentinelReconnectInstance</p><h4 id="发布-订阅连接"><a href="#发布-订阅连接" class="headerlink" title="发布/订阅连接"></a>发布/订阅连接</h4><p>Sentinel维护和其他主从节点的发布/订阅连接作用是为了获知其他监控相同主从实例的Sentinel实例的存在，并且从其他Sentinel实例中更新对所监控的主从实例以及发送的Sentinel实例的认知。例如在故障转移完成后，其他Sentinel通过读取领头Sentinel的频道消息来更新新的主节点的相关信息（地址，端口号等）。</p><p>Sentinel在默认每隔2秒钟会发送Hello消息包到其对应的主从实例的_<em>sentinel</em>_:hello频道中。Hello消息格式如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">__sentinel__:hello <span class="token operator">&lt;</span>sentinel地址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel端口号<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel运行id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sentinel配置纪元<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点名字 <span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点地址<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点端口号<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点配置纪元<span class="token operator">&gt;</span></code></pre><p>当Sentinel通过订阅连接收到其他Sentinel发送的的Hello包时，会更新对主从节点以及发送Sentinel的实例，如果收到自己发送的Hello包，则简单的丢弃不做任何处理。</p><p>处理hello信息实现函数sentinel.c/sentinelProcessHelloMessage</p><p>发布/订阅连接实现函数sentinel.c/sentinelReconnectInstance</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>sentinel本质是一个特殊模式的redis的服务器，代码的入口一样位于server.c/main函数</p><p>与普通的节点有不同:</p><p>**sertinet.c/initSentinelConfig()**函数将会覆盖普通redis服务器的一些默认配置</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 此函数用于设置Sentinel的默认值 * 覆盖普通redis config默认值。 */</span> <span class="token comment">/* This function overwrites a few normal Redis config default with Sentinel * specific defaults. */</span><span class="token keyword">void</span> <span class="token function">initSentinelConfig</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//使用26379作为sentinel的默认端口</span>    server<span class="token punctuation">.</span>port <span class="token operator">=</span> REDIS_SENTINEL_PORT<span class="token punctuation">;</span>     server<span class="token punctuation">.</span>protected_mode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Sentinel must be exposed. */</span><span class="token punctuation">}</span></code></pre><p>使用<strong>sentinel.c/sentinelcmds</strong>作为sentinel的命令表</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//sentinel 模块初始化</span><span class="token comment">/* Perform the Sentinel mode initialization. */</span><span class="token keyword">void</span> <span class="token function">initSentinel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>     <span class="token comment">// 清空常用命令；只添加sentinel 命令</span>    <span class="token comment">/* Remove usual Redis commands from the command table, then just add     * the SENTINEL command. */</span>    <span class="token function">dictEmpty</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>commands<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinelcmds<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinelcmds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> retval<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd <span class="token operator">=</span> sentinelcmds<span class="token operator">+</span>j<span class="token punctuation">;</span>         retval <span class="token operator">=</span> <span class="token function">dictAdd</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>commands<span class="token punctuation">,</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>cmd<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverAssert</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//......</span>    <span class="token comment">//初始化各种数据结构</span>    <span class="token comment">//......</span><span class="token punctuation">}</span>  <span class="token comment">//所有sentinel可以执行的命令</span><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> sentinelcmds<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token string">"ping"</span><span class="token punctuation">,</span>pingCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"sentinel"</span><span class="token punctuation">,</span>sentinelCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"subscribe"</span><span class="token punctuation">,</span>subscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"unsubscribe"</span><span class="token punctuation">,</span>unsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"psubscribe"</span><span class="token punctuation">,</span>psubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"punsubscribe"</span><span class="token punctuation">,</span>punsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"pub-sub"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"publish"</span><span class="token punctuation">,</span>sentinelPublishCommand<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"pub-sub fast"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"info"</span><span class="token punctuation">,</span>sentinelInfoCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"random @dangerous"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">,</span>sentinelRoleCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"fast read-only @dangerous"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"client"</span><span class="token punctuation">,</span>clientCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin random @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"shutdown"</span><span class="token punctuation">,</span>shutdownCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"auth"</span><span class="token punctuation">,</span>authCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"no-auth fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span>helloCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"no-auth fast @connection"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"acl"</span><span class="token punctuation">,</span>aclCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"command"</span><span class="token punctuation">,</span>commandCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"random @connection"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>初始化sentinel状态</p><p>接下来服务器会初始化一个<strong>sentinel.c/sentinelState</strong>，用于保存所有与sentinel功能有关的状态(redisServer保存了一般的状态)</p><pre class="language-c" data-language="c"><code class="language-c"> <span class="token comment">/** * sentinel 状态 */</span><span class="token comment">/* Main state. */</span><span class="token keyword">struct</span> <span class="token class-name">sentinelState</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> myid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* This sentinel ID. */</span>    <span class="token class-name">uint64_t</span> current_epoch<span class="token punctuation">;</span>         <span class="token comment">/* Current epoch. */</span> <span class="token comment">//当前纪元用户实现故障转移</span>     <span class="token comment">/**     * 当前哨兵监听的所有master字典     * key是实例名，value是指向sentinelRedisInstance 结构的指针     */</span>     dict <span class="token operator">*</span>masters<span class="token punctuation">;</span>      <span class="token comment">/* Dictionary of master sentinelRedisInstances.                           Key is the instance name, value is the                           sentinelRedisInstance structure pointer. */</span>    <span class="token comment">//是否进入了TILT模式                                          </span>    <span class="token keyword">int</span> tilt<span class="token punctuation">;</span>           <span class="token comment">/* Are we in TILT mode? */</span>    <span class="token comment">//目前正在执行的脚本数量</span>    <span class="token keyword">int</span> running_scripts<span class="token punctuation">;</span>    <span class="token comment">/* Number of scripts in execution right now. */</span>    <span class="token comment">//进入tilt模式的时间</span>    <span class="token class-name">mstime_t</span> tilt_start_time<span class="token punctuation">;</span>       <span class="token comment">/* When TITL started. */</span>    <span class="token comment">//最后一次执行处理器的时间</span>    <span class="token class-name">mstime_t</span> previous_time<span class="token punctuation">;</span>         <span class="token comment">/* Last time we ran the time handler. */</span>    <span class="token comment">//FIFO队列，包含所有需要执行的用户脚本</span>    list <span class="token operator">*</span>scripts_queue<span class="token punctuation">;</span>            <span class="token comment">/* Queue of user scripts to execute. */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>announce_ip<span class="token punctuation">;</span>  <span class="token comment">/* IP addr that is gossiped to other sentinels if                           not NULL. */</span>    <span class="token keyword">int</span> announce_port<span class="token punctuation">;</span>  <span class="token comment">/* Port that is gossiped to other sentinels if                           non zero. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> simfailure_flags<span class="token punctuation">;</span> <span class="token comment">/* Failures simulation. */</span>    <span class="token keyword">int</span> deny_scripts_reconfig<span class="token punctuation">;</span> <span class="token comment">/* Allow SENTINEL SET ... to change script                                  paths at runtime? */</span><span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span>   <span class="token comment">//sentinel 模块初始化</span><span class="token comment">/* Perform the Sentinel mode initialization. */</span><span class="token keyword">void</span> <span class="token function">initSentinel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token comment">//...............</span>    <span class="token comment">// 清空常用命令；只添加sentinel 命令</span>    <span class="token comment">//..............</span>     <span class="token comment">//初始化各种数据结构</span>    <span class="token comment">/* Initialize various data structures. */</span>    sentinel<span class="token punctuation">.</span>current_epoch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>masters <span class="token operator">=</span> <span class="token function">dictCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>instancesDictType<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>tilt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>tilt_start_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>previous_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>running_scripts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>scripts_queue <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>announce_ip <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>announce_port <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>simfailure_flags <span class="token operator">=</span> SENTINEL_SIMFAILURE_NONE<span class="token punctuation">;</span>    sentinel<span class="token punctuation">.</span>deny_scripts_reconfig <span class="token operator">=</span> SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>初始化sentinel状态的master属性</p><p>sentinelState状态中的master属性记录所有被sentinel监视的所有相关信息；</p><ul><li>sentinelState.masters的结构是hash；</li><li>字典键的被监视主服务的名字；</li><li>字典值则是 sentinel.c/sentinelRedisInstance结构体；</li></ul><p>根据sentinel启动时的指定的配置项或者配置文件来初始化</p><p>如果按照下图指定:</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155233753.png" alt="image-20211121155233753"></p><p>则最后的字典值为:</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155311843.png" alt="image-20211121155311843"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155327607.png" alt="image-20211121155327607"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121155342021.png" alt="image-20211121155342021"></p><p>创建与主服务器的网络连接</p><p>sentinel会与被监控的master建立连接，sentinel将会成为master的客户端</p><p>sentinel会创建两个连接向master的异步网络连接：</p><ul><li>一个是命令连接，用于向master发送命令并接受回复</li><li>一个是订阅连接，用于订阅master的<code>__sentinel__:hello</code>频道</li></ul><blockquote><p><strong>为什么要有两个连接</strong></p><p>目前发布和订阅的功能，被发送的信息都不会保存在服务器里面；</p><p>如果发送时接受信息的客户端不在线，那么客户端就会丢失这条数据；为了不丢失<code>__sentinel__:hello</code>频道的任何信息，所以sentinel必须创建一个订阅连接来接受消息</p><p>因为是多个连接,所以必须是异步的</p><p><strong>创建入口：</strong><br>server.c/main -&gt; server.c/serverCron() -&gt; sentinel.c/sentinelTimer -&gt; sentinel.c/sentinelHandleDictOfRedisInstances() -&gt; sentinel.c/sentinelHandleRedisInstance</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//对于特定的redis实例执行预操作</span><span class="token comment">/* Perform scheduled operations for the specified Redis instance. */</span><span class="token keyword">void</span> <span class="token function">sentinelHandleRedisInstance</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* ========== MONITORING HALF ============ */</span>    <span class="token comment">/* Every kind of instance */</span>    <span class="token comment">//监控所有类型的实例(master,slave,sentinel)</span>    <span class="token function">sentinelReconnectInstance</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sentinelSendPeriodicCommands</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* ============== ACTING HALF ============= */</span>    <span class="token comment">/* We don't proceed with the acting half if we are in TILT mode.     * TILT happens when we find something odd with the time, like a     * sudden change in the clock. */</span>    <span class="token comment">//对于tilt模式下哨兵已经不可信,这时候检测是否时钟恢复正常,如果正常就推出tilt模式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>tilt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>sentinel<span class="token punctuation">.</span>tilt_start_time <span class="token operator">&lt;</span> sentinel_tilt_period<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        sentinel<span class="token punctuation">.</span>tilt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"-tilt"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">"#tilt mode exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Every kind of instance */</span>    <span class="token function">sentinelCheckSubjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Masters and slaves */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_MASTER<span class="token operator">|</span>SRI_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Nothing so far. */</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Only masters */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelCheckObjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sentinelStartFailoverIfNeeded</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_ASK_FORCED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelFailoverStateMachine</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_NO_FLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121204051572.png" alt="image-20211121204051572"></p><h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p>sentinel默认每10s一次频率向 master &amp; slale发送info命令</p><p>实现的入口:(server.c/main -&gt; server.c/serverCron() -&gt; sentinel.c/sentinelTimer -&gt; sentinel.c/sentinelHandleDictOfRedisInstances() -&gt; sentinel.c/sentinelSendPeriodicCommands)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/** * 定期向指定的slave或master发送PING、INFO, 发布到消息到 “订阅”的channel */</span><span class="token comment">//类似于心跳检测</span><span class="token comment">/* Send periodic PING, INFO, and PUBLISH to the Hello channel to * the specified master or slave instance. */</span><span class="token keyword">void</span> <span class="token function">sentinelSendPeriodicCommands</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">mstime_t</span> now <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">mstime_t</span> info_period<span class="token punctuation">,</span> ping_period<span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token comment">/* Return ASAP if we have already a PING or INFO already pending, or     * in the case the instance is not properly connected. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>disconnected<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* For INFO, PING, PUBLISH that are not critical commands to send we     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't     * want to use a lot of memory just because a link is not working     * properly (note that anyway there is a redundant protection about this,     * that is, the link will be disconnected and reconnected if a long     * timeout condition is detected. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands <span class="token operator">&gt;=</span>        SENTINEL_MAX_PENDING_COMMANDS <span class="token operator">*</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>refcount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* If this is a slave of a master in O_DOWN condition we start sending     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD     * period. In this state we want to closely monitor slaves in case they     * are turned into masters by another Sentinel, or by the sysadmin.     *     * Similarly we monitor the INFO output more often if the slave reports     * to be disconnected from the master, so that we can have a fresh     * disconnection time figure. */</span>    <span class="token comment">//对于一个处于客观判断下线的slave,每秒发送info,避免被转换成了master</span>    <span class="token comment">//同时也检测其真实下线时间</span>    <span class="token comment">//todo:这里其实消耗的资源会比较多,有没有更好的解决办法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_SLAVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>master<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_O_DOWN<span class="token operator">|</span>SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>         <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>master_link_down_time <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        info_period <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        info_period <span class="token operator">=</span> sentinel_info_period<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* We ping instances every time the last received pong is older than     * the configured 'down-after-milliseconds' time, but every second     * anyway if 'down-after-milliseconds' is greater than 1 second. */</span>    ping_period <span class="token operator">=</span> ri<span class="token operator">-&gt;</span>down_after_period<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ping_period <span class="token operator">&gt;</span> sentinel_ping_period<span class="token punctuation">)</span> ping_period <span class="token operator">=</span> sentinel_ping_period<span class="token punctuation">;</span>    <span class="token comment">/* Send INFO to masters and slaves, not sentinels. */</span>    <span class="token comment">//向master和slave发送info命令</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_SENTINEL<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>info_refresh <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>info_refresh<span class="token punctuation">)</span> <span class="token operator">&gt;</span> info_period<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        retval <span class="token operator">=</span> <span class="token function">redisAsyncCommand</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token punctuation">,</span>            sentinelInfoReplyCallback<span class="token punctuation">,</span> ri<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span>            <span class="token function">sentinelInstanceMapCommand</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span><span class="token string">"INFO"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Send PING to all the three kinds of instances. */</span>    <span class="token comment">//对所有的实例发送ping</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>last_pong_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> ping_period <span class="token operator">&amp;&amp;</span>               <span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>last_ping_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> ping_period<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelSendPing</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* PUBLISH hello messages to all the three kinds of instances. */</span>    <span class="token comment">//向订阅的频道发布信息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> ri<span class="token operator">-&gt;</span>last_pub_time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> sentinel_publish_period<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sentinelSendHello</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121205944717.png" alt="image-20211121205944717"></p><p>通过解析maser返回Info命令信息，获取master的当前信息；</p><ul><li>一方面获取master的信息，包括run_id、角色、地址等；</li><li>另一方面获取master下所有slave服务器信息；</li></ul><p>根据这些返回信息，用户无需提供从服务器信息，就可以自动发现从服务器（便于与从服务器建立连接）</p><p>这些信息用来更新slaves字典,出现了新的就要加入到字典中,键是从服务器的ip:port，值是从服务器的对应实例结构</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223027407.png" alt="image-20211121223027407"></p><p><strong>解析info返回结果入口</strong><br><strong>sentinel.c/sentinelSendPeriodicCommands</strong> -&gt; <strong>sentinel.c/sentinelInfoReplyCallback</strong> &gt; <strong>sentinel.c/sentinelInfoReplyCallback</strong> &gt; <strong>sentinel.c/sentinelRefreshInstanceInfo</strong></p><h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>对于每个连接到主服务器的从服务器也要建立命令连接和订阅连接</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223238004.png" alt="image-20211121223238004"></p><p>通过解析slave返回的slave的信息，主要提取以下信息。然后根据这些信息，更新从服务的实例信息；</p><ul><li>从服务的run_id</li><li>主服务器的ip地址以及端口号</li><li>主从服务器的连接状态</li><li>从服务器优先级</li><li>从服务的偏移量</li></ul><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211121223623465.png" alt="image-20211121223623465"></p><h3 id="向被监视的主从服务器发送信息"><a href="#向被监视的主从服务器发送信息" class="headerlink" title="向被监视的主从服务器发送信息"></a>向被监视的主从服务器发送信息</h3><p>每两秒进行一次</p><p>发送的内容：</p><ul><li>sentinel_ip :sentinel的ip；</li><li>sentinel_port：sentinel的端口</li><li>sentinel_runid：：sentinel的runid</li><li>sentinel_current_epoch:sentinel当前配置的纪元</li><li>master_name: master的名称</li><li>·master_ip：master的ip</li><li>master_port：master的端口</li><li>master_config_epoch：master的当前配置的纪元</li></ul><p>函数实现：（sentinel.c/sentinelSendHello）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//通过Pub/Sub向指定的redis实例(即ri)发送hello消息,广播主机当前的配置,通知sentinel存活</span><span class="token comment">//如果发布成功排队,返回C_OK,否则是C_ERR</span><span class="token keyword">int</span> <span class="token function">sentinelSendHello</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token operator">+</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>announce_ip<span class="token punctuation">;</span>    <span class="token keyword">int</span> announce_port<span class="token punctuation">;</span>    sentinelRedisInstance <span class="token operator">*</span>master <span class="token operator">=</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token operator">?</span> ri <span class="token operator">:</span> ri<span class="token operator">-&gt;</span>master<span class="token punctuation">;</span>    sentinelAddr <span class="token operator">*</span>master_addr <span class="token operator">=</span> <span class="token function">sentinelGetCurrentMasterAddress</span><span class="token punctuation">(</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>disconnected<span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token comment">/* Use the specified announce address if specified, otherwise try to     * obtain our own IP address. */</span>    <span class="token comment">//设置广播的ip和端口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>announce_ip<span class="token punctuation">)</span> <span class="token punctuation">{</span>        announce_ip <span class="token operator">=</span> sentinel<span class="token punctuation">.</span>announce_ip<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">anetFdToString</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token operator">-&gt;</span>c<span class="token punctuation">.</span>fd<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>FD_TO_SOCK_NAME<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        announce_ip <span class="token operator">=</span> ip<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>announce_port<span class="token punctuation">)</span> announce_port <span class="token operator">=</span> sentinel<span class="token punctuation">.</span>announce_port<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>tls_replication <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>tls_port<span class="token punctuation">)</span> announce_port <span class="token operator">=</span> server<span class="token punctuation">.</span>tls_port<span class="token punctuation">;</span>    <span class="token keyword">else</span> announce_port <span class="token operator">=</span> server<span class="token punctuation">.</span>port<span class="token punctuation">;</span>    <span class="token comment">/* Format and send the Hello message. */</span>    <span class="token comment">//格式化要发送的消息</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>payload<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"%s,%d,%s,%llu,"</span> <span class="token comment">/* Info about this sentinel. */</span>        <span class="token string">"%s,%s,%d,%llu"</span><span class="token punctuation">,</span> <span class="token comment">/* Info about current master. */</span>        announce_ip<span class="token punctuation">,</span> announce_port<span class="token punctuation">,</span> sentinel<span class="token punctuation">.</span>myid<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">,</span>        <span class="token comment">/* --- */</span>        master<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span><span class="token function">announceSentinelAddr</span><span class="token punctuation">(</span>master_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>master_addr<span class="token operator">-&gt;</span>port<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> master<span class="token operator">-&gt;</span>config_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    retval <span class="token operator">=</span> <span class="token function">redisAsyncCommand</span><span class="token punctuation">(</span>ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>cc<span class="token punctuation">,</span>        sentinelPublishReplyCallback<span class="token punctuation">,</span> ri<span class="token punctuation">,</span> <span class="token string">"%s %s %s"</span><span class="token punctuation">,</span>        <span class="token function">sentinelInstanceMapCommand</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span><span class="token string">"PUBLISH"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        SENTINEL_HELLO_CHANNEL<span class="token punctuation">,</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    ri<span class="token operator">-&gt;</span>link<span class="token operator">-&gt;</span>pending_commands<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="接受来自主从服务器的频道信息"><a href="#接受来自主从服务器的频道信息" class="headerlink" title="接受来自主从服务器的频道信息"></a>接受来自主从服务器的频道信息</h3><p>当sentinel与主服务或者从服务建立连接后，sentinel就订阅主服务或从服务器的<code>__sentinel__::hello</code>频道；</p><p>订阅频道会一直持续到连接断开；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122130447110.png" alt="image-20211122130447110"></p><p>这样对于监听同一个服务器的多个sentinel，一个sentinel发送的信息会被其他sentinel接受到，这些信息会被其他sentinel用于更新信息；</p><p><strong>举个例子：</strong><br>假设有三个sentinel ，s1、s2、s3监听同一个服务器，s1向服务器频道<code>__sentinel__:hello</code>发送了一条信息，s1、s2、s3都会受到这条消息 ；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122145234776.png" alt="image-20211122145234776"></p><p>sentinel接受到消息后，会对消息进行解析:</p><ul><li>如果是自己发送的信息，就会丢弃该信息</li><li>如不是自己发送的，则是监视同一服务器的其他sentinel发送的，则会更新sentinel实例中相关信息</li></ul><h3 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h3><p>每个sentinel节点对于其他也监视这个主服务器的其他sentinel节点保存了一个instance结构</p><ul><li>键是其中一个 Sentinel 的名字， 格式为 ip:port</li><li>值是对应的实例结构</li></ul><p>收到其他sentinel发送的消息时，对于信息中sentinel，主服务器相关的参数配置做相应的记录</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122151957038.png" alt="image-20211122151957038"></p><p>sentinel节点保存的master实例中的sentinels字典不需要包含自身</p><p>sentinels字典利于发现监视同一个主服务器的其他sentinel节点</p><h3 id="创建连向其他sentinel节点的命令连接"><a href="#创建连向其他sentinel节点的命令连接" class="headerlink" title="创建连向其他sentinel节点的命令连接"></a>创建连向其他sentinel节点的命令连接</h3><p>使用命令连接相连的各个 Sentinel 可以通过向其他 Sentinel 发送命令请求来进行信息交换，但是不会创建订阅链接</p><p>Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新 Sentinel, 所以需要建立订阅连接， 而相互已知的 Sentinel 只要使用命令连接来进行通信就足够了   </p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211122153845487.png" alt="image-20211122153845487"></p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>默认情况下sentinel每秒发送ping，然后通过回复的pong确认监视的对象是否下线</p><p>对于ping命令的回复分两种情况：</p><ul><li>有效回复：返回 +PONG、-LOADING、-MASTERDOWN</li><li>无效回复：除了上述三种的回复外，都是无效回复</li></ul><p>如果down-after-millseconds毫秒内，连续返回无效回复，那么sentinel就会将master标记为主观下线，在实例结构的flag属性中标记主观下线</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211125223705911.png" alt="image-20211125223705911"></p><blockquote><p>down-after-millonseconds是sentinel配置文件指定的下线标准；<br>这个参数不仅会应用于master，还会应用到master下属的所有从服务器；</p><p>多个sentinel设置的down-after-millseconds时间可能是不同的，所以可能部分的sentinel认为主观下线，而其他的认为没有主观下线</p></blockquote><h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当sentinel将一个主服务器判断主观下线时，会向其他sentinel询问，看其他sentinel是否也人为他下线；</p><p>当有足够多的sentinel认为服务已经下线时，就判定服务器是客观下线，并进行故障转移</p><h4 id="发送SENTINEL-is-master-down-by-addr命令"><a href="#发送SENTINEL-is-master-down-by-addr命令" class="headerlink" title="发送SENTINEL is-master-down-by-addr命令"></a>发送SENTINEL is-master-down-by-addr命令</h4><p>询问其他sentinel的命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">SENTINEL is-master-down-by-addr <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>current_epoch<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>runid<span class="token operator">&gt;</span></code></pre><p>各参数意义如下</p><ul><li>ip：被sentinel判断为主观下线的服务ip</li><li>port：被sentinel判断为主观下线的服务端口</li><li>current_epoch：sentinel当前配置的纪元，用于选取领头sentinel</li><li>runid:可以是*符号或者sentinel的运行id，* 代表用于检测主服务器的客观下线状态；sentinel的运行id 则代表用于选举领头的sentinel；</li></ul><h4 id="接受SENTINEL-is-master-down-by-addr命令"><a href="#接受SENTINEL-is-master-down-by-addr命令" class="headerlink" title="接受SENTINEL is-master-down-by-addr命令"></a>接受SENTINEL is-master-down-by-addr命令</h4><p>返回的信息是包含三个参数的multi bulk：</p><ul><li><down_state>：表示自己对于目标服务器在线状态的检测结果</down_state></li><li><leader_runid>：可以是 * 符号或者目标 Sentinel 的局部领头 Sentinel 的运行 ID: * 符号代表命令用于检测主服务器的下线状态， 而局部领头 Sentinel 的运行 ID 则用于选举领头 Sentinel</leader_runid></li><li><leader_epoch>  ：局部领头 Sentinel的运行纪元</leader_epoch></li></ul><h4 id="接受SENTINEL-is-master-down-by-addr命令-的回复"><a href="#接受SENTINEL-is-master-down-by-addr命令-的回复" class="headerlink" title="接受SENTINEL is-master-down-by-addr命令 的回复"></a>接受SENTINEL is-master-down-by-addr命令 的回复</h4><p>sentienl根据SENTINEL is-master-down-by-addr命令的返回，统计其他sentinel返回下线的数量；<br>当这一数量达到配置指定的客观下线数量（之前由quorum参数指定）时，sentinel会将服务器实例结构的flags属性的SIR_O_DOWN标记位打开，标识主服务进入客观下线状态；</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211125223723501.png" alt="image-20211125223723501"></p><blockquote><p>同样的，多个sentinel设置的quorum参数可能是不同的，所以可能部分的sentinel认为客观下线，而其他的认为没有客观下线</p></blockquote><h3 id="选举sentinel领头者"><a href="#选举sentinel领头者" class="headerlink" title="选举sentinel领头者"></a>选举sentinel领头者</h3><p>当一个主服务器被判断为下线时，监视这个服务器sentinel的会进行协商，选举出一个领头的sentinel，由这个领头的sentinel执行故障转移操作</p><p><strong>选举领头sentinel的规则和方法</strong>：</p><ul><li>所有在线的sentinel都有被选为领头sentinel的资格</li><li>每次进行领头sentinel选举的时候，不论选举是否成功，所有sentinel的配置纪元的值都会+1；（配置的纪元就是个计数器）</li><li>每个配置的纪元里面，所有sentinel都有一票将某个sentinel设置为局部领头sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能更改了</li><li>每个发现主服务器下线的sentinel，都会要求其他sentinel将自己设置为领头sentinel</li><li>sentinel设置局部领头sentinel的选票规则是先到先得；最先向目标sentinel“索要投票” 将会得到该票，后续“索票”的sentinel将会被拒绝；</li><li>源sentinel收到目标sentinel的回复后，会解析回复中的leader_epoch；如果leader_epoch和源sentinel的一致，那么源sentinel会继续解析leader_runid参数；<br>如果leader_runid和源sentinel的run_id一致，说明目标sentinel将源sentinel设为了领头sentinel；</li><li>如果某sentinel被半数以上sentinel设置为了领头sentinel，那么这个sentinel将会成为领头sentinel；</li><li>如果给定的时间限制内，没有选举出领头sentinel，那么将在一段时间后重新选举，直到选举出为止；</li></ul><p>在这里和区块链选举比较相似</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选举出的领头sentinel将会已下线的主服务器进行下线操作，下线操作分为以下三个操作：</p><ol><li>在已下线的主服务的所有从服务器中，挑选出一个从服务器，将其转换为主服务器；</li><li>将已下线的主服务的所有从服务器，复制新的主服务器；</li><li>设置已经下线的主服务为从服务，并复制新的主服务，当下线的主服务重新上线后，就会复制新的主服务了；</li></ol><h4 id="选取新的主服务器步骤"><a href="#选取新的主服务器步骤" class="headerlink" title="选取新的主服务器步骤"></a>选取新的主服务器步骤</h4><ol><li>领头的sentinel会将下线的主服务的所有从服务放到一个列表里，然后按照以下规则对列表中一个个的过滤：</li><li>过滤掉已经断线的从服务器；</li><li>过滤掉最近5s内没有回复过sentinel 的info命令的从服务；</li><li>过滤掉与主服务器连接断开时间超过（down-after-millseconds * 10）毫秒的从服务器；这样可以保证剩余从服务器的数据比较新；</li><li>然后从剩余从服务器中选举优先级高的从服务器；</li><li>如果服务器优先级相同，则选取复制偏移量大的（复制偏移量大，说明数据新）；</li><li>至此，如果还没有选举出，则对运行id进行排序，选举出运行id最小的从服务器；</li></ol><p>选举出新的主服务后，sentinel将向新的主服务器发送slave no one ，转换成新的主服务器<br>然后领头sentinel以每秒一次的频率向新的主服务发送info命令,用于判断“切换主服务操作”是否成功（当新的主服务器角色由salve变成master，说明已经切换成功了）</p><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><p>新的主服务出现后，sentinel就会让所有从服务器去复制新的主服务器（通过salveof 命令实现）</p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211126111618727.png" alt="image-20211126111618727"></p><p><img src="/2022/01/27/redis-shao-bing-sentinels/image-20211126111640191.png" alt="image-20211126111640191"></p><h4 id="修改旧的主服务器的为从服务器"><a href="#修改旧的主服务器的为从服务器" class="headerlink" title="修改旧的主服务器的为从服务器"></a>修改旧的主服务器的为从服务器</h4><p>最后，将已经下线的主服务设置为从服务器，并复制新的主服务；</p><p>注意：因为这时旧的主服务已经下线，所以这时这个操作先保存到sentinel对应的实例结构中，等到旧的主服务重新上线后，sentinel就会向他发送slaveof命令，将他设置为从服务器；</p><h3 id="tilt模式"><a href="#tilt模式" class="headerlink" title="tilt模式"></a>tilt模式</h3><p>Redis哨兵依赖于系统时间,为了了解某个实例是否是可用的,其会记住最后一次成功回复PING命令的时间,然后与现在时间进行比较判断生存时间.<br>但是如果计算机时间发生了意外的变化,或者计算机现在非常忙碌,或者进程因为某些原因阻塞,哨兵可能会有意料之外的行为</p><p>TILT是一个特殊的保护模式,Sentinel的Tilt模式会在以下两种情况下开启：</p><ol><li>Sentinel进程被阻塞超过SENTINEL_TILT_TRIGGER时间（默认为2s），可能因为进程或系统I/O（内存，网络，存储）请求过多。</li><li>系统时钟调整到之前某个时间值。</li></ol><p>进入tilt模式会降低系统的可靠性(因为此时故障转移无法进行).sentinel计时器中断一般一秒十次.我们希望两次定时器中断的时间内控制在大约100毫秒.</p><p>当进入TILT模式时哨兵将会继续监视所有内容,但是</p><ul><li>停止所有的动作</li><li>会开始否定<code>SENTINEL is-master-down-by-addr</code>命令因为其不信任故障检测的能力</li></ul><p>如果30秒以内一切正常则退出TILT模式.<br>注意可以使用很多内核提供的单调时钟API已替换TILT模式.但是尚不清楚这是否是一个好的解决方案,因为当前系统避免了如果进程只是被挂起或长时间未由调度程序执行这种问题.</p><p>在计算机时间发生严重变化的时候进入<code>TILT模式</code>,并禁止除了监控以外的操作,因为此时sentinel依赖于时间,判断某个节点下线是根据PING的间隔来实现的,如果进入<code>TILT模式</code>证明时钟出现问题,此时这个sentinel已经不能被相信了.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis客户端与服务器</title>
      <link href="/2022/01/27/redis-ke-hu-duan/"/>
      <url>/2022/01/27/redis-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="redis客户端与服务器"><a href="#redis客户端与服务器" class="headerlink" title="redis客户端与服务器"></a>redis客户端与服务器</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li><p>cli命令行</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">{</span>    <span class="token comment">//参数</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>    <span class="token comment">//参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>    <span class="token comment">//命令指针</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span><span class="token punctuation">}</span> multiCmd<span class="token punctuation">;</span></code></pre></li><li><p>client结构(直接对于所有的数据结构进行了解释)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//I/O复用,所以需要为每个客户端维持一个状态,多个客户端在服务器用链表链接</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span>    <span class="token comment">//client的id</span>    <span class="token class-name">uint64_t</span> id<span class="token punctuation">;</span>            <span class="token comment">/* Client incremental unique ID. */</span>    connection <span class="token operator">*</span>conn<span class="token punctuation">;</span>    <span class="token comment">//协议版本</span>    <span class="token keyword">int</span> resp<span class="token punctuation">;</span>               <span class="token comment">/* RESP protocol version. Can be 2 or 3. */</span>    <span class="token comment">//当前正在使用的数据库</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>            <span class="token comment">/* Pointer to currently SELECTed DB. */</span>    <span class="token comment">//客户端名字</span>    robj <span class="token operator">*</span>name<span class="token punctuation">;</span>             <span class="token comment">/* As set by CLIENT SETNAME. */</span>    <span class="token comment">//缓冲区,用于储存指令</span>    sds querybuf<span class="token punctuation">;</span>           <span class="token comment">/* Buffer we use to accumulate client queries. */</span>    <span class="token comment">//在指令缓冲区中已经读到的位置</span>    <span class="token class-name">size_t</span> qb_pos<span class="token punctuation">;</span>          <span class="token comment">/* The position we have read in querybuf. */</span>    sds pending_querybuf<span class="token punctuation">;</span>   <span class="token comment">/* If this client is flagged as master, this buffer                               represents the yet not applied portion of the                               replication stream that we are receiving from                               the master. */</span>    <span class="token comment">//最近时间内缓冲区长度最大值</span>    <span class="token class-name">size_t</span> querybuf_peak<span class="token punctuation">;</span>   <span class="token comment">/* Recent (100ms or more) peak of querybuf size. */</span>    <span class="token comment">//当前指令的参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>               <span class="token comment">/* Num of arguments of current command. */</span>    <span class="token comment">//当前指令参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>            <span class="token comment">/* Arguments of current command. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数数量</span>    <span class="token keyword">int</span> original_argc<span class="token punctuation">;</span>      <span class="token comment">/* Num of arguments of original command if arguments were rewritten. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>original_argv<span class="token punctuation">;</span>   <span class="token comment">/* Arguments of original command if arguments were rewritten. */</span>    <span class="token class-name">size_t</span> argv_len_sum<span class="token punctuation">;</span>    <span class="token comment">/* Sum of lengths of objects in argv list. */</span>    <span class="token comment">//记录客户端执行的命令</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token operator">*</span>lastcmd<span class="token punctuation">;</span>  <span class="token comment">/* Last command executed. */</span>    <span class="token comment">//与之前定义的user对应,从而赋予相应的权限,NULL是管理员</span>    user <span class="token operator">*</span>user<span class="token punctuation">;</span>             <span class="token comment">/* User associated with this connection. If the                               user is set to NULL the connection can do                               anything (admin). */</span>    <span class="token comment">//指令类型,一条指令还是多条(内联)</span>    <span class="token keyword">int</span> reqtype<span class="token punctuation">;</span>            <span class="token comment">/* Request protocol type: PROTO_REQ_* */</span>    <span class="token comment">//还未读取的指令数量</span>    <span class="token keyword">int</span> multibulklen<span class="token punctuation">;</span>       <span class="token comment">/* Number of multi bulk arguments left to read. */</span>    <span class="token comment">//未读指令的</span>    <span class="token keyword">long</span> bulklen<span class="token punctuation">;</span>           <span class="token comment">/* Length of bulk argument in multi bulk request. */</span>    <span class="token comment">//回复链表</span>    list <span class="token operator">*</span>reply<span class="token punctuation">;</span>            <span class="token comment">/* List of reply objects to send to the client. */</span>    <span class="token comment">//回复链表中对象的总大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> reply_bytes<span class="token punctuation">;</span> <span class="token comment">/* Tot bytes of objects in reply list. */</span>    <span class="token comment">// 已发送字节，用于处理 short write </span>    <span class="token class-name">size_t</span> sentlen<span class="token punctuation">;</span>         <span class="token comment">/* Amount of bytes already sent in the current                               buffer or object being sent. */</span>    <span class="token comment">//创建客户端时间</span>    <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span>           <span class="token comment">/* Client creation time. */</span>    <span class="token keyword">long</span> duration<span class="token punctuation">;</span>          <span class="token comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span>    <span class="token comment">// 客户端最后一次和服务器互动的时间</span>    <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span> <span class="token comment">/* Time of the last interaction, used for timeout */</span>    <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span>    <span class="token comment">//客户端状态CLIENT_*</span>    <span class="token class-name">uint64_t</span> flags<span class="token punctuation">;</span>         <span class="token comment">/* Client flags: CLIENT_* macros. */</span>    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>      <span class="token comment">/* Needed when the default user requires auth. */</span>    <span class="token comment">//复制状态</span>    <span class="token keyword">int</span> replstate<span class="token punctuation">;</span>          <span class="token comment">/* Replication state if this is a slave. */</span>    <span class="token keyword">int</span> repl_put_online_on_ack<span class="token punctuation">;</span> <span class="token comment">/* Install slave write handler on first ACK. */</span>    <span class="token comment">// 用于保存主服务器传来的 RDB 文件的文件描述符</span>    <span class="token keyword">int</span> repldbfd<span class="token punctuation">;</span>           <span class="token comment">/* Replication DB file descriptor. */</span>    <span class="token comment">// 读取主服务器传来的 RDB 文件的偏移量</span>    <span class="token class-name">off_t</span> repldboff<span class="token punctuation">;</span>        <span class="token comment">/* Replication DB file offset. */</span>    <span class="token comment">// 主服务器传来的 RDB 文件的大小</span>    <span class="token class-name">off_t</span> repldbsize<span class="token punctuation">;</span>       <span class="token comment">/* Replication DB file size. */</span>    sds replpreamble<span class="token punctuation">;</span>       <span class="token comment">/* Replication DB preamble. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> read_reploff<span class="token punctuation">;</span> <span class="token comment">/* Read replication offset if this is a master. */</span>    <span class="token comment">// 主服务器的复制偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> reploff<span class="token punctuation">;</span>      <span class="token comment">/* Applied replication offset if this is a master. */</span>    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_off<span class="token punctuation">;</span> <span class="token comment">/* Replication ack offset, if this is a slave. */</span>    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 的时间</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_time<span class="token punctuation">;</span><span class="token comment">/* Replication ack time, if this is a slave. */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_last_partial_write<span class="token punctuation">;</span> <span class="token comment">/* The last time the server did a partial write from the RDB child pipe to this replica  */</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> psync_initial_offset<span class="token punctuation">;</span> <span class="token comment">/* FULLRESYNC reply offset other slaves                                       copying this slave output buffer                                       should use. */</span>    <span class="token comment">// 主服务器的 master run ID</span>    <span class="token comment">// 保存在客户端，用于执行部分重同步</span>    <span class="token keyword">char</span> replid<span class="token punctuation">[</span>CONFIG_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Master replication ID (if master). */</span>    <span class="token comment">// 从服务器的监听端口号</span>    <span class="token keyword">int</span> slave_listening_port<span class="token punctuation">;</span> <span class="token comment">/* As configured with: REPLCONF listening-port */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>slave_addr<span class="token punctuation">;</span>       <span class="token comment">/* Optionally given by REPLCONF ip-address */</span>    <span class="token keyword">int</span> slave_capa<span class="token punctuation">;</span>         <span class="token comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span>    <span class="token comment">//事务状态</span>    multiState mstate<span class="token punctuation">;</span>      <span class="token comment">/* MULTI/EXEC state */</span>    <span class="token comment">//阻塞类型</span>    <span class="token keyword">int</span> btype<span class="token punctuation">;</span>              <span class="token comment">/* Type of blocking op if CLIENT_BLOCKED. */</span>    <span class="token comment">//阻塞状态</span>    blockingState bpop<span class="token punctuation">;</span>     <span class="token comment">/* blocking state */</span>    <span class="token comment">// 最后被写入的全局复制偏移量</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> woff<span class="token punctuation">;</span>         <span class="token comment">/* Last write global replication offset. */</span>    list <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>     <span class="token comment">/* Keys WATCHED for MULTI/EXEC CAS */</span>    <span class="token comment">// 这个字典记录了客户端所有订阅的频道</span>    <span class="token comment">// 键为频道名字，值为 NULL</span>    <span class="token comment">// 也即是，一个频道的集合</span>    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment">/* channels a client is interested in (SUBSCRIBE) */</span>    <span class="token comment">// 链表，包含多个 pubsubPattern 结构</span>    <span class="token comment">// 记录了所有订阅频道的客户端的信息</span>    <span class="token comment">// 新 pubsubPattern 结构总是被添加到表尾</span>    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment">/* patterns a client is interested in (SUBSCRIBE) */</span>    sds peerid<span class="token punctuation">;</span>             <span class="token comment">/* Cached peer ID. */</span>    sds sockname<span class="token punctuation">;</span>           <span class="token comment">/* Cached connection target address. */</span>    listNode <span class="token operator">*</span>client_list_node<span class="token punctuation">;</span> <span class="token comment">/* list node in client list */</span>    listNode <span class="token operator">*</span>paused_list_node<span class="token punctuation">;</span> <span class="token comment">/* list node within the pause list */</span>    RedisModuleUserChangedFunc auth_callback<span class="token punctuation">;</span> <span class="token comment">/* Module callback to execute                                               * when the authenticated user                                               * changes. */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>auth_callback_privdata<span class="token punctuation">;</span> <span class="token comment">/* Private data that is passed when the auth                                   * changed callback is executed. Opaque for                                   * Redis Core. */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>auth_module<span class="token punctuation">;</span>      <span class="token comment">/* The module that owns the callback, which is used                             * to disconnect the client if the module is                             * unloaded for cleanup. Opaque for Redis Core.*/</span>    <span class="token comment">/* If this client is in tracking mode and this field is non zero,     * invalidation messages for keys fetched by this client will be send to     * the specified client ID. */</span>    <span class="token class-name">uint64_t</span> client_tracking_redirection<span class="token punctuation">;</span>    rax <span class="token operator">*</span>client_tracking_prefixes<span class="token punctuation">;</span> <span class="token comment">/* A dictionary of prefixes we are already                                      subscribed to in BCAST mode, in the                                      context of client side caching. */</span>    <span class="token comment">/* In clientsCronTrackClientsMemUsage() we track the memory usage of     * each client and add it to the sum of all the clients of a given type,     * however we need to remember what was the old contribution of each     * client, and in which category the client was, in order to remove it     * before adding it the new value. */</span>    <span class="token class-name">uint64_t</span> client_cron_last_memory_usage<span class="token punctuation">;</span>    <span class="token keyword">int</span>      client_cron_last_memory_type<span class="token punctuation">;</span>    <span class="token comment">/* Response buffer */</span>    <span class="token comment">// 回复偏移量</span>    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> buf_usable_size<span class="token punctuation">;</span> <span class="token comment">/* Usable size of buffer. */</span>    <span class="token comment">/* Note that 'buf' must be the last field of client struct, because memory     * allocator may give us more memory than our apply for reducing fragments,     * but we want to make full use of given memory, i.e. we may access the     * memory after 'buf'. To avoid make others fields corrupt, 'buf' must be     * the last one. */</span>    <span class="token comment">//回复缓冲区</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>PROTO_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> client<span class="token punctuation">;</span></code></pre><p>所有的client属性连成了一个链表,保存在redisServer的clients属性中,对于不同状态的client也有其他的链表保存.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token comment">//链表,保存了所有的客户端状态</span>    list <span class="token operator">*</span>clients<span class="token punctuation">;</span>              <span class="token comment">/* List of active clients */</span>    <span class="token comment">//保存所有的待关闭客户端</span>    list <span class="token operator">*</span>clients_to_close<span class="token punctuation">;</span>     <span class="token comment">/* Clients to close asynchronously */</span>    <span class="token comment">//将要写的客户端列表</span>    list <span class="token operator">*</span>clients_pending_write<span class="token punctuation">;</span> <span class="token comment">/* There is to write or install handler. */</span>    <span class="token comment">//将要读的客户端列表(已经知道有指令输入了)</span>    list <span class="token operator">*</span>clients_pending_read<span class="token punctuation">;</span>  <span class="token comment">/* Client has pending read socket buffers. */</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>包含通用属性(所有客户端执行基础功能都必须需要的)和特定功能(执行特定功能)相关的属性</p><ul><li><p>套接字描述符uint64_t id;</p><ul><li>伪客户端:id为-1,载入AOF文件时使用,或者是执行Lua脚本中包含的redis命令</li><li>普通客户端的id大于-1,表示是正常的客户端</li></ul></li><li><p>名字robj *name;</p><ul><li>可有可无,一个robj对象,没有的时候指定为NULL</li></ul></li><li><p>标志uint64_t flags;</p><ul><li><p>表示了当前客户端的角色和状态</p></li><li><p>可以是单个也可以是多个标志的二进制取或.见CLIENT_*的定义可知,都是一位表示的</p></li><li><p>源代码：</p><pre class="language-c#" data-language="c#"><code class="language-c#">/* Client flags *///主从服务器进行复制时,相互都是客户端的关系,slave和master区分两个服务器#define CLIENT_SLAVE (1&lt;&lt;0)   /* This client is a replica */#define CLIENT_MASTER (1&lt;&lt;1)  /* This client is a master *///正在执行monitor指令,是一个从客户端#define CLIENT_MONITOR (1&lt;&lt;2) /* This client is a slave monitor, see MONITOR *///执行事务#define CLIENT_MULTI (1&lt;&lt;3)   /* This client is in a MULTI context *///客户端被阻塞#define CLIENT_BLOCKED (1&lt;&lt;4) /* The client is waiting in a blocking operation *///事务使用WATCH监视的数据库键已经被修改,EXEC执行过程中会直接fail#define CLIENT_DIRTY_CAS (1&lt;&lt;5)//用户对这个客户端执行了 CLIENT KILL命令或者客户端发送给服务器的命令中协议内容有误, //服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端,然后关闭客户端#define CLIENT_CLOSE_AFTER_REPLY (1&lt;&lt;6) /* Close after writing entire reply. *///从阻塞中解除,只有在之前阻塞过才可用#define CLIENT_UNBLOCKED (1&lt;&lt;7) /* This client was unblocked and is stored in                                  server.unblocked_clients *///专门处理Lua脚本的客户端#define CLIENT_LUA (1&lt;&lt;8) /* This is a non connected client used by Lua *///客户端向集群节点（ 运行在集群模式下的服务器） 发送了ASKING 命令#define CLIENT_ASKING (1&lt;&lt;9)     /* Client issued the ASKING command *///客户端的输出缓冲区大小超出了服务器允许的范围，//服务器会在下一次执行 serverCron 函数时关闭这个客户端,以免影响服务器的稳定性//积存在输出缓冲区中的所有内容会直接被释放,不会返回给客户端.#define CLIENT_CLOSE_ASAP (1&lt;&lt;10)/* Close this client ASAP *///服务器使用 UNIX 套接字来连接客户端#define CLIENT_UNIX_SOCKET (1&lt;&lt;11) /* Client connected via Unix domain socket *///事务在命令入队时出现了错误, 和CLIENT_DIRTY_CAS 都表示了事务不安全,EXEC会执行失败#define CLIENT_DIRTY_EXEC (1&lt;&lt;12)  /* EXEC will fail for errors while queueing *///在主从服务器进行命令传播期间,从服务器需要向主服务器发送REPLICATION ACK命令//发送命令之前需要打开这个标志以允许发送操作执行#define CLIENT_MASTER_FORCE_REPLY (1&lt;&lt;13)  /* Queue replies even if is master *///执行PUBSUB指令时打开,强制服务器将当前执行的命令写人到 AOF 文件里面#define CLIENT_FORCE_AOF (1&lt;&lt;14)   /* Force AOF propagation of current cmd. *///执行SCRIPT LOADD指令时打开,强制主服务器将当前执行的命令复制给所有从服务器#define CLIENT_FORCE_REPL (1&lt;&lt;15)  /* Force replication of current cmd. *///主服务器不能使用PSYNC命令与当前低版本从服务器进行同步.//这个标志只能在 REDIS_SLAVE 标志处于打开状态时使用#define CLIENT_PRE_PSYNC (1&lt;&lt;16)   /* Instance don't understand PSYNC. */#define CLIENT_READONLY (1&lt;&lt;17)    /* Cluster client is in read-only state. */#define CLIENT_PUBSUB (1&lt;&lt;18)      /* Client is in Pub/Sub mode. */#define CLIENT_PREVENT_AOF_PROP (1&lt;&lt;19)  /* Don't propagate to AOF. */#define CLIENT_PREVENT_REPL_PROP (1&lt;&lt;20)  /* Don't propagate to slaves. */#define CLIENT_PREVENT_PROP (CLIENT_PREVENT_AOF_PROP|CLIENT_PREVENT_REPL_PROP)#define CLIENT_PENDING_WRITE (1&lt;&lt;21) /* Client has output to send but a write                                        handler is yet not installed. */#define CLIENT_REPLY_OFF (1&lt;&lt;22)   /* Don't send replies to client. */#define CLIENT_REPLY_SKIP_NEXT (1&lt;&lt;23)  /* Set CLIENT_REPLY_SKIP for next cmd */#define CLIENT_REPLY_SKIP (1&lt;&lt;24)  /* Don't send just this reply. */#define CLIENT_LUA_DEBUG (1&lt;&lt;25)  /* Run EVAL in debug mode. */#define CLIENT_LUA_DEBUG_SYNC (1&lt;&lt;26)  /* EVAL debugging without fork() */#define CLIENT_MODULE (1&lt;&lt;27) /* Non connected client used by some module. */#define CLIENT_PROTECTED (1&lt;&lt;28) /* Client should not be freed for now. */#define CLIENT_PENDING_READ (1&lt;&lt;29) /* The client has pending reads and was put                                       in the list of clients we can read                                       from. */#define CLIENT_PENDING_COMMAND (1&lt;&lt;30) /* Indicates the client has a fully                                        * parsed command ready for execution. */#define CLIENT_TRACKING (1ULL&lt;&lt;31) /* Client enabled keys tracking in order to                                   perform client side caching. */#define CLIENT_TRACKING_BROKEN_REDIR (1ULL&lt;&lt;32) /* Target client is invalid. */#define CLIENT_TRACKING_BCAST (1ULL&lt;&lt;33) /* Tracking in BCAST mode. */#define CLIENT_TRACKING_OPTIN (1ULL&lt;&lt;34)  /* Tracking in opt-in mode. */#define CLIENT_TRACKING_OPTOUT (1ULL&lt;&lt;35) /* Tracking in opt-out mode. */#define CLIENT_TRACKING_CACHING (1ULL&lt;&lt;36) /* CACHING yes/no was given,                                              depending on optin/optout mode. */#define CLIENT_TRACKING_NOLOOP (1ULL&lt;&lt;37) /* Don't send invalidation messages                                             about writes performed by myself.*/#define CLIENT_IN_TO_TABLE (1ULL&lt;&lt;38) /* This client is in the timeout table. */#define CLIENT_PROTOCOL_ERROR (1ULL&lt;&lt;39) /* Protocol error chatting with it. */#define CLIENT_CLOSE_AFTER_COMMAND (1ULL&lt;&lt;40) /* Close after executing commands                                               * and writing entire reply. */#define CLIENT_DENY_BLOCKING (1ULL&lt;&lt;41) /* Indicate that the client should not be blocked.                                           currently, turned on inside MULTI, Lua, RM_Call,                                           and AOF client */#define CLIENT_REPL_RDBONLY (1ULL&lt;&lt;42) /* This client is a replica that only wants RDB without replication buffer. */</code></pre></li><li><p>PUBSUB命令:本身不修改数据库,但是向频道的所有订阅者发送消息的行为带有副作用， 接收到消息的所有客户端的状态都会因为这个命令而改变,所以也需要写入AOF.</p></li><li><p>SCRIPT LOAD命令:类似的,它修改了服务器状态,也带有副作用,同时因为涉及到主从服务器,CLIENT_FORCE_REPL将指令发给所有的从服务器.</p></li></ul></li><li><p>输入缓冲区</p><ul><li><p>源代码：</p><pre class="language-c#" data-language="c#"><code class="language-c#">typedef struct client {//缓冲区,用于储存指令    sds querybuf;           /* Buffer we use to accumulate client queries. */}client;</code></pre></li><li><p>保存用户发送的命令请求,根据输入内容动态变化大小</p></li></ul></li><li><p>命令和命令参数</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span><span class="token comment">//当前指令的参数数量</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>               <span class="token comment">/* Num of arguments of current command. */</span>    <span class="token comment">//当前指令参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>            <span class="token comment">/* Arguments of current command. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数数量</span>    <span class="token keyword">int</span> original_argc<span class="token punctuation">;</span>      <span class="token comment">/* Num of arguments of original command if arguments were rewritten. */</span>    <span class="token comment">//参数有可能是重写过的,记录了原来的参数值</span>    robj <span class="token operator">*</span><span class="token operator">*</span>original_argv<span class="token punctuation">;</span>   <span class="token comment">/* Arguments of original command if arguments were rewritten. */</span>    <span class="token class-name">size_t</span> argv_len_sum<span class="token punctuation">;</span>    <span class="token comment">/* Sum of lengths of objects in argv list. */</span>    <span class="token punctuation">}</span>client<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>命令实现函数</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span><span class="token comment">//记录客户端执行的命令</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token operator">*</span>lastcmd<span class="token punctuation">;</span>  <span class="token comment">/* Last command executed. */</span><span class="token punctuation">}</span>client<span class="token punctuation">;</span></code></pre></li><li><p>根据项argv[0] 的值,在命令表中査找命令所对应的命令实现函数,找到之后将客户端状态的cmd执行那个在命令表之中的这个结构,这个结构保存了命令的实现函数、 命令的标志 、 命令应该给定的参数个数、 命令的总执行次数和总消耗时长等统计信息  </p></li></ul></li><li><p>输出缓冲区</p><ul><li><p>源代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token comment">/* Response buffer */</span>    <span class="token comment">// 回复偏移量</span>    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> buf_usable_size<span class="token punctuation">;</span> <span class="token comment">/* Usable size of buffer. */</span>    <span class="token comment">/* Note that 'buf' must be the last field of client struct, because memory     * allocator may give us more memory than our apply for reducing fragments,     * but we want to make full use of given memory, i.e. we may access the     * memory after 'buf'. To avoid make others fields corrupt, 'buf' must be     * the last one. */</span>    <span class="token comment">//回复缓冲区,放在最后,因为内存分配的时候可能多给了一些内存,实际上并没有用到</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>PROTO_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> client<span class="token punctuation">;</span></code></pre></li><li><p>当 buf 数组的空间已经用完,或者回复因为太大而没办法放进 buf 数组里面时， 服务器就会开始使用可变大小缓冲区<code>list *reply;</code>,一个链表连接多个字符串对象,可以保存很长的回复信息</p></li></ul></li><li><p>身份验证</p><ul><li>int authenticated;</li><li>启用了身份验证之后,当属性为0时,除了AUTH指令,其他指令都会被拒绝.</li></ul></li><li><p>时间</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建客户端时间</span>   <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span>           <span class="token comment">/* Client creation time. */</span>   <span class="token keyword">long</span> duration<span class="token punctuation">;</span>          <span class="token comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span>   <span class="token comment">// 客户端最后一次和服务器互动的时间,即客户端空转时间</span>   <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span> <span class="token comment">/* Time of the last interaction, used for timeout */</span><span class="token comment">//达到buf软性限制的时间,太长的话会被kill</span>   <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>限制缓冲区大小</p><ul><li>硬性限制（ hard limit ): 如果输出缓冲区的大小超过了硬性限制所设置的大小， 那么服务器立即关闭客户端。</li><li>软性限制（ softlimit ): 如果输出缓冲区的大小超过了软性限制所设置的大小， 但还没超过硬性限制， 那么服务器将使用客户端状态结构的 <code>obuf_soft_limit_ reached_time </code>属性记录下客户端到达软性限制的起始时间； 之后服务器会继续监视客户端， 如果输出缓冲区的大小一直超出软性限制， 并且持续时间超过服务器设定的时长， 那么服务器将关闭客户端;如果不再超过的话就直接清零属性值,不关闭客户端</li></ul></li></ul><h3 id="客户端的类型"><a href="#客户端的类型" class="headerlink" title="客户端的类型"></a>客户端的类型</h3><ul><li><p>普通客户端</p><ul><li>直接按照之前的模式执行相关程序即可</li></ul></li><li><p>Lua脚本的伪客户端</p><ul><li>Lua_client 伪客户端在服务器初始化的时候就创建了,服务器运行的整个生命期中会一直存在,服务器被关闭时， 这个客户端才会被关闭</li></ul></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>Redis 服务器的命令请求来自 Redis 客户端， 当用户在客户端中键人一个命令请求时，客户端会将这个命令请求转换成协议格式， 然后通过连接到服务器的套接字， 将协议格式的命令请求发送给服务器</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRid1<span class="token text string">[用户]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">键入命令请求</span><span class="token arrow operator">--&gt;</span></span>id2<span class="token text string">[客户端]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">将命令转换为协议的格式并发送</span><span class="token arrow operator">--&gt;</span></span>id3<span class="token text string">[服务器]</span></code></pre><h4 id="读取请求"><a href="#读取请求" class="headerlink" title="读取请求"></a>读取请求</h4><p>客户端与服务器之间的连接套接字因为客户端的写入而变得可读,服务器将调用命令请求处理器:</p><ol><li>读取套接字中协议格式的命令请求， 并保存到客户端的输入缓冲区里面</li><li>对输入缓冲区中的命令请求进行分析， 提取出命令请求中包含的命令参数， 以及命<br>令参数的个数， 然后分别将参数和参数个数保存到客户端的argv属性和argc 属性里面</li><li>调用命令执行器， 执行客户端指定的命令  </li></ol><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><h5 id="查找命令实现"><a href="#查找命令实现" class="headerlink" title="查找命令实现"></a>查找命令实现</h5><p>根据客户端状态的 argv [ 0 ] 参数， 在命令表中查找参数所指定的命令， 并将找到的命令保存到客户端的 cmd 属性.</p><blockquote><p>命令表(redisCommandTable)是一个字典,键是命令名字,值是redisCommand结构,记录了命令的实现信息</p></blockquote><h5 id="执行预备操作"><a href="#执行预备操作" class="headerlink" title="执行预备操作"></a>执行预备操作</h5><p>检查上一步执行结果和执行命令的环境,权限等</p><h5 id="调用命令实现函数"><a href="#调用命令实现函数" class="headerlink" title="调用命令实现函数"></a>调用命令实现函数</h5><p>执行<code>client-&gt;cmd-&gt;proc(client);</code>,执行函数之后产生相应的命令回复,保存在客户端状态的输出缓冲区(buf和reply)</p><h5 id="执行后续工作"><a href="#执行后续工作" class="headerlink" title="执行后续工作"></a>执行后续工作</h5><p>记录日志等后续</p><h4 id="将回复发送给客户端"><a href="#将回复发送给客户端" class="headerlink" title="将回复发送给客户端"></a>将回复发送给客户端</h4><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面， 并为客户端的套接字关联命令回复处理器， 当客户端套接字变为可写状态时， 服务器就会执行命令回复处理器， 将保存在客户端输出缓冲区中的命令回复发送给客户端。  发送完之后将缓冲区清空.</p><h4 id="客户端接受并打印命令回复"><a href="#客户端接受并打印命令回复" class="headerlink" title="客户端接受并打印命令回复"></a>客户端接受并打印命令回复</h4><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112225309381.png" alt="image-20211112225309381"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>SET KEY VALUE</p><ol><li><p>先由客户端转换成协议<code>*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n  </code>并发送给服务器</p></li><li><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112111306721.png" alt="image-20211112111306721"><img src="/2022/01/27/redis-ke-hu-duan/image-20211112111326098.png" alt="image-20211112111326098"></p></li><li><p>命令执行过程</p><ol><li><p>查找命令实现</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112195218882.png" alt="image-20211112195218882"></p></li><li><p>调用实现函数</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112223826504.png" alt="image-20211112223826504"></p></li><li><p>保存回复到缓冲区</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211112224130202.png" alt="image-20211112224130202"></p></li></ol></li><li><p>将<code>+OK\r\n</code>发送给客户端</p></li><li><p>客户端转换格式为<code>OK\n</code>并显示</p></li></ol><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><ul><li><p>默认每隔 100 毫秒执行一次</p></li><li><p>负责管理服务器的资源， 并保持服务器自身的良好运转</p></li><li><p>更新的内容:</p><ul><li><p>更新服务器时间缓存</p><p>实时获取系统当前时间开销比较大,对于时间精度要求不是很高的使用地方使用缓存时间就可以.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//保存秒级精度的系统当前UNIX时间戳</span>redisAtomic <span class="token class-name">time_t</span> unixtime<span class="token punctuation">;</span><span class="token comment">//毫秒级精度的当前时间戳</span><span class="token class-name">mstime_t</span> mstime<span class="token punctuation">;</span>            <span class="token comment">//微秒级精度的当前时间戳</span><span class="token class-name">ustime_t</span> ustime<span class="token punctuation">;</span></code></pre><p>serverCron就是定时更新时间缓存的</p></li><li><p>更新LRU时钟</p></li><li><p>更新redis对象的空转时长属性</p></li><li><p>更新服务器每秒执行命令次数</p><p>嵌套调用的trackOperationsPerSecond函数抽样调查服务器一秒执行命令数量</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//抽样记录服务器每秒执行的命令数量</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> last_sample_time<span class="token punctuation">;</span> <span class="token comment">/* Timestamp of last sample in ms */</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> last_sample_count<span class="token punctuation">;</span><span class="token comment">/* Count in last sample */</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> samples<span class="token punctuation">[</span>STATS_METRIC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx<span class="token punctuation">;</span>    <span class="token punctuation">}</span> inst_metric<span class="token punctuation">[</span>STATS_METRIC_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>每次执行和上次执行的记录结果做比较,估算这一秒的执行情况</p></li><li><p>更新服务器内存峰值记录</p><pre class="language-none"><code class="language-none">size_t stat_peak_memory;//已用内存峰值</code></pre><p>查看使用的内存数量,记录使用时的最大值</p></li><li><p>处理sigterm信号</p><p>为信号关联处理器sigtermHandler函数,负责在服务器接到sigterm信号的时候根据shutdown_asap决定是否关闭服务器(关闭之前先完成持久化操作)</p></li><li><p>管理客户端资源</p><p>clientsCron函数对客户端进行检查,连接是否超时,输入缓冲区是否过大.</p></li><li><p>管理数据库资源</p><p>databasesCron函数对数据库和其中的过期键,字典进行检查</p></li><li><p>执行被延迟的BGREWRITEAOGF</p><p>在服务器执行bgsave命令的期间， 如果客户端向服务器发来 BGREWRITEAOF 命令，那 么 服 务 器 会 将 命 令 的 执 行 时 间 延 迟 到 bgsave命 令 执 行 完 毕 之 后 </p></li></ul></li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><h4 id="初始化状态结构"><a href="#初始化状态结构" class="headerlink" title="初始化状态结构"></a>初始化状态结构</h4><p>创建一个<code>struct redisServer</code>实例变量,设置默认值,创建命令表</p><p>主要由initServerConfig函数完成</p><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>根据redis.config文件或者启动时指定的配置项配置其他选项</p><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>创建服务器需要的除命令表之外的其他数据结构,需要用到之前的配置信息</p><p>initServre负责初始化这些数据结构和一些其他的设置操作,包括:</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象： 这些对象包含 Redis 服务器经常用到的一些值， 比如包含”OK”和”ERR”回复的字符串对象， 包含整数 1 到 10000 的字符串对象等等， 服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口， 并为监听套接字关联连接应答事件处理器， 等待服务器正<br>式运行时接受客户端的连接。</li><li>为 serverCron 函数创建时间事件， 等待服务器正式运行时执行 serverCron 函数。</li><li>如果 AOF 持久化功能已经打开， 那么打开现有的 AOF 文件， 如果 AOF 文件不存在，<br>那么创建并打开一个新的 AOF 文件， 为 AOF 写入做好准备。</li><li>初始化服务器的后台 I/O 模块（ bio )， 为将来的 I/O 操作做好准备  </li></ul><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>载入AOF或者RDB文件</p><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>打开事件循环,之后就可以接受命令</p><h1 id="多机数据库实现"><a href="#多机数据库实现" class="headerlink" title="多机数据库实现"></a>多机数据库实现</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>SLAVEOF可以让从服务器复制主服务器的内容,二者保存的数据是一致的</p><h3 id="旧版复制功能"><a href="#旧版复制功能" class="headerlink" title="旧版复制功能"></a>旧版复制功能</h3><p>以前直接在重连的时候复制整个数据库的RDB文件,bgsave开销非常大(相当于重新执行了一次sync,期间对于主服务器不能执行其他命令,需要保存在缓冲区)</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211117222257569.png" alt="image-20211117222257569"></p><p>执行SYNC命令:</p><ul><li>主服务器需要执行BGSAVE命令来生成 RDB 文件， 这个生成操作会耗费主服务器大量的 CPU、 内存和磁盘 I/O 资源。</li><li>主服务器需要将自己生成的 RDB 文件发送给从服务器， 这个发送操作会耗费主从服务器大量的网络资源（ 带宽和流量 ）， 并对主服务器响应命令请求的时间产生影响。</li><li>接收到 RDB 文件的从服务器需要载入主服务器发来的 RDB 文件， 并且在载入期间， 从服务器会因为阻塞而没办法处理命令请求。  </li></ul><p>每次主服务器改数据库之后都要传播该条命令</p><h3 id="新版复制功能"><a href="#新版复制功能" class="headerlink" title="新版复制功能"></a>新版复制功能</h3><p>使用PSYNC实现</p><ul><li>完整重同步:初始复制主服务器,与之前的SYNC没有什么不同</li><li>部分重同步:断线后重连复制,条件允许时直接将断开连接期间的写命令发给从服务器.</li></ul><p>重连之后从服务器发送PSYNC命令,主服务器向从服务器返回+CONTINUE回复,表示执行部分重同步,从服务器接受回复,准备执行部分重同步,主服务器发送断线期间的写命令,从服务器接受并执行,完成同步</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118101021620.png" alt="image-20211118101021620"></p><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从服务器都会维护复制偏移量,主服务器发送n数据,从服务器接受n数据,都会分别给自己的复制偏移量添加n.</p><p>如果master和slave的偏移量是相同的，那么主从数据处于一致的状态</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>主服务器维护的一个FIFO队列,固定默认1MB大小</p><p>当master向slave传播命令时，会将命令<strong>写入到复制积压缓冲区</strong>,复制积压缓冲区记录了最近向slave传播的命令；并且为每个字节记录了相应的复制偏移量</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118105510397.png" alt="image-20211118105510397"></p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118105606106.png" alt="image-20211118105606106"></p><p>当slave断线后重新连接master时，向master发送PSYNC命令会将自己的复制偏移量发送给master。</p><p>master会根据这个偏移量决定对slave执行<strong>部分同步</strong>还是<strong>完全同步；</strong></p><ul><li>slave的偏移量在复制积压缓冲区，执行部分同步 ；</li><li>slave的偏移量不在复制积压缓冲区，则执行完全同步；</li></ul><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>slave对master初次复制时，会保存master的运行id；</p><ul><li><p>当slave重新连接到master时，slave向master发送之前保存的mater run id；</p></li><li><p>如果slave保存的master run id和重新连接的master run id不一致，（换了master），则执行完全同步；</p></li></ul><p>相反，如果一致则尝试执行部分同步</p><h3 id="PSYNC执行过程"><a href="#PSYNC执行过程" class="headerlink" title="PSYNC执行过程"></a>PSYNC执行过程</h3><p><strong>PSYNC命令调用方式有两种：</strong></p><ol><li><p><strong><code>PSYNC ? -1</code> 全量复制</strong><br>当从服务没有复制过主服务器，或者从服务执行过<code>SLAVEOF NO ONE</code>命令（取消复制），那么从服务将发送<code>PSYNC ？-1</code>命令；</p></li><li><p><strong><code>PSYNC &lt;runid&gt; &lt;offset&gt; </code>部分复制</strong><br>从服务已经复制过主服务器，那么从服务将向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>， runid是主服务器的id，offset服务器当前的偏移量；</p><p>主服务器接受到<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令后，主服务会判断是否能“部分同步”，向从服务回复相应的命令；</p></li></ol><p><strong>主服务向从服务的三种回复：</strong></p><ol><li><strong><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code> 执行完全重同步；</strong></li><li><strong><code>+CONTINUE</code> 执行部分重同步；</strong></li><li><strong><code>-ERR</code> 不支持psync同步操作，从服务将发送sync命令到主服务器,执行完全重同步；</strong></li></ol><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118170432055.png" alt="image-20211118170432055"></p><p>注意图片有个情况没写出来</p><ol><li><p>设置主服务器的地址和端口</p><p>通过向从服务器发送SLAVE命令，可以让一个从服务器去复制一个主服务器</p><p>slaveof要做的主要是给“从服务”设置的“主服务”地址和端口，会保存到从服务器的<strong>masterhost</strong>和<strong>masterport</strong>属性中(<strong>replication.c/replicaofCommand</strong>)</p><p>slaveof是一个异步命令，完成设置后，会给客户端返回OK; 实际复制工作将在OK返回后真正开始执行；</p><p>执行<code>SLAVEOF 127.0.0.1&nbsp;6379</code>,设置好之后</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118204602440.png" alt="image-20211118204602440"></p></li><li><p>建立套接字连接</p><p>根据前一步保存的属性开始连接主服务器套接字(<strong>server.c/serverCron</strong> &gt; <strong>replication.c/replicationCron</strong> &gt; <strong>replication.c/connectWithMaster</strong>)</p><p>如果从服务和主服务器连接成功，从服务器会给这个套接字关联一个处理复制工作的文件处理器(<strong>replication.c/syncWithMaster</strong>),处理器完成后续工作,包括接受RDB文件,接受后续传来的写命令</p><p>主服务器在接受（ accept ) 从服务器的套接字连接之后， 将为该套接字创建相应的客户端状态， 并将从服务器看作是一个连接到主服务器的客户端来对待， 这时从服务器将同时具有服务器和客户端两个身份. </p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221239382.png" alt="image-20211118221239382"></p></li><li><p>发送ping命令</p><ul><li>检查套接字连接情况</li><li>检查主服务器是否能正常处理命令</li></ul><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221522707.png" alt="image-20211118221522707"></p></li><li><p>身份验证</p><ul><li>如果从服务器设置了 masterauth 选项， 那么进行身份验证。</li><li>如果从服务器没有设置 masterauth 选项， 那么不进行身份验证。</li></ul><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221720561.png" alt="image-20211118221720561"></p></li><li><p>发送端口信息</p><p>从服务将执行<code>REPLCONF listen-port &lt;port-number&gt;</code>，向主服务器发送从服务监听的端口号</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221853890.png" alt="image-20211118221853890"></p><p>主服务器接受到这个命令后，将从服务的端口号记录到客户端状态中的 slave_listening_port属性中</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118221942590.png" alt="image-20211118221942590"></p></li><li><p>同步</p><p>从服务器向主服务器发送PSYNC命令</p><p>在同步操作执行之前， 只有从服务器是主服务器的客户端， 但是在执行同步操作之后， 他们互为客户端,因为主服务器也需要发送写命令给从服务器</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211118223802314.png" alt="image-20211118223802314"></p></li><li><p>命令传播</p><p>写命令传播给从服务器</p></li></ol><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务默认每秒一次的频率向主服务器发送 <code>REPLCONF ACK &lt;replicaiotn_offset&gt; </code>(<code>replication_offset</code>是当前从服务器的复制偏移量)</p><p>心跳检测的代码入口位于：<code>server.c/serverCron &gt; replication.c/replicationCron &gt;  replication.c/replicationSendAck</code></p><h4 id="检测与主服务的网络连接状态"><a href="#检测与主服务的网络连接状态" class="headerlink" title="检测与主服务的网络连接状态"></a><strong>检测与主服务的网络连接状态</strong></h4><p>主从服务器通过发送和接受<code>REPLCONF</code> 命令检查网络连接是否正常；<br>如果从服务器超过一秒没有接收到从服务的<code>REPLCONF</code> 命令，主服务器就知道从服务连接出了问题； </p><p>主服务器对每个从服务器保存一个lag值记录上次收到心跳包的时间</p><h4 id="辅助实现min-slave选项"><a href="#辅助实现min-slave选项" class="headerlink" title="辅助实现min-slave选项"></a><strong>辅助实现min-slave选项</strong></h4><p>redis的<code>min-slave-to-write</code>和<code>min-salve-max-lag</code>可以防止主服务在不安全的情况下执行写命令；</p><p>例如 主服务的min-slave-to-write和min-salve-max-lag配置如下：<br>min-salve-max-lag 10<br>min-slave-to-write 3</p><p>那么从服务的数量少于3个，或者3个从服务的延时（lag）值大于等于10秒时，主服务都不能执行写命令；</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a><strong>检测命令丢失</strong></h4><p>如果因为网络原因，主服务传播给从服务的命令丢失了。那么当从服务向主服务器放松RELPCONF ACK 命令时，主服务会发觉 从服务 的复制偏移量少于主服务的复制偏移量；</p><p>然后主服务会将丢失的部分发送给从服务器(这里是没有断线的部分重同步,与断线之后的PSYNC区分)</p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211119111122087.png" alt="image-20211119111122087"></p><p><img src="/2022/01/27/redis-ke-hu-duan/image-20211119111136634.png" alt="image-20211119111136634"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事件</title>
      <link href="/2022/01/27/redis-shi-jian/"/>
      <url>/2022/01/27/redis-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="redis事件"><a href="#redis事件" class="headerlink" title="redis事件"></a>redis事件</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//事件处理器状态(同时是时间处理器和文件处理器)</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>    <span class="token comment">//当前注册的最大描述符</span>    <span class="token keyword">int</span> maxfd<span class="token punctuation">;</span>   <span class="token comment">/* highest file descriptor currently registered */</span>    <span class="token comment">//当前追踪的最大描述符</span>    <span class="token keyword">int</span> setsize<span class="token punctuation">;</span> <span class="token comment">/* max number of file descriptors tracked */</span>    <span class="token comment">//时间事件的id,时间事件链表中记录了最大的id</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> timeEventNextId<span class="token punctuation">;</span>    <span class="token comment">//已注册的文件事件</span>    aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">/* Registered events */</span>    <span class="token comment">//已经就绪,执行过处理器的文件事件</span>    aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">/* Fired events */</span>    <span class="token comment">//时间事件</span>    aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span>    <span class="token comment">//事件处理器开关</span>    <span class="token keyword">int</span> stop<span class="token punctuation">;</span>    <span class="token comment">//多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>apidata<span class="token punctuation">;</span> <span class="token comment">/* This is used for polling API specific data */</span>    <span class="token comment">//处理事件之前要执行的函数</span>    aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span>    <span class="token comment">//处理事件之后要执行的函数</span>    aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span></code></pre><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>服务器通过套接字和客户端连接,文件事件是对于套接字操作的抽象,通信过程会产生相应文件事件,服务器监听处理这些事件</p><ul><li><strong>本身单线程运行,但是I/O多路复用监听多个套接字</strong></li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* File event structure * * 文件事件结构 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>    <span class="token comment">// 监听事件类型掩码，</span>    <span class="token comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span>    <span class="token comment">// 或者 AE_READABLE | AE_WRITABLE</span>    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">/* one of AE_(READABLE|WRITABLE) */</span>    <span class="token comment">// 读事件处理器</span>    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>    <span class="token comment">// 写事件处理器</span>    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>    <span class="token comment">// 多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span><span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span></code></pre><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul><li><p>套接字</p><ul><li>每当一个套接字准备好执行某项操作时,产生一个文件事件,一个服务器连接了多个套接字,可以产生多个文件事件</li><li>当套接字可读(客户端执行write或者close之后)或者有新的可应答套接字出现(新的connect建立)时,产生AE_READABLE事件;套接字变得可写(客户端执行read操作之后)时,产生AE_WRITABLE事件</li></ul></li><li><p>I/O多路复用程序</p><ul><li>负责监听多个套接字的上述两种事件,向文件事件分派器传送产生了事件的套接字</li><li>多个事件时先处理AE_READABLE事件,先读后写,多个套接字都有事件时按照一个队列传送,当上一个套接字的事件处理完毕之后再处理下一个套接字</li></ul></li><li><p>文件事件分派器</p><ul><li>根据传来的套接字调用相应的事件处理器</li></ul></li><li><p>事件处理器</p><ul><li>执行相关操作的函数</li></ul></li></ul><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><ul><li><p>函数aeCreateFileEvent</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 根据 mask 参数的值，监听 fd 文件的状态， * 当 fd 可用时，执行 proc 函数 * 将给定套接字的给定事件加入到I/O多路复用程序的监听范围 * 将事件和事件处理器关联 */</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        errno <span class="token operator">=</span> ERANGE<span class="token punctuation">;</span>        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 取出文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token comment">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-&gt;</span>mask <span class="token operator">|=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment">// 私有数据</span>    fe<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>    <span class="token comment">// 如果有需要，更新事件处理器的最大 fd</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">)</span>        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeDeleteFileEvent</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 将 fd 从 mask 指定的监听队列中删除 * i/o多路复用程序取消对给定套接字的给定事件的监听 * 取消事件和事件处理器之间的关联 */</span><span class="token keyword">void</span> <span class="token function">aeDeleteFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 取出文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 未设置监听的事件类型，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* We want to always remove AE_BARRIER if set when AE_WRITABLE     * is removed. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> mask <span class="token operator">|=</span> AE_BARRIER<span class="token punctuation">;</span>    <span class="token comment">// 取消对给定 fd 的给定事件的监视</span>    <span class="token function">aeApiDelEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算新掩码</span>    fe<span class="token operator">-&gt;</span>mask <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Update the max fd */</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">!=</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeGetFileEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 获取给定 fd 正在监听的事件类型 * 返回正在监视的事件类型 */</span><span class="token keyword">int</span> <span class="token function">aeGetFileEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> fe<span class="token operator">-&gt;</span>mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeWait</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* Wait for milliseconds until the given file descriptor becomes * writable/readable/exception * 在给定毫秒内等待，直到 fd 变成可写、可读或异常 * 事件成功产生或者超时就返回 */</span><span class="token keyword">int</span> <span class="token function">aeWait</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> pfd<span class="token punctuation">;</span>    <span class="token keyword">int</span> retmask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfd<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLIN<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> pfd<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLOUT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pfd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> milliseconds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLOUT<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLERR<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pfd<span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLHUP<span class="token punctuation">)</span> retmask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>        <span class="token keyword">return</span> retmask<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeApiPoll</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*在指定时间内阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件当有至少一个事件产生或者超时返回*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tvp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>apidata<span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">,</span> j<span class="token punctuation">,</span> numevents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>rfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>wfds<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据select的retval决定之后的操作</span>    retval <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>                <span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> eventLoop<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//监听得到的事件类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">==</span> AE_NONE<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_READABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_rfds<span class="token punctuation">)</span><span class="token punctuation">)</span>                mask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_WRITABLE <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>state<span class="token operator">-&gt;</span>_wfds<span class="token punctuation">)</span><span class="token punctuation">)</span>                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> j<span class="token punctuation">;</span>            eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>numevents<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> mask<span class="token punctuation">;</span>            numevents<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"aeApiPoll: select, %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> numevents<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeProcessEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 调用aeApiPoll等待事件产生,之后遍历所有产生的事件,处理所有已到达的时间事件，以及所有已就绪的文件事件 * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪， * 或者下个时间事件到达（如果有的话） * 根据flag值确定相应的处理步骤 * 函数的返回值为已处理事件的数量*/</span><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> numevents<span class="token punctuation">;</span>    <span class="token comment">/* Nothing to do? return ASAP */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_FILE_EVENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* Note that we want to call select() even if there are no     * file events to process as long as we want to process time     * events, in order to sleep until the next time event is ready     * to fire. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">,</span> <span class="token operator">*</span>tvp<span class="token punctuation">;</span>        <span class="token class-name">int64_t</span> usUntilTimer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 距今最近的时间事件还要多久才能达到,使用usUntilTimer保存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span>            usUntilTimer <span class="token operator">=</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//还没有到达</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>usUntilTimer <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> usUntilTimer <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">;</span>            tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> usUntilTimer <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//如果时间事件已经到达(到达间隔时间为负数),将已到达时间事件的到达时间间隔设置为0</span>            <span class="token comment">/* If we have to check for events but need to return             * ASAP because of AE_DONT_WAIT we need to set the timeout             * to zero */</span>            <span class="token comment">// 执行到这一步，说明没有时间事件即将到达</span>            <span class="token comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 设置文件事件不阻塞,将已到达时间事件的到达时间间隔设置为0</span>                tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">/* Otherwise we can block */</span>                <span class="token comment">// 文件事件可以阻塞直到有事件到达为止,wait时间设置为无穷</span>                tvp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* wait forever */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            tvp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Call the multiplexing API, will return only on timeout or when         * some event fires. */</span>        <span class="token comment">// 处理文件事件，阻塞时间由 tvp 决定</span>        numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* After sleep callback. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>aftersleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-&gt;</span><span class="token function">aftersleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//从已就绪数组中获取事件</span>            <span class="token keyword">int</span> fd <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>            aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> mask <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>            <span class="token keyword">int</span> fired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Number of events fired for current fd. */</span>            <span class="token keyword">int</span> invert <span class="token operator">=</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> AE_BARRIER<span class="token punctuation">;</span>            <span class="token comment">//读取事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//确保读/写事件只能执行其中一个</span>                fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                fired<span class="token operator">++</span><span class="token punctuation">;</span>                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>            <span class="token punctuation">}</span>            <span class="token comment">/* Fire the writable event. */</span>            <span class="token comment">//写事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                    fired<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">/* If we have to invert the call, fire the readable event now             * after the writable one. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>invert<span class="token punctuation">)</span> <span class="token punctuation">{</span>                fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Refresh in case of resize. */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>                    fired<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            processed<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Check time events */</span>    <span class="token comment">//执行时间事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>        processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> processed<span class="token punctuation">;</span> <span class="token comment">/* return the number of processed file/time events */</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>实现不同的网络通信需求,主要是连接应答处理器,命令请求处理器,命令回复处理器</p><ul><li><p>连接应答处理器</p><ul><li><p>函数acceptTcpHandler对连接服务器监听套接字的客户端进行应答</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建一个TCP连接</span><span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cport<span class="token punctuation">,</span> cfd<span class="token punctuation">,</span> max <span class="token operator">=</span> MAX_ACCEPTS_PER_CALL<span class="token punctuation">;</span>    <span class="token keyword">char</span> cip<span class="token punctuation">[</span>NET_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UNUSED</span><span class="token punctuation">(</span>privdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//accept客户端连接</span>        cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cport<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//TCP连接函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cfd <span class="token operator">==</span> ANET_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span>                <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>                    <span class="token string">"Accepting client connection: %s"</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>neterr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">"Accepted %s:%d"</span><span class="token punctuation">,</span> cip<span class="token punctuation">,</span> cport<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 为客户端创建客户端状态（redisClient）</span>        <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span><span class="token function">connCreateAcceptedSocket</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>cip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>redis进行初始化时,将处理器与套接字的AE_READABLE事件连接起来,当由客户端使用sys/socket.h/connect函数连接服务器监听套接字时,套接字产生AE_READABLE事件,引发连接应答处理器执行,并执行相应的套接字应答操作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">连接监听套接字</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:服务器监听套接字产生的AE_READABLE事件,执行连接应答处理器]</span></code></pre></li></ul></li><li><p>命令请求处理器</p><ul><li><p>函数readQueryFromClient从套接字中读入客户端发送的命令请求内容</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 读取客户端的查询缓冲区内容 */</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nread<span class="token punctuation">,</span> big_arg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">;</span>    <span class="token comment">/* Check if we want to read from the client later when exiting from     * the event loop. This is the case if threaded I/O is enabled. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* Update total number of reads on server */</span>    <span class="token comment">//更新server的读入处理计数器</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_reads_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    readlen <span class="token operator">=</span> PROTO_IOBUF_LEN<span class="token punctuation">;</span>    <span class="token comment">/* If this is a multi bulk request, and we are processing a bulk reply     * that is large enough, try to maximize the probability that the query     * buffer contains exactly the SDS string representing the object, even     * at the risk of requiring more read(2) calls. This way the function     * processMultiBulkBuffer() can avoid copying buffers to create the     * Redis Object representing the argument. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reqtype <span class="token operator">==</span> PROTO_REQ_MULTIBULK <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>multibulklen <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>bulklen <span class="token operator">&gt;=</span> PROTO_MBULK_BIG_ARG<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">ssize_t</span> remaining <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bulklen<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>        big_arg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">/* Note that the 'remaining' variable may be zero in some edge case,         * for example once we resume a blocked client after CLIENT PAUSE. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> readlen <span class="token operator">=</span> remaining<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 获取查询缓冲区当前内容的长度</span>    <span class="token comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span>    <span class="token comment">// 这些滞留内容也许不能完整构成一个符合协议的命令</span>    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//为查询缓冲区分配空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>big_arg <span class="token operator">||</span> <span class="token function">sdsalloc</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> PROTO_IOBUF_LEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* When reading a BIG_ARG we won't be reading more than that one arg         * into the query buffer, so we don't need to pre-allocate more than we         * need, so using the non-greedy growing. For an initial allocation of         * the query buffer, we also don't wanna use the greedy growth, in order         * to avoid collision with the RESIZE_THRESHOLD mechanism. */</span>        <span class="token comment">//太长的指令参数只读入一个参数,查询缓冲区不需要多余分配空间,不使用贪心分配空间</span>        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomForNonGreedy</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Read as much as possible from the socket to save read(2) system calls. */</span>        readlen <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//读入内容到查询缓存</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读入出错时</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token operator">==</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Reading from client: %s"</span><span class="token punctuation">,</span><span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment">//遇到EOF</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>verbosity <span class="token operator">&lt;=</span> LL_VERBOSE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sds info <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span> <span class="token string">"Client closed connection %s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Append the query buffer to the pending (not applied) buffer         * of the master. We'll use this buffer later in order to have a         * copy of the string applied by the last command executed. */</span>        <span class="token comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span>        <span class="token comment">// 并将 '\0' 正确地放到内容的最后</span>        c<span class="token operator">-&gt;</span>pending_querybuf <span class="token operator">=</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>pending_querybuf<span class="token punctuation">,</span>                                        c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sdsIncrLen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span>nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    qblen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">&lt;</span> qblen<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">=</span> qblen<span class="token punctuation">;</span>    <span class="token comment">// 记录服务器和客户端最后一次互动的时间</span>    c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token comment">// 如果客户端是 master 的话，更新它的复制偏移量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>read_reploff <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_input_bytes<span class="token punctuation">,</span> nread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span>    <span class="token comment">// 清空缓冲区并释放客户端</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>client_max_querybuf_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sds ci <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bytes <span class="token operator">=</span> <span class="token function">sdscatrepr</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span><span class="token punctuation">,</span> ci<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* There is more data in the client input buffer, continue parsing it     * in case to check if there is a full command to execute. */</span>    <span class="token comment">// 从查询缓存重读取内容，创建参数，并执行命令</span>    <span class="token comment">// 函数会执行到缓存中的所有内容都被处理完为止</span>     <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当一个客户端通过连接应答处理器连接到服务器之后,客户端套接字的AE_READABLE事件和命令请求处理器相关联,当客户端向服务器发送命令请求时,产生AE_READABLE事件引发处理器执行,执行相关套接字读入工作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR  a<span class="token text string">((客户端))</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令请求</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器:客户端套接字产生AE_READABLE事件,执行命令请求处理器]</span></code></pre></li></ul></li><li><p>命令回复处理器</p><ul><li><p>函数sendReplyToClient将服务器执行相关命令得到的命令回复通过套接字返回给客户端</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * 负责传送命令回复的写处理器 */</span> <span class="token keyword">void</span> <span class="token function">sendReplyToClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//具体实现</span><span class="token punctuation">}</span></code></pre><p>具体实现的函数如下:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* Update total number of writes on server */</span>    <span class="token comment">//更新写回复计数器</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_total_writes_processed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> totwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> objlen<span class="token punctuation">;</span>    clientReplyBlock <span class="token operator">*</span>o<span class="token punctuation">;</span>    <span class="token comment">//一直循环直到回复缓冲区为空</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>bufpos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 写入内容到套接字</span>            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时,</span>            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上。</span>            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>buf<span class="token operator">+</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>bufpos<span class="token operator">-</span>c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//出错时跳出循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//写入之后更新写入计数器变量</span>            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            <span class="token comment">/* If the buffer was sent, set bufpos to zero to continue with             * the remainder of the reply. */</span>            <span class="token comment">// 如果缓冲区中的内容已经全部写入完毕</span>            <span class="token comment">// 那么清空客户端的两个计数器变量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> c<span class="token operator">-&gt;</span>bufpos<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>bufpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//取出位于链表最前面的对象</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            objlen <span class="token operator">=</span> o<span class="token operator">-&gt;</span>used<span class="token punctuation">;</span>            <span class="token comment">//空对象不做处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>objlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 写入内容到套接字</span>            <span class="token comment">// c-&gt;sentlen 是用来处理 short write 的</span>            <span class="token comment">// 当出现 short write ，导致写入未能一次完成时，</span>            <span class="token comment">// c-&gt;buf+c-&gt;sentlen 就会偏移到正确（未写入）内容的位置上</span>            nwritten <span class="token operator">=</span> <span class="token function">connWrite</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> o<span class="token operator">-&gt;</span>buf <span class="token operator">+</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-&gt;</span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//写入出错时跳出</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//成功写入时更新计数器变量</span>            c<span class="token operator">-&gt;</span>sentlen <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            totwritten <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>            <span class="token comment">/* If we fully sent the object on head go to the next one */</span>            <span class="token comment">// 如果缓冲区内容全部写入完毕，那么删除已写入完毕的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>sentlen <span class="token operator">==</span> objlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">-=</span> o<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>                <span class="token function">listDelNode</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">,</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">/* If there are no longer objects in the list, we expect                 * the count of reply bytes to be exactly zero. */</span>                <span class="token comment">//list之中没有对象,reply的字节数设置为0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token function">serverAssert</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>reply_bytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 为了避免一个非常大的回复独占服务器，         * 当写入的总数量大于 REDIS_MAX_WRITE_PER_EVENT ，         * 临时中断写入，将处理时间让给其他客户端，         * 剩余的内容等下次写入就绪再继续写入         * 不过，如果服务器的内存占用已经超过了限制，         * 那么为了将回复缓冲区中的内容尽快写入给客户端，         * 然后释放回复缓冲区的空间来回收内存，         * 这时即使写入量超过了 REDIS_MAX_WRITE_PER_EVENT ，         * 程序也继续进行写入*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> NET_MAX_WRITES_PER_EVENT <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>             <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">atomicIncr</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>stat_net_output_bytes<span class="token punctuation">,</span> totwritten<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//写入出错检测</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connGetState</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span> <span class="token operator">!=</span> CONN_STATE_CONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span>                <span class="token string">"Error writing to client: %s"</span><span class="token punctuation">,</span> <span class="token function">connGetLastError</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totwritten <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* For clients representing masters we don't count sending data         * as an interaction, since we always send REPLCONF ACK commands         * that take some time to just fill the socket output buffer.         * We just rely on data / pings received for timeout detection. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span><span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>lastinteraction <span class="token operator">=</span> server<span class="token punctuation">.</span>unixtime<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token operator">-&gt;</span>sentlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* Note that writeToClient() is called in a threaded way, but         * adDeleteFileEvent() is not thread safe: however writeToClient()         * is always called with handler_installed set to 0 from threads         * so we are fine. */</span><span class="token comment">//前面应该是aeDeleteFileEvent()</span>        <span class="token comment">//不能直接删除write handler,因为本身调用就是在线程之中了,aeDeleteFileEvent()线程不安全</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>handler_installed<span class="token punctuation">)</span> <span class="token function">connSetWriteHandler</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Close connection after entire reply has been sent. */</span>        <span class="token comment">// 如果指定了写入之后关闭客户端 FLAG ，那么关闭客户端</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_AFTER_REPLY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">freeClientAsync</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当访问有命令回复需要传送给客户端的时候将客户端套接字的AE_WRITABLE事件和命令回复处理器相关联,当客户端准备好接受服务器传回的命令回复时,产生AE_WRITABLE事件引发处理器执行,执行相关套接字写入工作</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> RL  a<span class="token text string">[服务器:客户端套接字产生AE_WRITABLE事件,执行命令回复处理器]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">发送命令回复</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">((客户端))</span></code></pre><p>回复发送之后就接触命令回复处理器和客户端套接字AE_WRITABLE事件之间的关联</p></li></ul></li><li><p>全过程:</p><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRa<span class="token text string">[客户端]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送连接请求,服务器执行连接应答处理器</span><span class="token arrow operator">--&gt;</span></span>b<span class="token text string">[服务器]</span>a<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">客户端向服务器发送命令请求,服务器执行命令请求处理器</span><span class="token arrow operator">--&gt;</span></span>bb<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">服务器向客户端发送命令回复,服务器执行命令回复处理器</span><span class="token arrow operator">--&gt;</span></span>a</code></pre></li></ul><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>(如serverCron函数)在给定时间点执行,时间事件就是对定时操作的抽象</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定时事件</li><li>周期性事件</li></ul><h4 id="时间事件的结构"><a href="#时间事件的结构" class="headerlink" title="时间事件的结构"></a>时间事件的结构</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//时间事件的结构,种类包括定时事件和周期性事件</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>    <span class="token comment">//事件的唯一标识符,从小到大表示从旧到新</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span>    <span class="token comment">//事件的到达时间</span>    monotime when<span class="token punctuation">;</span>    <span class="token comment">//时间事件处理器,一个函数</span>    <span class="token comment">//时间事件的种类决定于这个函数的返回值</span>    <span class="token comment">//AE_NOMORE表示定时事件,到达一次之后被删除并且不会再次到达</span>    <span class="token comment">//返回其他整数n表示周期性事件,服务器对事件的when属性进行更新,使之n毫秒之后再次到达</span>    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>    <span class="token comment">//事件释放函数</span>    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>    <span class="token comment">//多路复用库的私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>    <span class="token comment">//指向上一个和下一个时间事件结构,形成链表</span>    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token comment">//防止在迭代过程中周期性事件被释放</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">/* refcount to prevent timer events from being     * freed in recursive time event calls. */</span><span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span></code></pre><p>服务器将时间事件都放在一个链表中,每当时间事件处理器执行时遍历链表,对所有已到达的时间事件调用相应的事件处理器.</p><p>新事件放在链表头部,所以链表的头部事件id较大,无序是指when的无序</p><h4 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h4><ul><li><p>函数aeCreateTimeEvent将一个新的时间事件加入到服务器,在当前时间的milliseconds毫秒之后到达</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//创建事件计数器</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">,</span>        aeTimeProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span>        aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//更新时间计数器</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> id <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//创建时间事件结构</span>    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>    te <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>    <span class="token comment">//设置id</span>    te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token comment">//设置事件</span>    te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> milliseconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token comment">//设置事件处理器</span>    te<span class="token operator">-&gt;</span>timeProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>finalizerProc <span class="token operator">=</span> finalizerProc<span class="token punctuation">;</span>    <span class="token comment">//私有数据</span>    te<span class="token operator">-&gt;</span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>    <span class="token comment">//将事件插入链表</span>    te<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>next <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    te<span class="token operator">-&gt;</span>refcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>        te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token punctuation">;</span>    eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token punctuation">;</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数aeDeleteTimeEvent删除给定id的时间事件</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//删除给定的时间事件</span><span class="token keyword">int</span> <span class="token function">aeDeleteTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    <span class="token comment">//遍历链表</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//发现目标事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//修改id之后,在processTimeEvents的时候删除</span>            te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>            <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span> <span class="token comment">/* NO event with the specified ID found  */</span><span class="token punctuation">}</span></code></pre></li><li><p>函数usUntilEarliestTimer返回到达时间距离当前时间最近的时间事件到达耗时</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//返回距离第一个时间事件触发的毫秒数</span><span class="token comment">//需要遍历链表,定时一般来说时间事件不多,遍历时间很短</span><span class="token keyword">static</span> <span class="token class-name">int64_t</span> <span class="token function">usUntilEarliestTimer</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeTimeEvent <span class="token operator">*</span>te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>te <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    aeTimeEvent <span class="token operator">*</span>earliest <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>earliest <span class="token operator">||</span> te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span>            earliest <span class="token operator">=</span> te<span class="token punctuation">;</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>now <span class="token operator">&gt;=</span> earliest<span class="token operator">-&gt;</span>when<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> earliest<span class="token operator">-&gt;</span>when <span class="token operator">-</span> now<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>函数processTimeEvents</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//处理到达的时间事件</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> maxId<span class="token punctuation">;</span>    <span class="token comment">//遍历链表执行已到达的事件</span>    te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span><span class="token comment">//指向链表头部</span>    maxId <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventNextId<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    monotime now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>        <span class="token comment">/* Remove events scheduled for deletion. */</span>        <span class="token comment">//之前id已经设置为AE_DELETED_EVENT_ID的事件需要删除掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">==</span> AE_DELETED_EVENT_ID<span class="token punctuation">)</span> <span class="token punctuation">{</span>            aeTimeEvent <span class="token operator">*</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token comment">/* If a reference exists for this timer event,             * don't free it. This is currently incremented             * for recursive timerProc calls */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>refcount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//有迭代子程序调用的事件不删除</span>                te <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//修改相关的指针</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>prev<span class="token punctuation">)</span>                te<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                eventLoop<span class="token operator">-&gt;</span>timeEventHead <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>                te<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> te<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>            <span class="token comment">//执行清理处理器</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>finalizerProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>                te<span class="token operator">-&gt;</span><span class="token function">finalizerProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>                now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//释放要删除的时间事件</span>            <span class="token function">zfree</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">;</span>            te <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Make sure we don't process time events created by time events in         * this iteration. Note that this check is currently useless: we always         * add new timers on the head, however if we change the implementation         * detail, this check may be useful again: we keep it here for future         * defense. */</span>        <span class="token comment">//无效事件跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>id <span class="token operator">&gt;</span> maxId<span class="token punctuation">)</span> <span class="token punctuation">{</span>            te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//当前时间大于等于时间事件的when,事件已到达,执行这个事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-&gt;</span>when <span class="token operator">&lt;=</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> retval<span class="token punctuation">;</span>            id <span class="token operator">=</span> te<span class="token operator">-&gt;</span>id<span class="token punctuation">;</span>            te<span class="token operator">-&gt;</span>refcount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//执行对应的文件处理器,记录返回值</span>            retval <span class="token operator">=</span> te<span class="token operator">-&gt;</span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>            te<span class="token operator">-&gt;</span>refcount<span class="token operator">--</span><span class="token punctuation">;</span>            processed<span class="token operator">++</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token function">getMonotonicUs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//区分是否是定时事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> AE_NOMORE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//retval毫秒之后再次执行</span>                te<span class="token operator">-&gt;</span>when <span class="token operator">=</span> now <span class="token operator">+</span> retval <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">//直接删除</span>                te<span class="token operator">-&gt;</span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> processed<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>serverCron就是非常典型的周期性时间事件,服务器只要在运行就要周期性运行这个函数</p></li></ul><h2 id="redis运行流程"><a href="#redis运行流程" class="headerlink" title="redis运行流程"></a>redis运行流程</h2><pre class="language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LRid1<span class="token text string">[启动服务器]</span><span class="token arrow operator">--&gt;</span>id7<span class="token text string">[配置和加载初始化]</span><span class="token arrow operator">--&gt;</span>id8<span class="token text string">[创建事件循环]</span><span class="token arrow operator">--&gt;</span>id10<span class="token text string">[开始socket监听]</span><span class="token arrow operator">--&gt;</span>id9<span class="token text string">[向循环事件中注册serverCron]</span><span class="token keyword">subgraph</span> 循环id9<span class="token arrow operator">--&gt;</span>id2<span class="token text string">{是否关闭服务器}</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">否</span><span class="token arrow operator">--&gt;</span></span>id4<span class="token text string">[等待文件事件产生]</span>id4<span class="token arrow operator">--&gt;</span>id5<span class="token text string">[处理产生的文件事件]</span><span class="token arrow operator">--&gt;</span>id6<span class="token text string">[处理已到达的时间事件]</span><span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">开始新的事件循环</span><span class="token arrow operator">--&gt;</span></span>id2<span class="token keyword">end</span>id2<span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">是</span><span class="token arrow operator">--&gt;</span></span>id3<span class="token text string">[关闭服务器]</span></code></pre><p><img src="/2022/01/27/redis-shi-jian/main_start_event_loop-3251881.png" alt="main_start_event_loop"></p><p>两张图的方式都差不多,展示了整个redis的过程</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis单机数据库以及持久化</title>
      <link href="/2022/01/27/redis-dan-ji-shu-ju-ku/"/>
      <url>/2022/01/27/redis-dan-ji-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="单机数据库实现和持久化"><a href="#单机数据库实现和持久化" class="headerlink" title="单机数据库实现和持久化"></a>单机数据库实现和持久化</h1><h2 id="数据库细节实现"><a href="#数据库细节实现" class="headerlink" title="数据库细节实现"></a>数据库细节实现</h2><ul><li><p>数据库的数据结构</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token comment">// 数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>                 <span class="token comment">/* The keyspace for this DB */</span>    <span class="token comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>              <span class="token comment">/* Timeout of keys with a timeout set */</span>    <span class="token comment">// 正处于阻塞状态的键</span>    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>        <span class="token comment">/* Keys with clients waiting for data (BLPOP)*/</span>    <span class="token comment">// 可以解除阻塞的键</span>    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>           <span class="token comment">/* Blocked keys that received a PUSH */</span>    <span class="token comment">// 正在被 WATCH 命令监视的键</span>    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>         <span class="token comment">/* WATCHED keys for MULTI/EXEC CAS */</span>    <span class="token comment">//数据库编码</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                     <span class="token comment">/* Database ID */</span>    <span class="token comment">// 数据库的键的平均 TTL ，统计信息</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>          <span class="token comment">/* Average TTL, just for stats */</span>    <span class="token comment">//过期指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> expires_cursor<span class="token punctuation">;</span> <span class="token comment">/* Cursor of the active expire cycle. */</span>    <span class="token comment">//即将整理的键名称,用一个list保存</span>    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>         <span class="token comment">/* List of key names to attempt to defrag one by one, gradually. */</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></code></pre></li></ul></li></ul><ul><li>Hash table type implementation<ul><li>tryResizeHashTables()用于缩小字典体积：如果字典的使用率比 HASHTABLE_MIN_MINFILL 常量要低，那么通过缩小字典的体积来节约内存,htNeedsResize()就是比较这两个大小的函数,在有孩子进程的时候不会进行resize</li><li>服务器在对数据库执行增删改查命令时会对数据库进行渐进式 rehash ,但如果服务器长期没有执行命令的话，数据库字典的 rehash 就可能一直没办法完成,为了防止出现这种情况，incrementallyRehash()主动 rehash ,执行了rehash之后返回1,否则返回0</li></ul></li></ul><h3 id="过期功能实现"><a href="#过期功能实现" class="headerlink" title="过期功能实现"></a>过期功能实现</h3><ul><li><p>设置生存和过期时间</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211110165635236.png" alt="image-20211110165635236"></p></li><li><p>带有生存和过期时间的数据库</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211110165743757.png" alt="image-20211110165743757"></p><p>添加过期时间就是在过期字典中添加项目,移除过期时间就是在过期字典中删除对应的项目,键过期时间和当前时间做差就可以计算出生存时间.</p></li><li><p>过期键删除:</p><ul><li><p>惰性删除</p><ul><li><p>db.c的expireIfNeeded()函数对于所有的输入键检查是否过期,过期的键直接删除</p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111154024925.png" alt="image-20211111154024925"></p><ul><li>定期删除<ul><li>由expire.c中的activeExpireCycle()函数实现定期删除,当服务器定期执行server.c的serverCron()函数时,就会调用,在expire字典中随机检查一部分键的过期时间,并且删除其中的过期键.</li></ul></li></ul></li><li><p>RDB对于过期键处理</p><ul><li>生成时过期键不加入RDB文件中</li><li>主服务器载入时检查键是否过期,过期键不加入数据库;从服务器不检查,但是会和主服务器同步数据,同步的时候也会清除过期键</li></ul></li><li><p>AOF对于过期键处理</p><ul><li><p>写入时如果键过期但没有删除,不会影响,当(惰性或者定期)删除的时候追加一条DEL</p><ul><li><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111214557807.png" alt="image-20211111214557807"></li></ul></li><li><p>重写入的时候检查键是否过期,过期键不加入数据库</p></li></ul></li><li><p>复制对于过期键处理</p><ul><li><p>主服务器处理,之后对从服务器发送DEL,从服务器对于过期键不做处理</p></li><li><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111220239415.png" alt="image-20211111220239415"></p><p><img src="/2022/01/27/redis-dan-ji-shu-ju-ku/image-20211111220255616.png" alt="image-20211111220255616"></p></li></ul></li></ul></li></ul><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><ul><li><p>可以监视对键的操作情况,或者是监视某个指令的使用情况</p></li><li><p>由notify.c/notifyKeyspaceEvent()函数实现:</p></li></ul></li></ul><pre class="language-c#" data-language="c#"><code class="language-c#">/* The API provided to the rest of the Redis core is a simple function: *实现了发送数据库通知的功能 * notifyKeyspaceEvent(int type, char *event, robj *key, int dbid); * * 'type' is the notification class we define in `server.h`. * type是当前想要发送的通知的类型,根据这个判断通知发送与否,提前在server.h中定义过种类 * 'event' is a C string representing the event name. *  event 参数是一个字符串表示的事件名 * 'key' is a Redis object representing the key name. * key 参数是一个 Redis 对象表示的键名,是产生事件的键 * 'dbid' is the database ID where the key lives. * dbid 参数为键所在(产生事件)的数据库   * 每当一个redis命令需要发送数据库通知的时候,都会调用此函数,向函数传递命令的相关信息*/void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {    sds chan;    robj *chanobj, *eventobj;    int len = -1;    char buf[24];    /* If any modules are interested in events, notify the module system now.     * This bypasses the notifications configuration, but the module engine     * will only call event subscribers if the event type matches the types     * they are interested in. */     moduleNotifyKeyspaceEvent(type, event, key, dbid);    /* If notifications for this class of events are off, return ASAP.     如果给定通知不是服务器允许发送的通知,直接返回*/    if (!(server.notify_keyspace_events &amp; type)) return;    eventobj = createStringObject(event,strlen(event));    /* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */    //发送键空间通知    if (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) {        chan = sdsnewlen("__keyspace@",11);        len = ll2string(buf,sizeof(buf),dbid);        chan = sdscatlen(chan, buf, len);        chan = sdscatlen(chan, "__:", 3);        chan = sdscatsds(chan, key-&gt;ptr);        chanobj = createObject(OBJ_STRING, chan);        pubsubPublishMessage(chanobj, eventobj);//通过publish发送通知        decrRefCount(chanobj);    }    /* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */    //发送键时间通知    if (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) {        chan = sdsnewlen("__keyevent@",11);        //初始化为-1,加入前面发送键空间通知的时候计算过了就不会是-1,少计算一次        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);        chan = sdscatlen(chan, buf, len);        chan = sdscatlen(chan, "__:", 3);        chan = sdscatsds(chan, eventobj-&gt;ptr);        chanobj = createObject(OBJ_STRING, chan);        pubsubPublishMessage(chanobj, key);        decrRefCount(chanobj);    }    decrRefCount(eventobj);}</code></pre><p>​    </p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>redis是内存数据库,RDB持久化将数据库状态保存到磁盘里面,避免数据意外丢失</p><p>RDB文件时压缩的二进制文件,可以用这个文件恢复数据库状态,主要使用save和bgsave实现</p><h3 id="创建和载入"><a href="#创建和载入" class="headerlink" title="创建和载入"></a>创建和载入</h3><ul><li>save创建RDB文件,但是会阻塞服务器;bgsave生成一个子进程,专门负责生成RDB文件</li><li>只要有RDB文件在,就会自动载入RDB文件(如果开启了AOF持久化功能,会优先使用AOF文件还原数据库)</li><li>bgsave执行期间不能执行save,bgsave(防止竞争条件);也不能执行bgrewriteaof,因为都会有大量的磁盘写入</li></ul><h3 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h3><h4 id="设置自动保存条件"><a href="#设置自动保存条件" class="headerlink" title="设置自动保存条件"></a>设置自动保存条件</h4><p>设定自动保存的条件,达到条件时自动运行bgsave</p><p>条件保存在redisServer的saveparams属性中</p><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h4><ul><li>dirty计数器记录上次成功执行save或者bgsave之后服务器对数据库进行修改的次数</li><li>lastsave记录了上次成功save的时间</li></ul><h4 id="检查保存条件"><a href="#检查保存条件" class="headerlink" title="检查保存条件"></a>检查保存条件</h4><p>serverCron函数默认没100ms就要执行一次,维护当前运行的数据库,同时也检查了自动保存条件是否满足,只要有一个条件满足了就要执行bgsave</p><h2 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h2><p>通过保存所有的写命令记录数据库状态</p><p>写命令执行之后加到redisServer的aof_buf缓冲区末尾,在处理事件循环的时候决定是否将缓冲区的值写入到AOF文件</p><p>数据还原的时候先创建不带网络连接的伪客户端,直接使用来自AOF文件中的命令,挨个执行,最终执行完毕就是数据库的状态</p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><ul><li><p>直接读取当前状态,对于每个键直接使用add指令读取最后的状态作为一个add添加进去.</p></li><li><p>开始执行重写之后可能会继续执行指令,对于数据库进行修改,因此建立了AOF重写缓冲区,新指令同时同步到AOF缓冲区和AOF重写缓冲区</p></li><li><p>完成重写之后直接覆盖原来的AOF文件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2022/01/27/redis-ji-chu/"/>
      <url>/2022/01/27/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><ul><li>字符串长度保存在本体中,获取需要常数时间复杂度</li><li>header包含的部分:<ul><li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li><li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li><li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。</li></ul></li><li>缓冲区不会溢出</li><li>减少修改时的内存重分配次数<ul><li>空间预分配</li><li>alloca记录分配的总空间,惰性空间释放</li></ul></li><li>除了自己加上的头部字段,其他和c函数一样,兼容相关函数</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>双向链表</li><li>无环,头指针的prev,尾指针的next都指向null</li><li>自带指向头指针和尾指针的指针</li><li>链表具有链表长度计数器,标识长度</li><li>void *可以保存不同类型的值</li></ul><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>基于哈希表实现,采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子超过预定值时自动扩展内存，引发重哈希,并且在重哈希的过程中,每次增删改查推进一步重哈希,避免重哈希期间单个请求的响应时间剧烈增加.</p><p>实现增量式重哈希，dict的数据结构里包含两个哈希表。在重哈希期间，数据从第一个哈希表向第二个哈希表迁移</p><ul><li><p>hash table结构:</p><ul><li>一个dictEntry指针数组（table）。key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li><li>size：标识dictEntry指针数组的长度。它总是2的指数。</li><li>sizemask：用于将哈希值映射到table的位置索引。它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。</li><li>used：记录dict中现有的数据个数。它与size的比值就是装载因子（load factor）。这个比值越大，哈希值冲突概率越高。</li></ul></li><li><p>单个dictentry结构:</p><ul><li>```c<br>typedef struct dictEntry {<pre><code>void *key;//键union {    void *val;    uint64_t u64;    int64_t s64;    double d;} v;//值struct dictEntry *next;     /* 具有相同的hash值,先通过链表链接起来Next entry in the same hash bucket. */void *metadata[];           /* An arbitrary number of bytes (starting at a                             * pointer-aligned address) of size as returned                             * by dictType's dictEntryMetadataBytes(). */</code></pre>} dictEntry;<pre class="language-none"><code class="language-none">    - dict本身结构:  ```c  //字典本身  struct dict {      dictType *type;//类型函数      /*dictEntry指针数组（table）。      key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。      如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。      只有在重哈希的过程中，ht_table[0]和ht_table[1]才都有效。      而在平常情况下，只有ht_table[0]有效，ht_table[1]里面没有任何数据。*/      dictEntry **ht_table[2];//hash表      /*记录dict中现有的数据个数。      它与size的比值就是装载因子（load factor）。      这个比值越大，哈希值冲突概率越高。*/      unsigned long ht_used[2];      // rehash 索引      // 当 rehash 不在进行时，值为 -1,它的值记录了当前重哈希进行到哪一步了      long rehashidx; /* rehashing not in progress if rehashidx == -1 */        /* Keep small vars at end for optimal (minimal) struct padding */      /* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */      int16_t pauserehash; //大于0表示rehash计算停止,小于0编码错误      signed char ht_size_exp[2]; /* 记录大小的次方,exponent of size. (size = 1&lt;&lt;exp) */  };</code></pre></li></ul></li><li><p>rehash过程:</p><ul><li>大小选择:<ul><li>扩展时第二个hash表的大小是大于等于第一个的used*2的第一个$2^n$</li><li>收缩时第二个hash表的大小是大于等于第一个的used的第一个$2^n$</li></ul></li><li>rehash的时候重新计算键的哈希值和索引值</li><li>所有键值对rehash结束之后就直接把新的hash表当作原来的hash表</li><li>rehash进行时,每次增删改查都会顺带把第一个哈希表上面相应rehashidx索引上面的所有键值对rehash到第二个表上,rehash完成之后将rehashidx值增加一</li><li>当rehash完成之后,rehashidx的值设置成-1</li></ul></li></ul><h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><ul><li><p>基本结构:</p><ul><li>```c<br>typedef struct zskiplistNode {<pre><code>//zadd命令在将数据插入到skiplist里面之前先进行了解码，所以存储的一定是一个sds//为了方便在查找的时候对数据进行字典序的比较，//而且，skiplist里的value部分是数字的可能性也比较小,不是很方便压缩sds ele;double score;//指向链表前一个节点的指针（前向指针）//每个节点只有1个前向指针(没有依靠level分开)，所以只有第1层链表是一个双向链表struct zskiplistNode *backward;//存放指向各层链表后一个节点的指针（后向指针）//是一个柔性数组,占用内存不在zskiplistNode结构里面，需要插入节点的时候单独为它分配//所以skiplist的每个节点所包含的指针数目是不固定的struct zskiplistLevel {    //每层对应1个后向指针，用forward字段表示    struct zskiplistNode *forward;    //表示当前的指针跨越了多少个节点,用于计算元素排名    unsigned long span;} level[];</code></pre>} zskiplistNode;<pre class="language-none"><code class="language-none">- ```c  //真正的skiplist结构  typedef struct zskiplist {      struct zskiplistNode *header, *tail;      unsigned long length;//链表长度,头指针为空,不算在计数中      int level;//总层数  } zskiplist;</code></pre></li></ul></li><li><p>层数随机决定(1-32,幂次随机算法)</p></li><li><p>分值可以相同,但是对应成员必须不一样</p></li></ul><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><ul><li><p>不会出现重复元素</p></li><li><p>结构:</p><ul><li>```c<br>//由整数组成的有序集合,便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合<br>typedef struct intset {<pre><code>//整个统一的数据编码，表示intset中的每个数据元素用几个字节来存储//intset中存储的整数最多只能占用64bit//随着数据添加,可能改变数据编码,比如一些比较大的整数uint32_t encoding;//inset中的元素个数uint32_t length;//一个柔性数组,长度等于encoding * length,用于表达偏移量//contents需要单独为其分配空间，这部分内存不包含在intset结构当中int8_t contents[];</code></pre>} intset;<pre class="language-none"><code class="language-none">- 当原来的encoding大小不够新的数据存储时,需要升级数据编码  - 先扩充整个集合底层数组大小,分配新元素空间  - 原来的数据类型转换  - 添加新元素(一般来说新元素都在开头或者末尾位置)- 有点像数组的排列,中间插入元素需要整个向后移动,修改代价比较高### ziplist- 列表键只包含少量列表键,值的储存是变长的- 将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存- 结构:  - 源代码：        ```c    typedef struct {        /* When string is used, it is provided with the length (slen). */        unsigned char *sval;        unsigned int slen;        /* When integer is used, 'sval' is NULL, and lval holds the value. */        long long lval;    } ziplistEntry;    //ziplist的数据类型，没有用自定义的struct之类的来表达，    //而就是简单的unsigned char *。    //这是因为ziplist本质上就是一块连续内存，    //内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</code></pre></li><li>zlentry结构：<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* We use this function to receive information about a ziplist entry. * Note that this is not how the data is actually encoded, is just what we * get filled by a function in order to operate more easily. */</span><span class="token comment">//每一个entry的格式</span><span class="token comment">//记录长度是为了方便指针运算确定偏移量</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">/* Bytes used to encode the previous entry len*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">/* Previous entry len. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>        <span class="token comment">/* Bytes used to encode this entry type/len.                                    For example strings have a 1, 2 or 5 bytes                                    header. Integers always use a single byte.*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token comment">/* Bytes used to represent the actual entry.                                    For strings this is just the string length                                    while for integers it is 1, 2, 3, 4, 8 or                                    0 (for 4 bit immediate) depending on the                                    number range. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">/* prevrawlensize + lensize. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on                                    the entry encoding. However for 4 bits                                    immediate integers this can assume a range                                    of values and must be range-checked. */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>            <span class="token comment">/* Pointer to the very start of the entry, that                                    is, this points to prev-entry-len field. */</span><span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>添加/删除节点的时候很可能出现连锁更新</p></li></ul><h2 id="robj-server-h"><a href="#robj-server-h" class="headerlink" title="robj(server.h)"></a>robj(server.h)</h2><p>对象的类型一般是指value的类型,和key类型无关(key一般都是string)</p><ul><li><p>作用:</p><ul><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul></li><li><p>结构:</p><ul><li>源代码：<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>    <span class="token comment">//对象的数据类型</span>    <span class="token comment">//可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，</span>    <span class="token comment">//分别对应Redis对外暴露的5种数据结构</span>    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">//对象的内部表示方式（也可以称为编码）</span>    <span class="token comment">//可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量</span>    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">//lru算法记录使用的数据</span>    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* LRU time (relative to global lru_clock) or                            * LFU data (least significant 8 bits frequency                            * and most significant 16 bits access time). */</span>    <span class="token comment">//引用计数,允许robj在一定情况下被共享</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment">//数据指针,指向真正的数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">}</span> robj<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>string对象:</p><ul><li>接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象</li><li>然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式</li></ul></li><li><p>list对象</p><ul><li>一般使用ziplist</li></ul></li><li><p>哈希对象</p><ul><li>使用ziplist或者hashtable</li><li>ziplist:<ul><li>键值对相邻,先压入键再压入值</li><li>直接往尾部添加</li></ul></li><li>hashtable:<ul><li>使用dict实现</li><li>dict的键保存键,值保存值</li></ul></li></ul></li><li><p>集合</p><ul><li>使用intset或者hashtable</li><li>使用hashtable实现时,字典每个键都是一个字符串对象,对应一个集合元素,字典值设为null</li></ul></li><li><p>有序集合</p><ul><li>使用ziplist或者skiplist</li></ul></li><li><p>多态指令:</p><ul><li>根据对象的类型编码决定指令的具体函数与实现方式决定要调用的函数</li><li>执行指令前像检查对应键或者值能否正确执行相关函数指令</li></ul></li><li><p>内存回收</p><ul><li>通过引用计数在适当时候释放对象并回收内存<ul><li>创建时引用数加一</li><li>被新程序使用时引用数加一</li><li>程序不再使用,引用数减一</li><li>引用数变成0,内存释放</li></ul></li></ul></li><li><p>对象共享</p><ul><li>共享就是利用refcount实现的,每多一个共享的就加一</li><li>提前准备了0到9999的字符串对象共享</li></ul></li><li><p>空转时长</p><ul><li>lru记录最后一次被程序访问的时间,当前时间减去lru时间就是空转时长</li><li>(打印空转时长并不会更新lru值)</li><li>当内存比较满时,最先被释放的是lru最早的那些键</li></ul></li></ul><h2 id="数据类型实现"><a href="#数据类型实现" class="headerlink" title="数据类型实现"></a>数据类型实现</h2><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><ul><li>setGenericCommand()函数实现了SET,SETEX,PSETEX,SETNX指令<ul><li>expire 定义了 Redis 对象的过期时间</li><li><em>ok_reply 和 abort_reply 决定了命令回复的内容，NX 参数和 XX 参数也会改变回复。</em><ul><li><em>如果 ok_reply 为 NULL ，那么 “+OK” 被返回。如果 abort_reply 为 NULL ，那么 “$-1” 被返回。</em></li></ul></li></ul></li><li>getExpireMillisecondsOrReply()实现了过期处理,从客户请求中处理过期的robj</li><li>parseExtendedStringArgumentsOrReply()判断当前字符串操作指令的有效性</li><li>*getexCommand()*对于GET的多余参数进行处理,和GET不同,这个指令不是仅可读的</li><li>setrangeCommand()函数中感觉有个地方可以优化,sdslen只能为0或者正值,那么可以减少一个地方的判断,少用一个if语句</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3W1H | 关于写博客的反思</title>
      <link href="/2022/01/26/guan-yu-xie-bo-ke-de-si-kao/"/>
      <url>/2022/01/26/guan-yu-xie-bo-ke-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h1 id="3W1H-关于写博客的反思"><a href="#3W1H-关于写博客的反思" class="headerlink" title="3W1H | 关于写博客的反思"></a>3W1H | 关于写博客的反思</h1><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><p>也就是之前只是做了一个比较粗糙的主页，现在想要丰富一下自己的页面</p><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><p>大概就是记录自己学习过程的东西吧，主要做的就是redis方面的</p><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><p>更多只是自己学习方面的记录，我觉得有时间摸摸鱼写一下就是很给博客面子了</p><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2><p>不准备花多少时间哈哈哈哈哈哈我可能就是心血来潮搞一下而已</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/26/hello-world/"/>
      <url>/2022/01/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
